<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>自己満足プログラミング</title>
    <description>Reinventing the wheel.</description>
    <link>https://happyclam.github.io/</link>
    <atom:link href="https://happyclam.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 08 Oct 2025 21:01:03 +0900</pubDate>
    <lastBuildDate>Wed, 08 Oct 2025 21:01:03 +0900</lastBuildDate>
    <generator>Jekyll v3.10.0</generator>
    
      <item>
        <title>C++よりJSの方が速い！？</title>
        <description>&lt;h3 id=&quot;期待が高過ぎたみたい&quot;&gt;期待が高過ぎたみたい&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2025-08-07/OOP&quot;&gt;前回の記事&lt;/a&gt;で&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;３三将棋アプリ&lt;/code&gt;&lt;/a&gt;のソースを元に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えた話を書きましたが、なんと出来上がった&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++製&lt;/code&gt;のプログラムは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript(JavaScript)製&lt;/code&gt;のものより遅い結果となりました。当ブログで度々「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にすればもっと深く読めるのに〜」なんて書いてきましたが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に対する期待が高過ぎたようです。たとえ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にとって不利なデータ構造であっても、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にはそんなものでは超えられないほどの実行速度の優位性があると信じていたのですが、認識が間違っていたようです。&lt;br /&gt;
　実行速度を比較する際は、実際に作ってみないと正確には分からないという点が辛いところですが、今回は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok4&lt;/code&gt;にほぼ丸投げで試すことが出来たので、その点は助かりました。&lt;/p&gt;

&lt;h3 id=&quot;c版がどれぐらい遅いのか&quot;&gt;C++版がどれぐらい遅いのか&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;CoffeeScriptの３三将棋アプリのレポジトリ&lt;/a&gt;と&lt;a href=&quot;https://github.com/happyclam/shogi33.git&quot;&gt;C++版のリポジトリ&lt;/a&gt;の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;README.mdファイル&lt;/code&gt;に、先手・後手双方をAI同士で対戦させた実行例を記載していますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1781ミリ秒&lt;/code&gt;で終了する対局が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;では倍以上の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4434ミリ秒&lt;/code&gt;掛かっています。興味のある方は開発環境を用意すれば再現できます。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;が提案するコンパイルオプションもいろいろ試しましたが、ほとんど効果はありませんでした。&lt;/p&gt;

&lt;h3 id=&quot;chatgptgpt-5によるアドバイス&quot;&gt;ChatGPT(GPT-5)によるアドバイス&lt;/h3&gt;
&lt;p&gt;　以下の質問から始めて、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;にいろいろアドバイスを求めました。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;同じアルゴリズムとデータ構造で作ったJavascriptとC++のゲームプログラムがあって、Javascript製の方が実行速度が速いとき、どのような原因が考えられますか？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　会話の中で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;に言われたことをいくつか箇条書きにしてみます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;「同じアルゴリズム・データ構造で作ったゲームプログラムで、C++よりJavaScriptの方が速い」というのは直感に反しますが、実際に起こり得ます。&lt;/li&gt;
  &lt;li&gt;なるほど！Piece という抽象クラスがあって、それを継承した Pawn, Rook, Bishop … みたいな形で設計されているわけですね。これはオブジェクト指向的にきれいなんですが、将棋AIの「思考部分（探索＋評価）」ではかなり不利です。&lt;/li&gt;
  &lt;li&gt;なるほど…😅将棋AIをオブジェクト指向で作っている場合、&lt;strong&gt;「設計としてはきれい」だけど「パフォーマンス的には厳しい」&lt;/strong&gt;という典型的な状況にハマっていますね。&lt;/li&gt;
  &lt;li&gt;今の実装は「オブジェクト指向的にはきれい」だけど、性能的には JS エンジンの hidden class 最適化に負けているのが原因です。抽象クラスを廃止して struct+enum にするだけで、C++ の方が確実に速くなるはずです。&lt;/li&gt;
  &lt;li&gt;ここが C++ 版が JS に負けている一番の原因候補です。JS のオブジェクトは 実際には JIT によって連続配列のように最適化されます。一方 C++ の「駒ごとのオブジェクト集合＋ポインタ参照」はメモリがバラバラに配置される、毎回ポインタを間接参照する、キャッシュミスが頻発するので「CPU が待ち時間ばかり」で全然速くならない、という現象が起こります。&lt;br /&gt;
　実際、将棋エンジンやチェスエンジンは &lt;strong&gt;必ず「盤面を配列で表現」&lt;/strong&gt;しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　巷に出回っている将棋ソフトの真似ではなく自分で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;オプジェクト志向&lt;/code&gt;で作ってみたいと思って作り始めた（元々は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;で作ってました）ので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;に指摘された内容はある程度認識していましたが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;のようなコンバイラ言語なら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript(JavaScript)&lt;/code&gt;より遅くなることはないだろう、なんて勝手に思っていました。それに&lt;strong&gt;JS エンジンの hidden class 最適化&lt;/strong&gt;なんてことは、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;に指摘されるまで知りませんでした。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;って自分が思っていたより元々速いんですね。&lt;br /&gt;
　そう言えば同じアルゴリズムとデータ構造で昔作った&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;製の将棋ソフトより&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;の方が断然速いなぁとは感じてました。&lt;/p&gt;

&lt;h3 id=&quot;小さなリファクタリング&quot;&gt;小さなリファクタリング&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;に、大きなリファクタリングが大変なら以下のような高速化案がありますと言われました。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;vtableを極力通さない&lt;br /&gt;
もし 駒種はコンストラクタで固定なら、Piece に「enum型のメンバー」を持たせておけば仮想関数を呼ばずに済みます。→ piece-&amp;gt;type に直接アクセスできれば、仮想関数呼び出しを消せる。&lt;/li&gt;
  &lt;li&gt;駒オブジェクトをヒープでなく配列に置く&lt;br /&gt;
new してポインタ管理するのではなく、最初にstatic Piece allPieces[MAX_PIECES];を作って Board はポインタではなく インデックス（int）で参照する。&lt;br /&gt;
これなら 全駒が連続配置されるのでキャッシュ効率が改善します。&lt;/li&gt;
  &lt;li&gt;評価関数の高速化&lt;br /&gt;
もし各駒に evaluate() があるなら呼ばずに、
switch(piece-&amp;gt;type)
あるいは pieceSquareTable の配列参照に置き換えるだけでもだいぶ速くなるはず。&lt;/li&gt;
  &lt;li&gt;コンパイルオプションで粘る&lt;br /&gt;
既に -O2 をお使いですが、&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ -O3 -march=native -flto=8 -funroll-loops -DNDEBUG&lt;/code&gt;&lt;br /&gt;
を試すと、関数インライン化やループ展開が強化されて多少マシになります。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　簡単に試せそうなのでソース全体を通して1.の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;からのアドバイスを実装してみました（koma-&amp;gt;getKind()で駒種を取得していた処理をやめて、publicなenum型のconstメンバ変数を追加してkoma-&amp;gt;typeで駒種を判定）が、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4434ミリ秒&lt;/code&gt;掛かっていた処理が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;400m秒&lt;/code&gt;程短縮出来ただけで全然&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript(JavaScript)&lt;/code&gt;には敵いません。&lt;br /&gt;
　ということで、今の&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;将棋・チェス関連アプリ&lt;/a&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;のまま置いておくのが一番良いのかなと思っていて、改善するにしても今の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のまま改善していく方向で考えています。&lt;/p&gt;

&lt;h3 id=&quot;それでもoopが好き&quot;&gt;それでもOOPが好き&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP（オブジェクト指向プログラミング）&lt;/code&gt;を絶対視する気はありませんが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP言語&lt;/code&gt;を使う限りは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;すべきなんじゃない？なんて思ってましたが、実効性を重視するなら拘らないほうがいいのかもしれません。昔、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rails&lt;/code&gt;のプロジェクトでありながら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORM（O/Rマッパー）&lt;/code&gt;を使わずに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL文&lt;/code&gt;を書いているなんてプロジェクトの話を聞いたことがありますし、もしかして&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Go言語&lt;/code&gt;や&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt;など&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;非OOP言語&lt;/code&gt;が勢力を伸ばして来ているのは、よく知りませんが、実行速度を上げること（PCが処理しやすい）を重視する流れなのかもしれません。&lt;strong&gt;今後プログラムは人間が書くものではなくAIが書くもの？&lt;/strong&gt;という流れの一貫で、人間側に寄せるのか？プログラムを実行するコンピュータ側に寄せるのか？という話なのかもしれません。&lt;br /&gt;
　でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rails&lt;/code&gt;が出てきた頃に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORM&lt;/code&gt;に感動した自分としては、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rails&lt;/code&gt;を使いながら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL文&lt;/code&gt;を書くなんていう本末転倒なプロジェクトには参加したくありませんし、今後も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;で作りたいと思ってます。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「OOPとは何か？」&lt;/code&gt;なんて話をすると主語が大きくなりすぎて自分には語れませんが、直感的に人間が理解しやすいと思うんですよねぇ。今回のケースも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;が悪いということではなく、まだまだ改善の余地があると思ってます。というか、取り敢えず機能を実現することを優先していて、高速化に関しては深く考えていませんでした。後は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にすれば自然と速くなるだろう、なんて考えながらも手を付けられずに長い間放置していた感じです。&lt;br /&gt;
　新規に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GUI&lt;/code&gt;から作ることを考えれば現状の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のリファクタリング＆高速化に着手するほうが楽ですし、どれ程の結果が出るか未知数ですがいつくかアイデアもあるので試してみたいと思ってます。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sat, 23 Aug 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-08-23/JSvsCPlus</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-08-23/JSvsCPlus</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>c++</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>３三将棋CUI版のC++バージョン</title>
        <description>&lt;h3 id=&quot;共通点はオブジェクト指向プログラミング言語&quot;&gt;共通点はオブジェクト指向プログラミング言語&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2025-06-07/kotlins_recursion&quot;&gt;前回の記事&lt;/a&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;製のウォーターソートパズル解答プログラムを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok4&lt;/code&gt;を使って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;や&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えましたが、極短時間で移行出来たのは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;オブジェクト指向プログラミング（OOP）言語&lt;/code&gt;だったということも一つの要因だと思います。&lt;br /&gt;
　現在公開している&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「３三将棋の簡易版」&lt;/code&gt;&lt;/a&gt;も一応&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP言語&lt;/code&gt;である&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;で書いているので、移行しやすいだろうと思いやってみました。もし元のコードが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;素のJavascript（Vanilla JS）&lt;/code&gt;だったら大変だったろうと思います。&lt;/p&gt;

&lt;h3 id=&quot;coffeescriptはoopオブジェクト指向プログラミング言語&quot;&gt;CoffeeScriptはOOP（オブジェクト指向プログラミング）言語&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;もどんどん変化していて現在はそうでもありませんが、私は昔は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;が嫌いでした。でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cordova&lt;/code&gt;を使って手軽に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Androidアプリ&lt;/code&gt;を作成するために必要だったので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AltJS&lt;/code&gt;である&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;なら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;出来ると喜んで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;の替わりに使ったのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;を意識しながら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;を使っていた人は少ないと思います。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rails&lt;/code&gt;のプロジェクト内でちょっとした関数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;で作ってみるぐらいが普通の使われ方だったと思います。&lt;br /&gt;
　でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;は一応&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP言語&lt;/code&gt;で、static変数・メソッドとインスタンス変数・メソッド、publicな変数・メソッドとprivateな変数・メソッドを区別して記述することが出来ますし、クラスの継承も可能です。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AltJS&lt;/code&gt;なので結局は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;の制限に縛られるので、スコープの有効性等がどれだけ厳密に守られてるのかは知らないのですが気分は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;のままコードが書けます。&lt;br /&gt;
　ということで、公開している&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript製&lt;/code&gt;の&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋の簡易版」リポジトリ&lt;/a&gt;を元に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えればいいのですが、&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;このリポジトリ&lt;/a&gt;は全然更新していないので内部で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval関数&lt;/code&gt;を使っていたり古いコードになっているため今回は無視して、&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋アプリ&lt;/a&gt;の最新版のソースを元に書き換えました。なので&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋の簡易版」リポジトリ&lt;/a&gt;のコードと比較すると少し内容に違いがあることを先にことわっておきます。でも、やってることは同じで出力結果は同じになる&lt;strong&gt;はず&lt;/strong&gt;ですし、&lt;a href=&quot;/project/2018-06-30/9masushogi_solver&quot;&gt;「CUIで９マス将棋を解く」&lt;/a&gt;の記事に書かれている内容もほぼ当て嵌まります。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;span&gt;３三将棋CUI版のC++バージョンのソースコード&lt;/span&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/shogi33.git&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;３三将棋簡易版のC++バージョン&quot; title=&quot;３三将棋簡易版のC++バージョン&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;コーディング力では生成aiにはかなわない&quot;&gt;コーディング力では生成AIにはかなわない&lt;/h3&gt;
&lt;p&gt;　過去にも将棋関連アプリの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のソースを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に移行してみようと思ったことはあったのですが、一つのソースで３三将棋から７七将棋まで遊べるようにしようとしたり、将棋AI部分を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;で作ってもAndroid用GUIが作れない（不可能ではないでしょうが難易度高過ぎ）所為もあって、モチベーションが上がらずやりかけては中断することを繰り返してました。それに、例えば「抽象クラスをインスタンス化したくなったときはどうすべきなんだろう（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;では出来てしまう）」とか&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;に関するに言語仕様の違いについて迷うことが出てきて手が止まることも多かったです。そういう時に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok4&lt;/code&gt;は複数の選択肢を挙げてくれましたしコード化してくれました。&lt;a href=&quot;/software/2025-06-07/kotlins_recursion&quot;&gt;前回の記事&lt;/a&gt;でも、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt;で配列の比較をしている部分を、演算子のオーバーロードが使えない&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;ではequalsメソッドを追加・修正して実現しましたし、何も言わなくても&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;演算子のオーバーロード&lt;/code&gt;で実現してくれました。こうあるべきという綺麗なコードを一瞬で出力してくれました。&lt;br /&gt;
　自分の場合、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;なら自分が思いついたアイデアをすぐにコードにして試せるので好きなのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;で書くとなると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;自分の中では要件が明確なのにも関わらず&lt;/code&gt;コードにするとなると時間がかかってしまいます。でも、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;を使いながらもアイデアをすぐにコード化出来るという&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++の達人&lt;/code&gt;もいるでしょうから、プログラミング言語の違いは大きな問題ではないでしょう。どういう書式で書くのか、どういう型を使うのか、どういう関数を使うのか、OOP的にはどう書くべきかというプログラミングのテクニカルな部分、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;コーディング力&lt;/code&gt;とでもいうのでしょうか？に関しては&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;には敵わないなと感じました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;は世界中のソースコードから学習しているわけですから、少し寂しい気持ちもありますが、そうなるのは仕方がないことでしょう。前向きに捉えて&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;を使っていくのがいいと思います。&lt;br /&gt;
　現に今まで中途半端にしか進められなかった&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;への移行が、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;を使うことで極短時間で出来たわけですから喜ぶべきでしょう。今回もほとんどデバッグ作業は必要なかったです。&lt;br /&gt;
　但し、今回は試しにやってみたという感じなので、３三将棋から７七将棋まで対応可能なソースの一本化はとりあえず見送りました。&lt;/p&gt;

&lt;h3 id=&quot;大事なのはアルゴリズムを生み出す発想力&quot;&gt;大事なのはアルゴリズムを生み出す発想力&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;アルゴリズムを生み出す&lt;/code&gt;と言っても新しい汎用的なソートアルゴリズムを発見するとかいう大袈裟なものではなく、データ構造を含めたアルゴリズムを生み出す作業とは、世のプログラマが普通にやってることです。業務ソフトでもユーザーの要望を聞いてこういう関数を作ってみよう、こういうクラス構成にしてみよう、こういう手順で実行させようとアイデアを出して日々やっている（押し付けられている？:sweat_smile:）作業です。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;コンピュータが要件を満たせるレベルまで細分化して明確にしていく作業&lt;/code&gt;と言えばいいかもしれません。多くのユーザーは、人間がやっていることをコンピュータにやらせるレベルまでには要件を明確に出来ていませんので、プログラマが業務ソフト毎にデータ構造を含めた新しいアルゴリズムを日々生み出してます。&lt;br /&gt;
　当ブログで紹介してきたプログラミング事例でも、特に苦労せず実現できたものやネット上からのコピペも多いですが、以下のアルゴリズムは実現までに結構悩まされてなんとか生み出した、アイデアを絞り出したという感じです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将棋アプリの打ち歩詰め判定 -&amp;gt; &lt;a href=&quot;/software/2018-06-10/droppawncheck&quot;&gt;「打ち歩詰め判定は必要なのか」&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;チェスアプリのゲーム終了条件 -&amp;gt; &lt;a href=&quot;/software/2019-10-27/stalemate&quot;&gt;「将棋の評価関数とチェスの評価関数−１」&lt;/a&gt;、&lt;a href=&quot;/software/2024-04-07/tdd&quot;&gt;「チェスAIとテスト駆動開発」&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;チェスアプリのPIN絡みのステイルメイト判定 -&amp;gt; &lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;「チェスのStalemateとPINの話」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　その人間が生み出したアルゴリズムもどんどん生成AIの餌になっていくわけですから、いずれはすべてAIがやるようになるのかもしれません。それに人間側が、AIが処理しやすいように業務内容を変えていく動きもありますね。&lt;/p&gt;

&lt;h3 id=&quot;生成aiはコーディングスキルだけなのか&quot;&gt;生成AIはコーディングスキルだけなのか？&lt;/h3&gt;
&lt;p&gt;　今回の記事も、元になる&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のソースコードから&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に移行しただけで、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;を使って０からアプリを作った経験はないので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;アルゴリズムを生み出す&lt;/code&gt;という点でどこまで役に立つのか分からないのですが、そういう部分ではまだまだ人間の方に分があるのではないでしょうか？&lt;br /&gt;
　機会があれば生成AIを使って０から何か作ってみたいと思ってます。&lt;/p&gt;

&lt;h3 id=&quot;３三将棋の簡易版リポジトリ更新しました2025-08-16追記&quot;&gt;&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋の簡易版」リポジトリ&lt;/a&gt;更新しました（2025-08-16追記）&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋の簡易版」リポジトリ&lt;/a&gt;を&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋アプリ&lt;/a&gt;の最新版のソースに更新しました。これでリポジトリ名は変えてませんが、「簡易版」ではなく、&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋アプリ&lt;/a&gt;のソースファイル一式になります。&lt;br /&gt;
　これで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok4&lt;/code&gt;を使って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に移行する際に、極一部の処理（候補手のソート等）に変更を加えましたが、ほぼ丸々一式&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋アプリ」リポジトリ&lt;/a&gt;を元にして&lt;a href=&quot;https://github.com/happyclam/shogi33.git&quot;&gt;「３三将棋のC++バージョン」&lt;/a&gt;を作成した形になります。&lt;br /&gt;
　ところが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Player.think&lt;/code&gt;メソッド（全件探索、全幅探索）は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript版&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++版&lt;/code&gt;も同様に動いています（&lt;strong&gt;但し、実行速度が速くなってない！&lt;/strong&gt;）が、肝心の候補手を絞って深く読む&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Player.prepare&lt;/code&gt;メソッドが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript版&lt;/code&gt;では問題なく動いているのに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++版&lt;/code&gt;ではうまく動いていない状況です。これに関しては別記事に書こうと思ってます。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Thu, 07 Aug 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-08-07/OOP</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-08-07/OOP</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>c++</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>Kotlinで再帰関数（AIに丸投げ）</title>
        <description>&lt;h3 id=&quot;ウォーターソートパズルを題材に&quot;&gt;ウォーターソートパズルを題材に&lt;/h3&gt;
&lt;p&gt;　もう６年以上前の話ですが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;が流行り始めた当時、将棋関連アプリ（&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋&lt;/a&gt;、&lt;a href=&quot;https://happyclam.booth.pm/items/6325376&quot;&gt;５五将棋&lt;/a&gt;、&lt;a href=&quot;https://happyclam.booth.pm/items/6346070&quot;&gt;７七将棋&lt;/a&gt;）のAI部分の高速化を考えていた私は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript(Javascript)&lt;/code&gt;のソースコードを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に書き換えてみたことがあります。でも文法だけ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に書き換えてもわずか&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;３手読み&lt;/code&gt;ですぐにスタックオーバーフローが発生して、末尾再帰の形になるようにソースコードを書き換えなければならないことが分かって挫折しました。&lt;br /&gt;
　でも、&lt;a href=&quot;/software/2025-04-27/waterbottle&quot;&gt;前回の記事&lt;/a&gt;で作った&lt;a href=&quot;https://github.com/happyclam/water_sort_puzzle&quot;&gt;プログラム&lt;/a&gt;なら、将棋関連アプリに較べればかなり単純な構造の再帰関数なので、これなら出来るんじゃないか？と興味が湧いて、これを題材にして末尾再帰に書き換える作業を体験することにしました。&lt;/p&gt;

&lt;p&gt;※&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;製の５五将棋プログラムは今でもソースが残ってますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Null Safety&lt;/code&gt;なんて全く気にしていない&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のソースコードをそのまま&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に移行して、とにかくコンパイルを通すために&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nullable&lt;/code&gt;な変数を無理やり&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-null&lt;/code&gt;に強制的に変換する演算子&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!!&lt;/code&gt;（ビックリマーク２つ）だらけの、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin使い&lt;/code&gt;に言わせれば汚いコードでした。&lt;/p&gt;

&lt;h3 id=&quot;grokに聞いてみる&quot;&gt;Grokに聞いてみる&lt;/h3&gt;
&lt;p&gt;　プログラミングの際に本やGoogle検索を使うよりもリファレンスとして&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;は有用だなと思っていたので、まずは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に慣れていない私は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のソースコードを貼り付けて「このコードをKotlinに書き換えて！」と丸投げしてみました。コンパイルエラーが出ても実行時エラーが出ても「エラー出てるよ！」と返して、修正されたコードをまたコピペして実行するだけでこちらはあくまでも受け身の姿勢です。&lt;br /&gt;
　そしてエラーは無くなったけど期待した結果が返ってこない状態になって、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;配列A == 配列B&lt;/code&gt;の比較をしている部分は「Kotlinでは無理だろうな」と当たりをつけて&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;equalsメソッド&lt;/code&gt;を改変したら（ここも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に丸投げ）すぐに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;は完成しました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;が吐き出すコードを碌に確認もせずデバッグ作業も全くしてません。そして肝心のNodeクラス内の再帰関数メソッドに較べて再帰がやや複雑になっている&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;も「dfs関数も末尾再帰に書き換えて！」と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に丸投げしただけで完成しました:astonished:&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;div align=&quot;center&quot;&gt;ソースコード&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/water_sort_kotlin&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;ウォーターソートパズル解答プログラム（Kotlin版）&quot; title=&quot;ウォーターソートパズル解答プログラム（Kotlin版）&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;　「どうせどこかでトラブってデバッグ作業させられるんだろうなぁ」と期待せずにダラダラと始めた作業なのですが、正味の作業時間は１時間もかかっていません。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;とのやり取りも数回だけです、公開するのは少し恥ずかしいですが、&lt;a href=&quot;https://x.com/i/grok/share/MA2ogBDeGSppQ2poNu8tRDmom&quot;&gt;Grokとのやり取り&lt;/a&gt;の一部始終を公開しますので興味ある方は確認してみてください。&lt;/p&gt;

&lt;h3 id=&quot;生成aiの実力を認めざるを得ない&quot;&gt;生成AIの実力を認めざるを得ない&lt;/h3&gt;
&lt;p&gt;　この記事は「自作の再帰関数を末尾再帰に書き換えるためにはこんな作業が必要でした」という内容になる予定だったのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に丸投げするだけで済んでしまったので書くことが無くなりました。もしそういう内容を期待してた方は&lt;a href=&quot;https://x.com/i/grok/share/MA2ogBDeGSppQ2poNu8tRDmom&quot;&gt;Grokの履歴&lt;/a&gt;を見てもらえば各再帰関数の変更前と変更後のソースも見れますし、解説もされているのでそちらを見ていただきたいと思います。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dfs関数&lt;/code&gt;の末尾再帰化された後のコードは自分自身もよく理解できていません。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;はプログラミング時のリファレンスには使えるぐらいの認識だったのですが、完全に自分が教えて貰ってる状態です。未だに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT&lt;/code&gt;もほとんど使ってないし&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Copilot&lt;/code&gt;もよく知りません（何を使っても中身は同じ？）が、積極的に使ったほうが開発効率は上がりそうですね。&lt;br /&gt;
　とは言っても今回のケースは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;の正解がある状態、アルゴリズムに問題が無いことが分かっている状態から始めたので、一から&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;でプログラミングしていたら例え&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に手伝ってもらってもこんなに簡単には完成しなかったとは思います。しかし&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のような&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;軽量プログラミング言語（Lightweight Languages）&lt;/code&gt;でサクッとプロトタイプを作ってから&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;を使って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;のようなコンパイラ言語に置き換えるのも一つの使い方としてアリかもしれません。将棋関連アプリの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++（STL使用）&lt;/code&gt;への変換も試してみようと思ってます。&lt;/p&gt;

&lt;h3 id=&quot;ちょっと怪しい&quot;&gt;ちょっと怪しい…&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vscode&lt;/code&gt;上で実行していた時は気づかなかったのですが、コマンドラインでコンパイルすると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;warning&lt;/code&gt;が出てました&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kotlinc -include-runtime -d ./game.jar waterBottles
waterBottles/game.kt:72:21: warning: recursive call is not a tail call.
    val subResult = dfs(node, temp, depth - 1, 0, 0, false, newResult)
                    ^^^
waterBottles/node.kt:52:22: warning: recursive call is not a tail call.
        } else if (c.add(nd, target, 0)) {
                     ^^^
waterBottles/node.kt:77:22: warning: recursive call is not a tail call.
        } else if (c.replace(nd, target, 0)) {
                     ^^^^^^^
waterBottles/node.kt:94:22: warning: recursive call is not a tail call.
        } else if (c.search(target, 0)) {
                     ^^^^^^
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　コンパイラは「末尾再帰になってませんよ」と言ってます&lt;br /&gt;
どうやら末尾再帰化が中途半端になっているようですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dfs関数&lt;/code&gt;に関しては&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;による末尾再帰化を施さないと期待通り動かなかったので、間違った変更を加えたわけではないようですし、内部の処理が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;とどのような違いがあるのかは分かりません。それより驚いたのは、完成した&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;のプログラムで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のプログラムと同じ問題を解かせてみると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;も&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin版&lt;/code&gt;の方が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby版&lt;/code&gt;よりもかなり遅かったことです&lt;/strong&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;に合わせて敢えて不要な部分で可変長の配列を使ってるところとか、確かに実行速度を上げることを目指したコードではないですが、まさか&lt;strong&gt;同じデータ構造とアルゴリズムで&lt;/strong&gt;インタプリタ言語の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;より大幅に実行速度が遅くなるとは思いませんでした。&lt;/p&gt;

&lt;h3 id=&quot;kotlinjavaって再帰関数が苦手なの&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin(Java)&lt;/code&gt;って再帰関数が苦手なの？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2025-04-27/waterbottle&quot;&gt;前回の記事&lt;/a&gt;の冒頭の問題を解かせて見たところ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.151秒&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5530.022秒（約１時間半！！）&lt;/code&gt;でした、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;では&lt;a href=&quot;/software/2025-04-27/waterbottle&quot;&gt;前回の記事&lt;/a&gt;でも書いた通り&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.016248494秒&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;279.599430481秒（約４分半）&lt;/code&gt;です。再帰関数ではないはずの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;の遅さが目立ちますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;でも内部では再帰関数であるNodeクラスの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addメソッド&lt;/code&gt;を頻繁に呼び出すので、念の為Node.addメソッドを末尾再帰ではない元々のコードに戻して試してみましたが実行時間に違いはありませんし、スタックオーバーフローも発生しません。末尾再帰化はスタックオーバーフローを避けるためのものなので、実行速度は変わらない（あるいは若干遅くなる）はずで、まぁこうなるところでしょう。それよりなにより&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;より遅いのならそもそも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に書き換える意味がありません。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt;は昔に較べて速くなってると聞いていたし、原因はいろいろあると思いますが、もしかして&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin(Java)&lt;/code&gt;は末尾再帰化されているかどうかに関わらす再帰関数を使うと遅くなるのでしょうか？とにかくモチベーションが一気に下がりました。&lt;br /&gt;
　結局、末尾再帰化は中途半端になりましたが、速度アップには繋がらないし、スタックオーバーフローが発生しているわけでもないのでここで止めておきます。昔、GOTO文も駆使しながらスタックの消費を抑えている&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C言語&lt;/code&gt;のソースを見たことがありますが、そこまでする必要はないでしょう、というかそこまでやる人に敬意を表しますが私には出来そうにないです。&lt;br /&gt;
　もう&lt;a href=&quot;https://github.com/happyclam/water_sort_kotlin&quot;&gt;このKotlin版&lt;/a&gt;の高速化に時間を掛けようとは思いませんが、その昔将棋関連アプリを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に書き換えることを早々に諦めたことは私にとって良かったのかもしれません。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;が存在しなかった当時、スタックオーバーフローを避けるために苦労して末尾再帰に書き換えても実行速度が遅くなったのではさぞ虚しかったことでしょう。&lt;/p&gt;

&lt;h3 id=&quot;やはり高速化ならc&quot;&gt;やはり高速化なら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;　将棋関連アプリの高速化のために将棋AI部分を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;で書き直したとしても、GUIを何で作るかという問題が残りますのでこれについては今後も模索中です。Kotlinで高速なものが作れれば、AndroidアプリのGUIもKotlinで作れるのでよかったのですが、残念です。&lt;br /&gt;
　現在販売中の&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋アプリ&lt;/a&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;評価値でソートして候補手を絞る関数&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;局面を先読みする関数&lt;/code&gt;の２つの関数を再帰呼出ししている面白い処理（&lt;a href=&quot;/software/2019-02-26/iterativedeeping&quot;&gt;「反復深化？を工夫してより深く読む」&lt;/a&gt;参照）をしているので、GUI付きのアプリとして販売するかどうかに関わらず一度&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;で実装してみたいとは思っています。&lt;/p&gt;

&lt;h3 id=&quot;生成aiはアルゴリズムを勝手に変更する2025-06-08追記&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;はアルゴリズムを勝手に変更する？（2025-06-08追記）&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えたら速くなることを確認するため一応&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;でも上記の方法で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;を使ってやってみました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;div align=&quot;center&quot;&gt;ソースコード&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/water_sort_cPlus&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;ウォーターソートパズル解答プログラム（C++版）&quot; title=&quot;ウォーターソートパズル解答プログラム（C++版）&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;/software/2025-04-27/waterbottle&quot;&gt;前回の記事&lt;/a&gt;の冒頭の問題を解かせて見たところ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.00225114秒&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11.9202秒！！&lt;/code&gt;でした。流石に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;は速いです。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;から&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に移植した時と違い、何回かデバッグ作業を強いられました。それに、「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のコードを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にして！」と依頼しているのに、AIが勝手に判断して変更するケースもあるようです。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のコードでは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.makeHash&lt;/code&gt;メソッド内で局面を文字列化するときに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MD5&lt;/code&gt;のハッシュ値を使用しているのですが、私はボトルの数が増えると局面を表現するための文字列がどんどん長くなっていくのでそれを防ぐ意味でハッシュ値を使用していたのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;はそういう私の意図などお構いなしに勝手にハッシュ化のためのコードを削除しました:sweat_smile:&lt;br /&gt;
　まぁそれは良いとしても、アルゴリズムに影響を与える勝手な変更も一部あって、その所為で一時は問題を解くのに時間がかかる結果になってしまいました。その時はボトルの水を移動する回数（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cnt変数&lt;/code&gt;でカウント）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;と較べて異常に増えていたのですぐにおかしいと気付いたのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin版&lt;/code&gt;に関してはそういう明確な出力の違いがないので&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin版&lt;/code&gt;が遅い原因は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin(Java)&lt;/code&gt;自体にあるとみてます。&lt;br /&gt;
　将棋でも一度&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI&lt;/code&gt;のアドバイスを貰うと「その次の手はどう指すの？」、「その次は？」と際限なく聞きたくなってきて、自分の頭で考えなくなってしまいますので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI&lt;/code&gt;の使い方には気をつけないとダメですね。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sat, 07 Jun 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-06-07/kotlins_recursion</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-06-07/kotlins_recursion</guid>
        
        <category>ruby</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>kotlin</category>
        
        <category>c++</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>ウォーターソートパズルの答えが知りたい</title>
        <description>&lt;h3 id=&quot;暇潰しに丁度いい&quot;&gt;暇潰しに丁度いい&lt;/h3&gt;
&lt;p&gt;　スマホ弄っていたら広告を見かける人も多いと思いますが、最近ボトルに色分けされた水が入っていてそのボトル内の水を同一色に並べ替えるゲームに嵌っています。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ウォータソートパズル&lt;/code&gt;とか&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;水選別パズル&lt;/code&gt;とか呼ばれてるようで、大抵の問題は何回かやり直せば正解にたどり着けるのですが、どうしても解けないパターンに出会って、「そもそもこれに解答は存在するのか？」という疑問を持ったのでプログラムを作って確認することにしました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;どうしても解けなかったパターン
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;/images/watersort00.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/watersort00.png&quot; alt=&quot;解けない？パターン&quot; width=&quot;200&quot; height=&quot;200&quot; title=&quot;解けない？問題&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;とりあえずgrokに聞いてみる&quot;&gt;とりあえずGrokに聞いてみる&lt;/h3&gt;
&lt;p&gt;　最近プログラミングに関する技術的な調べものをする際に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;を何度か使ってみて、Googleで調べるより効率的かもと思っていたので試してみました。&lt;br /&gt;
　上記の画像ファイルをアップロードしてGrokに「このウォータソートパズルの解答手順を教えてください」と聞いてみたところ&lt;br /&gt;
「ボトルは１２本ですね」とか言いながら解答手順を即答しましたが、&lt;br /&gt;
画像の認識が間違っているので「よく見てください、ボトルは１３本です」と送ると&lt;br /&gt;
「申し訳ありません、画像をよく確認したところ、ボトルは12本ではなく13本ですね」とかいいながら、また間違った問題のまま解答手順を列挙してきました。&lt;br /&gt;
更に「ボトルは上段に７本、下段に６本です。下段の右側に空のボトルが２本有ります」と訂正すると&lt;br /&gt;
「ご指摘ありがとうございます」とかいいながら、またまた間違った問題のまま解答手順を列挙してきました。&lt;br /&gt;
こんな感じでやり取りが延々続いて解答は得られませんでした。問題の画像を正確に認識するのが難しいみたいです。それにしても解答の速さに驚いたのですが、画像の認識さえ正確に出来れば解答手順も正確に答えられるのでしょうか？
以下のテキストを貼り付けて再度Grokに聞いてみました。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      [RED, SKY_BLUE, RED, YELLOW],
      [MAGENTA, PINK, AQUA_GREEN, RED],
      [AQUA_GREEN, YELLOW_GREEN, PURPLE, BLUE],
      [SKY_BLUE, MAGENTA, ORANGE, YELLOW],
      [PURPLE, PINK, ORANGE, YELLOW_GREEN],
      [PURPLE, BLUE, PINK, AQUA_GREEN],
      [ORANGE, YELLOW, AQUA_GREEN, PURPLE],
      [SKY_BLUE, BLUE, GRAY, GRAY],
      [SKY_BLUE, YELLOW_GREEN, MAGENTA, RED],
      [YELLOW, MAGENTA, ORANGE, GRAY],
      [YELLOW_GREEN, GRAY, PINK, BLUE],
      [],
      []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　すると今度は「提供された色のリストに基づき、ウォーターソートパズルの解答手順を日本語で説明します」と言いながら手順を示してきたのですが、ボトルの最上段に存在しない色を移動していたり、ルールを無視した手順を何回も示してきました。&lt;br /&gt;
根気よく訂正し続ければ解答できるのかもしれませんが、自分には無理そうに思えたので諦めました。&lt;/p&gt;

&lt;h3 id=&quot;自分で解答プログラムを作る&quot;&gt;自分で解答プログラムを作る&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2018-08-18/puzzle&quot;&gt;以前の記事&lt;/a&gt;で紹介した&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;将棋パズル解答プログラム&lt;/code&gt;とほぼ同じコードで解決できそうなのでやってみました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS（幅優先探索）&lt;/code&gt;を使って一手ずつ局面を進めてすべてのボトルの色が一色に揃う解答画面に辿り着いた時点で探索を終了し、その手順を遡って表示します。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS&lt;/code&gt;では解答までの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最短手順&lt;/code&gt;を表示しますが、実行時間がかなりかかります。PCのスペックにもよりますし、問題によってもかなり解答までの時間が大きく変化するのですが、ボトル５本（内、空ボトル２本）なら１秒も掛かりませんけど、ボトル９本（内、空ボトル２本）だと&lt;del&gt;３〜４時間掛かりました。&lt;/del&gt;冒頭で紹介しているボトル１３本（内、空ボトル２本）では&lt;del&gt;数日掛かるのでしょうか？&lt;/del&gt;実際に作ってみる前の想像以上に時間が掛かるのは&lt;a href=&quot;/software/2020-06-07/mancala&quot;&gt;マンカラの時&lt;/a&gt;と同じですね。&lt;/p&gt;

&lt;h3 id=&quot;dfs深さ優先探索版も作ってみる&quot;&gt;DFS（深さ優先探索）版も作ってみる&lt;/h3&gt;
&lt;p&gt;　解答を得るのにあまりにも時間がかかりそうなので&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;も作ってみました。すると&lt;del&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;だと数日掛かると思われた上記の問題が&lt;/del&gt;１秒掛からずに解答を得ることが出来ました:sweat_smile:&lt;br /&gt;
　但し&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で得られた解答手順は最短手順とは限りません。でも、そもそも&lt;strong&gt;解答が存在するのかどうかを知りたい&lt;/strong&gt;というのが目的だったので満足です。上記の問題も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で出力された解答手順通りにやればアプリ上で実際に解けました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;div align=&quot;center&quot;&gt;ソースコード&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/water_sort_puzzle&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;ウォーターソートパズル解答プログラム&quot; title=&quot;ウォーターソートパズル解答プログラム&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;解けない問題はあるのか&quot;&gt;解けない問題はあるのか？&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;で問題を解くためにあまりに時間が掛かるので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;を作ってみるまでは「この問題には解が存在しない」と言い切るための条件はなんだろう？とか「解が存在することを証明するにはどうすればいいのか？」なんて難しく考えていたのですが時間の無駄でした。解けるかどうか判断するには「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS&lt;/code&gt;アルゴリズムで作られた解答プログラムで確認すればいいだけ」ですね、スタックオーバーフローに見舞われない限りは…。&lt;br /&gt;
　逆に空ボトル２本で解けない問題を作る方が難しいのかもしれません。ちなみに空ボトルを１本にすれば解けない問題はすぐに出来上がりますが、&lt;strong&gt;解は存在するけど解くのが難しい問題&lt;/strong&gt;というのを意図的に作るのは難しいと思います。&lt;a href=&quot;/software/2018-08-18/puzzle&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;将棋パズル&lt;/code&gt;の記事&lt;/a&gt;や&lt;a href=&quot;/project/2018-01-01/33shogiapp&quot;&gt;３三将棋アプリの記事&lt;/a&gt;でも書きましたが、&lt;strong&gt;問題を解くよりも、難しい問題を作る方が難しい&lt;/strong&gt;というのはウォーターソートパズルに関しても言えそうです。&lt;br /&gt;
　あと「ボトルの数がどれぐらい増えれば空ボトルが最低３本必要になるのか？」とか「空ボトル２本で解けるのは全体のボトル数が何本が限界？」とかの問題を考えるのも面白いかもしれませんが、ボトル１本あたりの色の数とかも考慮し出すとキリが無いので何か汎用的な法則を見つけ出すのは大変でしょうね。&lt;/p&gt;

&lt;h3 id=&quot;ヒント機能はどうなってるのか&quot;&gt;ヒント機能はどうなってるのか？&lt;/h3&gt;
&lt;p&gt;　アプリの中にはヒント機能が実装されているものも有ります。ヒント機能があるということはアプリが解答も知っているということなので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;を作ってみるまでは予め用意した問題だけを出題してるのだろうか？と考えたりしましたが、そんなことはなく&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS&lt;/code&gt;ならランダムに問題を生成してその場でヒントが出せそうです。つまり、確認はしてませんが&lt;strong&gt;ヒント機能があるウォーターソートパズルアプリが出すヒントは最短手順のヒントではない&lt;/strong&gt;と思われます。&lt;/p&gt;

&lt;h3 id=&quot;プログラムの解説nodeクラスの役割&quot;&gt;プログラムの解説（Nodeクラスの役割）&lt;/h3&gt;
&lt;p&gt;　プログラムは水を入れる入れ物である&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bottleクラス&lt;/code&gt;、ボトルを収納する&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Boxクラス&lt;/code&gt;、開始局面を頂点とする&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ゲーム木&lt;/code&gt;を生成して格納する&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;の３つのクラスを使っていますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;について解説します。&lt;br /&gt;
　まず&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS&lt;/code&gt;の場合は、一手目の操作で現れ得る局面をすべて調べてから二手目の局面を調べるという順番なので&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ゲーム木&lt;/code&gt;を横方向に走査していく形になります。同じ手数の局面を横方向に全部調べてから次の手数の局面を全部調べるので、最終的に解答手順を表示する時に縦の手順に変えなければいけません。横方向に局面を蓄積（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addメソッド&lt;/code&gt;）していって、最終的に辿り着いた完成局面から、今度は開始局面までを縦方向に手順を再帰的に遡って辿り着くようにして表示しているのが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;の役割です。&lt;br /&gt;
　次に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS&lt;/code&gt;の場合は開始局面から指定された深さの末端ノードまで一気に読み進めて、末端ノードを調べ尽くしたら指し手を遡ってまた隣の経路を末端ノードまで読むという感じで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ゲーム木&lt;/code&gt;を縦方向に読み進めます。だから&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS&lt;/code&gt;のように&lt;strong&gt;局面を蓄積していく必要はなく&lt;/strong&gt;、毎回辿った履歴を上書き（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replaceメソッド&lt;/code&gt;）していけば最終的に辿り着いた完成局面までの履歴が残ります。今回作ったプログラムは先に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS&lt;/code&gt;のプログラムを作ったので&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;のようなものを使っていますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;だけ作ることを考えるのなら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;のようなもので再帰的に局面を辿るようにしなくても、外部変数の配列を一つ用意して局面が進む度に上書きしていけば開始局面から完成局面までの一本のルートが配列に残ります。昔、オセロのパズル（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;）を作った時はそんな感じで作りました。→&lt;a href=&quot;https://github.com/happyclam/othello&quot;&gt;github&lt;/a&gt;&lt;br /&gt;
　偉そうに解説していますが、実際そうなっているかどうか詳しく確認していませんし、バグってるかもしれません。自己責任でご利用ください。&lt;br /&gt;
　将棋もプログラミングも&lt;strong&gt;直感精読!!&lt;/strong&gt;、特に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;直感&lt;/code&gt;が大事だと思います。&lt;/p&gt;

&lt;h3 id=&quot;答えを知るために必要なプログラムの変更箇所&quot;&gt;答えを知るために必要なプログラムの変更箇所&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;game_bfs.rb&lt;/code&gt;でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;game_dfs.rb&lt;/code&gt;でも、ボトルを格納するための&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box&lt;/code&gt;オブジェクト生成部分を書き換えればいろんな問題に対応できます。色数を増やす場合は色の定義ファイル（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const.rb&lt;/code&gt;）と表示部分（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;box.rb&lt;/code&gt;）を修正する必要があります。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; box = Box.new(
   [
     Bottle.new([PINK, YELLOW_GREEN, GRAY, PINK]),
     Bottle.new([BLUE, YELLOW_GREEN, ORANGE, YELLOW]),
     Bottle.new([ORANGE, YELLOW, BLUE, PINK]),
     Bottle.new([RED, ORANGE, ORANGE, PINK]),
     Bottle.new([GRAY, YELLOW, BLUE, RED]),
     Bottle.new([YELLOW_GREEN, RED, BLUE, GRAY]),
     Bottle.new([YELLOW_GREEN, GRAY, RED, YELLOW]),
     Bottle.new,
     Bottle.new
   ]
  )

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;追記2025-05-06&quot;&gt;追記（2025-05-06）&lt;/h3&gt;
&lt;p&gt;　記事を公開した後にディスプレイが壊れた&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M1 Macbook Pro&lt;/code&gt;で記事冒頭に紹介した問題を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;で 解かせていたのですが、いつまで（数日）経ってもプログラムが終了しないのでおかしいと思ったらやはりバグってました:sweat_smile:&lt;br /&gt;
　バグと言うか同じ結果は得られるはずですが、同一局面の判定に無意味なことをしていて&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;のレスポンスが極端に悪くなっていました。&lt;a href=&quot;https://github.com/happyclam/water_sort_puzzle&quot;&gt;github&lt;/a&gt;のソースは修正済みですが、それでも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;は時間が掛かって、記事冒頭の問題の最短手順の答えを得るまでに、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;279.599430481秒（約４分半）&lt;/code&gt;掛かり、最短手数は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;36手&lt;/code&gt;でした。同じPCで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で解いてみると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.016248494秒&lt;/code&gt;で、手数は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;46手&lt;/code&gt;でした。&lt;br /&gt;
　今回の修正は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;には影響ないはずです。&lt;br /&gt;
　やはり&lt;strong&gt;直感精読&lt;/strong&gt;の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;精読&lt;/code&gt;も大事ですね:sweat_smile:&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 27 Apr 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-04-27/waterbottle</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-04-27/waterbottle</guid>
        
        <category>ruby</category>
        
        <category>shogi</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>lichessに挑戦</title>
        <description>&lt;h3 id=&quot;チェスサイトのaiはすべてstockfish&quot;&gt;チェスサイトのAIはすべてStockfish？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/project/2019-11-16/chessapp&quot;&gt;以前の記事&lt;/a&gt;で&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;&lt;/a&gt;のAIと&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;との対戦成績を紹介したので、今度は&lt;a href=&quot;https://lichess.org/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lichess&lt;/code&gt;&lt;/a&gt;で試してみました。でも中で動いているAIは&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;&lt;/a&gt;も&lt;a href=&quot;https://lichess.org/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lichess&lt;/code&gt;&lt;/a&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stockfish&lt;/code&gt;を使っているようで大きな違いは無いようです。対戦結果も&lt;a href=&quot;/project/2019-11-16/chessapp&quot;&gt;以前の記事&lt;/a&gt;と似たようなものだったので、同じAIが動いていると思われますが、自分の&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;が勝つ時はある特定のパターンがありそうです。そしてチェス対戦サイトのAI（&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://lichess.org/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lichess&lt;/code&gt;&lt;/a&gt;）の&lt;strong&gt;ある特徴&lt;/strong&gt;に気付きました…。&lt;/p&gt;

&lt;h3 id=&quot;チェスアプリが勝った対局&quot;&gt;&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;が勝った対局&lt;/h3&gt;
&lt;p&gt;　レベル４で１０戦して３勝７敗だったのですが、&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;が勝った３局をgifファイルで紹介します。gitファイルの下側が&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;です。テキストの棋譜は&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;に入力して再現することも可能です。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;序盤は大抵&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;側が劣勢になります。&lt;/p&gt;

    &lt;div align=&quot;center&quot;&gt;勝局１:劣勢から逆転&lt;/div&gt;
    &lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess01.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess01.gif&quot; alt=&quot;vs.lichess_level04_1&quot; width=&quot;320&quot; height=&quot;373&quot; title=&quot;vs.lichess_level04_1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess01.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess01.png&quot; alt=&quot;vs.lichess_level04_1&quot; width=&quot;480&quot; height=&quot;218&quot; title=&quot;vs.lichess_level04_1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1. e3 e6 2. Qg4 f5 3. Qf4 g5 4. Qf3 g4 5. Qf4 Bh6 6. Qe5 Nf6 7. h4 Nc6 8. Qb5 a6 9. Qc4 b5 10. Qc3 b4 11. Qc4 Bb7 12. a4 d5 13. Qb3 a5 14. Bb5 O-O 15. Bxc6 Bxc6 16. d4 Bg7 17. Nd2 Ra6 18. Qd3 Rb6 19. f3 Qe7 20. Ne2 h5 21. Kf2 Ne4+ 22. Kf1 Bd7 23. Ke1 Nd6 24. Ng3 Be8 25. Kf2 f4 26. exf4 Rf6 27. Nxh5 g3+ 28. Nxg3 Bg6 29. f5 Nxf5 30. Nde4 Nd6 31. Nxf6+ Kf7 32. Nge4 Qxf6 33. Nxf6 Bxd3 34. cxd3 Bxf6 35. Be3 Nf5 36. Rac1 c6 37. g4 Nxd4 38. g5 Bh8 39. g6+ Kxg6 40. Rhg1+ Kh5 41. Rg5+ Kh6 42. Rxd5+ Kh7 43. Rd7+ Kg8 44. Bxd4 Bxd4+ 45. Rxd4 c5 46. Rxc5 Kf7 47. Rf4+ Ke7 48. Rxa5 Kd7 49. Rg5 Kc7 50. Rg7+ Kd6 51. Rf8 Ra6 52. Rd8+ Kc6 53. Re8 Kd6 54. Rd8+ Kc5 55. Rg5+ e5 56. Rxe5+ Kc6 57. Re7 b3 58. Rd4 Kc5 59. Rde4 Rf6 60. R4e6 Rxe6 61. Rxe6 Kb4 62. Ra6 Kc5 63. f4 Kb4 64. h5 Kc5 65. f5 Kd5 66. Re6 Kc5 67. Re4 Kd6 68. Re1 Kc5 69. Re4 Kd6 70. Re6+ Kc7 71. d4 Kc8 72. Re3 Kc7 73. Rxb3 Kd8 74. Rc3 Ke7 75. b4 Kd8 76. a5 Ke7 77. b5 Kf6 78. Rf3 Kg5 79. d5 Kxh5 80. d6 Kg5 81. d7 Kf6 82. d8=Q+ Ke5 83. Qe7+ Kd4 84. a6 Kd5 85. Rg3 Kd4 86. Rg4+ Kd3 87. Qc7 Kd2 88. Rd4# 1-0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;なんと！６手（将棋で言うと１２手）でチェックメイト。lichessAIは一手詰めを読んでない？&lt;br /&gt;
　棋譜解析によると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nf3&lt;/code&gt;が悪手で、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d4&lt;/code&gt;と着手すればlichessAI側が優勢のままだったようです。&lt;/p&gt;

    &lt;div align=&quot;center&quot;&gt;勝局２:６手でチェックメイト&lt;/div&gt;
    &lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess02.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess02.gif&quot; alt=&quot;vs.lichess_level04_2&quot; width=&quot;320&quot; height=&quot;373&quot; title=&quot;vs.lichess_level04_2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess02.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess02.png&quot; alt=&quot;vs.lichess_level04_2&quot; width=&quot;480&quot; height=&quot;218&quot; title=&quot;vs.lichess_level04_2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1. g4 d5 2. g5 e5 3. Bg2 Qxg5 4. Bxd5 Bc5 5. Nf3 Qg2 6. Rg1 Qxf2# 0-1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;の序盤は相変わらず定跡無視の乱戦、終盤は５手詰め以内の詰みならほぼ逃すことはありませんが、大優勢な局面であっても詰みがない局面だとも勝ち切るまでがもたつきます。評価関数の出来の悪さとしか言えません。&lt;/p&gt;

    &lt;div align=&quot;center&quot;&gt;勝局３:終盤はもたつく&lt;/div&gt;
    &lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess03.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess03.gif&quot; alt=&quot;vs.lichess_level04_3&quot; width=&quot;320&quot; height=&quot;373&quot; title=&quot;vs.lichess_level04_3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess03.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess03.png&quot; alt=&quot;vs.lichess_level04_3&quot; width=&quot;480&quot; height=&quot;218&quot; title=&quot;vs.lichess_level04_3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1. c4 e5 2. Nc3 Qh4 3. e3 a5 4. g3 Qg5 5. h4 Qf5 6. g4 Qf6 7. g5 Qf5 8. e4 Qe6 9. Nd5 Kd8 10. Bh3 Qc6 11. d4 Qxc4 12. Qh5 Bb4+ 13. Nxb4 axb4 14. g6 Qxd4 15. gxf7 Qxe4+ 16. Kf1 Ne7 17. Bg2 Qd3+ 18. Qe2 Qxe2+ 19. Nxe2 Rf8 20. a3 d5 21. Be3 Rxf7 22. Rh2 Bg4 23. Bc5 Nd7 24. Be3 Ra6 25. Bd2 Nc5 26. Bxb4 Nd3 27. Bxe7+ Kxe7 28. Nc1 Rxf2+ 29. Kg1 Nxc1 30. Kxf2 Nb3 31. Rg1 Rf6+ 32. Kg3 Be6 33. Rhh1 Rf4 34. Re1 Rg4+ 35. Kf2 e4 36. Rd1 b5 37. Bf1 Rf4+ 38. Kg2 Rg4+ 39. Kh2 Rxh4+ 40. Kg2 Rg4+ 41. Kf2 Rf4+ 42. Ke1 e3 43. Bg2 Nd4 44. Rc1 Nf3+ 45. Bxf3 Rxf3 46. Rg1 Rf4 47. Rxc7+ Kd6 48. Rcxg7 d4 49. Rxh7 d3 50. Rg6 Rc4 51. Kd1 Rf4 52. Ke1 Rc4 53. Rxe6+ Kxe6 54. Rh6+ Kd7 55. Rh7+ Kd6 56. Rh6+ Kc7 57. Kd1 Rf4 58. Ke1 Rg4 59. Rh7+ Kc6 60. Rh1 Rf4 61. Rh5 Rg4 62. Rh1 Rg2 63. a4 bxa4 64. b4 axb3 65. Rh6+ Kb7 66. Kf1 Rf2+ 67. Kg1 Rf4 68. Rh3 e2 69. Kg2 e1=Q 70. Rh7+ Ka8 71. Rh8+ Ka7 72. Rh7+ Ka8 73. Kh3 Qe5 74. Rh6 Rf2 75. Kg4 Qg7+ 76. Rg6 Qxg6+ 77. Kh3 d2 78. Kh4 Rh2# 0-1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;lichessのaiは先読み探索をしていない&quot;&gt;lichessのAIは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み（探索）&lt;/code&gt;をしていない？&lt;/h3&gt;
&lt;p&gt;　AIの強さを調整する（適度に弱くする）のはなかなか難しいと思いますが、上記の２番目の勝局のように１手詰め（詰めろ）を受けないというのはどういうことでしょうか？lichessAIが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rg1&lt;/code&gt;と指したところで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rf1&lt;/code&gt;と指して１手詰めを受けていればまだまだ勝負は分からなかったと思います。それをせずにわざと負ける（チェックメイトされる）ような手を選ぶのは、「何回かに一回はわざと負けてあげる」というようなことをしているわけではなく、AIのレベルが低い時（今回の場合はレベル４）は「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み&lt;/code&gt;を一切しない」というような調整の仕方をしている気がします。&lt;br /&gt;
　一般的に学習型のAIは詰将棋（チェスプロブレム）は苦手と言われますが、それを補うためにまず短い手数の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み（探索）&lt;/code&gt;を行い、詰みが無ければ学習データを利用した静的評価関数で指し手を決めるようになっていると聞きますが、その&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み&lt;/code&gt;（よく&lt;strong&gt;力任せ&lt;/strong&gt;とか&lt;strong&gt;brute-force&lt;/strong&gt;と表現される指し手の探索）をせずに静的評価関数のみ（計算式のパラメータ調整のみ？）で指し手を決めているのかも知れません。冒頭で&lt;strong&gt;ある特徴&lt;/strong&gt;と書いたのはこのことです。&lt;br /&gt;
　実際のところは分かりませんし、他にも強さ調整のためにいろいろやってると思いますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み（探索）&lt;/code&gt;をしなければサイトの負荷軽減にもなるので当たってる気がします。&lt;br /&gt;
　ちなみに先読みをしないという点では&lt;a href=&quot;https://happyclam.booth.pm/items/6582961&quot;&gt;「消える三目並べ」アプリ&lt;/a&gt;も同じような作りになっています。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;モンテカルロ法&lt;/code&gt;を使った強化学習で学習データを作り、そのデータに基づいて確率によって指し手を選択します。確率によって指し手を選択するので一手詰め（あと一手でラインが揃う）を見逃したりするのですが、学習が進むにつれて間違う確率が低くなっていきます。最近「消える三目並べ」を検索ワードにした当ブログへの訪問者が増えてるので、また記事を書くかも知れません。&lt;/p&gt;

&lt;h3 id=&quot;chesscomも同じ&quot;&gt;chess.comも同じ？&lt;/h3&gt;
&lt;p&gt;　以下の対局は&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;のAI（Santa BOT）&lt;/a&gt;と&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;の対戦ですが&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;chess.com AI が必勝局面から３手詰め頓死&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/vs_chesscom01.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_chesscom01.gif&quot; alt=&quot;vs.chesscom_santa_1&quot; width=&quot;320&quot; height=&quot;373&quot; title=&quot;vs.chesscom_santa_1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. e4 e5 2. Nf3 Qf6 3. Bc4 a5 4. O-O g5 5. Qe2 h5 6. Bd5 g4 7. Ne1 Ne7 8. Kh1
Rg8 9. Nd3 Nxd5 10. exd5 Bd6 11. Nc3 h4 12. Ne4 Qf5 13. Nxd6+ cxd6 14. b3 h3 15.
Kg1 hxg2 16. Re1 g3 17. hxg3 Qh3 18. f4 Rxg3 19. Nf2 Qh6 20. fxe5 Ke7 21. exd6+
Kf8 22. Qe8+ Kg7 23. Re3 Qh2+ 24. Kxh2 g1=Q# 0-1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;AI&lt;/a&gt;が必勝局面で23手目&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Re3&lt;/code&gt;と指したことで３手詰が生じて頓死です。これも&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;のAI&lt;/a&gt;が短手数の詰みを読んでいなかった（先読み探索をしてなかった）のだと思います。&lt;br /&gt;
　自分の&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;が勝つ時はだいたいこんな感じで、出来の悪い評価関数のせいで序盤からずっと劣勢でなんとか終盤まで縺れた時に相手の頓死で勝つパターンが多いです。&lt;br /&gt;
　あと、&lt;a href=&quot;https://lichess.org/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lichess&lt;/code&gt;&lt;/a&gt;の方は&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;&lt;/a&gt;と違って無料の棋譜解析の回数制限が無いようなのでお勧めです。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 05 Jan 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-01-05/lichess</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-01-05/lichess</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>chess</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>ミニチェスアプリもテスト</title>
        <description>&lt;h3 id=&quot;ミニチェスアプリは盤面編集可能&quot;&gt;ミニチェスアプリは盤面編集可能&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;前回記事&lt;/a&gt;の内容を&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;でもテストしてみました。&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門&lt;/a&gt;のステイルメイトの問題集を6x6のミニチェス用にアレンジして解かせてみると、元々の問題の趣旨とは違った発見があります。&lt;br /&gt;
　&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;は&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;と違って盤面編集機能があるので、暇な方は試してみて下さい。もしソースコードを見るつもりの方はアンパッサンとかキャスリングの実装でかなり汚くなっている&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;のコードよりも&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;の方をお勧めします。&lt;/p&gt;

&lt;h3 id=&quot;問題３&quot;&gt;&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;問題３&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;　元々の問題は以下の局面です。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;元の問題、初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q3_org.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q3_org.png&quot; alt=&quot;ステイルメイト問題３&quot; width=&quot;320&quot; height=&quot;459&quot; title=&quot;ステイルメイト問題３&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　正解は白&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc8+&lt;/code&gt;で、以下黒&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc8&lt;/code&gt;と進み、白がステイルメイトに持ち込むという問題です。&lt;br /&gt;
これを以下のように6x6に編集してみました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;６ｘ６初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q3-1.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q3-1.png&quot; alt=&quot;ステイルメイト問題３ー１&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題３ー１&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;ここからAI同士で対戦させると以下のように進みます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;詰みあり&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/chess66_3-1.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/chess66_3-1.gif&quot; alt=&quot;ステイルメイト問題３&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題３&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　6x6に編集した結果、詰みがある局面になってしまったので黒を詰ましてしまいましたが、当然こうなるべきでしょう。&lt;br /&gt;
今度は黒のキングを一路ずらして配置してみます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;初期盤面を変更&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q3-2.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q3-2.png&quot; alt=&quot;ステイルメイト問題３ー２&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題３ー２&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;ここからAI同士で対戦させると以下のように進みます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;ステイルメイト&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/chess66_3-2.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/chess66_3-2.gif&quot; alt=&quot;ステイルメイト問題３&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題３&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　白が劣勢ですが一旦&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;と黒のキングにチェックを掛けて、その後はステイルメイトが最善と判断して&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc6+&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc6&lt;/code&gt;とステイルメイトに持ち込みました、最善の応酬だと思います。下手に勝とうと思って白が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qd5&lt;/code&gt;（詰めろ）なんていう手を選ぶと、黒に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qd1+&lt;/code&gt;とチェックされてクィーンを交換後に戦力不足で白が負けてしまいます。&lt;/p&gt;

&lt;h3 id=&quot;問題７&quot;&gt;&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;問題７&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;　元々の問題は以下の局面です。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;元の問題、初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_01.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_01.png&quot; alt=&quot;ステイルメイト問題７&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問題７&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　正解は白&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;で白がステイルメイトに持ち込むという問題です。&lt;br /&gt;
これを以下のように6x6に編集してみました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;６ｘ６初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q7-1.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q7-1.png&quot; alt=&quot;ステイルメイト問題７ー１&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題７ー１&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;ここからAI同士で対戦させると以下のように進みます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;白、負けは避けられない&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/chess66_7.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/chess66_7.gif&quot; alt=&quot;ステイルメイト問題７&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題７&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　元々の問題のようにステイルメイトを狙って白が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qa4+&lt;/code&gt;なんてやると、黒が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxa4&lt;/code&gt;とクィーンで取ってくれれば良いのですが、以下のように&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rxa4&lt;/code&gt;とルークで白のクィーンを取られて&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;黒はステイルメイトを避ける&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q7-2.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q7-2.png&quot; alt=&quot;ステイルメイト問題７ー２&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題７ー２&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　白は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c3&lt;/code&gt;しか指す手がなくなり黒&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qb3#&lt;/code&gt;とチェックメイトになります。結局この問題は白の負けが避けられないので、上記の変化は最善の応酬だったことが分かります。もちろん黒がルークで白のクィーンを取る（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rxa4&lt;/code&gt;）ことも確認済みです。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  === intro07-2
    --- problem -7-2

6|♜| | | | | |
5| |♛| | | |♟|
4|♕| | | | |♚|
3| | | | |♟| |
2| | |♙|♟|♙| |
1| | | |♔| | |
  a b c d e f

      ✔ expects checkmate -7-2 (206ms)
♕
6| | | | | | |
5| |♛| | | |♟|
4|♜| | | | |♚|
3| | | | |♟| |
2| | |♙|♟|♙| |
1| | | |♔| | |
  a b c d e f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;も&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;も多くのソースコードは同じなので問題がなくて当然なのですが、&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;に関しては&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mocha&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chai&lt;/code&gt;のテストを省略していたので、あらためてテストスクリプトを書いて確認してみました。&lt;/p&gt;

&lt;h3 id=&quot;ステイルメイトの評価値について&quot;&gt;ステイルメイトの評価値について&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;前回の記事&lt;/a&gt;で先手勝ちの評価値を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;、後手勝ちの評価値を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;、ステイルメイトの局面に掛ける係数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.0009&lt;/code&gt;にして様子を見ると書きましたが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.0009&lt;/code&gt;という値があまりにも小さすぎて奇異に感じるので先手勝ちを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;500&lt;/code&gt;、後手勝ちを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-500&lt;/code&gt;、係数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.09&lt;/code&gt;にして試してみたのですが、今度は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;駒の重み&lt;/code&gt;に使ってる値とバランスが取れず？に&lt;strong&gt;不都合&lt;/strong&gt;が出てきたので止めました。もし値を変えるとしたら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;駒の重み&lt;/code&gt;の数値も全面的に見直さないといけないんだろうなぁと思っていたところ、タイミング良く？&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X（Twitter）&lt;/code&gt;で&lt;a href=&quot;https://x.com/yaneuraou/status/1870996558600441943&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;やねうら王&lt;/code&gt;開発者のポスト&lt;/a&gt;を見かけました。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;やねうら王&lt;/code&gt;では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;400&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-400&lt;/code&gt;を最大・最小値として使用しているそうで、以前&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;やねうら王&lt;/code&gt;をインストールした時（&lt;a href=&quot;/software/2024-06-12/yaneuraou&quot;&gt;「Ubuntuでやねうら王」&lt;/a&gt;）のソースを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;すると確かにそのようです（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval_limit&lt;/code&gt;定数）。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;やねうら王&lt;/code&gt;のソースを読んでみてもいいのですが、理解するのは大変でしょうし何かアイデアが浮かばない限り当面はこのままにしておくつもりです。&lt;/p&gt;

&lt;p&gt;※&lt;strong&gt;不都合&lt;/strong&gt;とは何か…自分のアプリの場合、単純に評価値の最大・最小値を小さな値にすると「相手キングを積極的に詰ましにいかなくなる」、「千日手になりやすくなる」という現象を確認してます。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 22 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2024-12-22/chess66_test</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2024-12-22/chess66_test</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>chess</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>チェスのStalemateとPINの話</title>
        <description>&lt;h3 id=&quot;チェスアプリのバグを見つけてしまいました&quot;&gt;チェスアプリのバグを見つけてしまいました&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門&lt;/a&gt;というサイトのステイルメイトの問題集を&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;で解いてみると８問中１問間違えてしまいました。ステイルメイトの問題集はあまり見かけないので、十分なテストをしてなかったのが原因です。&lt;a href=&quot;https://happyclam.booth.pm/items/6325341&quot;&gt;マンカラアプリ&lt;/a&gt;もそうですが（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;詰めマンカラ問題集&lt;/code&gt;なんて聞いたことがありません）、問題集が手に入らないのである程度のところでテストを打ち切ってリリースしていたのですが、実際に解けない問題を見つけてしまった以上、対処することにしました。&lt;/p&gt;

&lt;h3 id=&quot;pinが絡む問題に問題がある&quot;&gt;PINが絡む問題に問題がある&lt;/h3&gt;
&lt;p&gt;　解けなかったのは&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門サイトの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;で、以下の局面です。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_01.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_01.png&quot; alt=&quot;ステイルメイト問7-1&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　正解手は以下のようにQueenをc4に移動する&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;です。先手（白）劣勢ですが「王手クイーン取り」を掛けてステイルメイト（引き分け）に持ち込むという問題です。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;正解盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_02.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_02.png&quot; alt=&quot;ステイルメイト問7-2&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;でも、初期盤面から&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;に指させてみると、以下のように&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxd5&lt;/code&gt;と黒のクイーンを取ります。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;不正解&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_03.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_03.png&quot; alt=&quot;ステイルメイト問7-3&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　クィーンは取れるのですが次に後手（黒）がルークをa1に移動（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ra1&lt;/code&gt;）して合い駒効かずでチェックメイトされて先手（白）が負けます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;不正解後の変化&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_04.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_04.png&quot; alt=&quot;ステイルメイト問7-4&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;正解手が指せないからといってバグとは限らないのですが、この問題の場合は３手の読みでステイルメイトに気付いて５手読めば&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ra1&lt;/code&gt;からの負けに気付くので、候補手を絞っている可能性があるので一概には言えませんが５手読めば正解できるはずです。&lt;br /&gt;
　では、手動で先手（白）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;と指した局面で&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;に指させてみると&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;先手（白）のクィーンを取る、正しい応手？&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_05.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_05.png&quot; alt=&quot;ステイルメイト問7-5&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-5&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;相手のクィーンを取って（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;）ステイルメイトと判定してゲーム終了となるのでこれも問題ありません。&lt;br /&gt;
　しかし、手動で先手（白）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;と指した局面から後手（黒）も手動で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;と指すと以下のようになります。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;手動で指すと「後手勝ち」の判定！！！&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_06.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_06.png&quot; alt=&quot;ステイルメイト問7-6&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　これはイケマセン。ステイルメイトなのに「後手の勝ちです」と判定してしまってます。これは明らかなバグです。&lt;br /&gt;
どうやらチェスで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;と呼ばれる状態の時にSTALEMATEの判定を間違うようです。
このステイルメイトの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;のミソは他の問題とは違って、単に「王手クィーン取り」を掛けてステイルメイトに持ち込むだけではなく、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;状態に持ち込むところです。初手は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qd4+&lt;/code&gt;でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4+&lt;/code&gt;でもダメで、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;でなければならないのです。&lt;/p&gt;

&lt;h3 id=&quot;将棋ではpinは大した問題ではない&quot;&gt;将棋ではPINは大した問題ではない&lt;/h3&gt;
&lt;p&gt;　上の図の終局の局面は将棋でも珍しくない形だと思います。将棋なら先手（白）は指す手が無くて投了するしか無い局面です。もし将棋初心者が指す手に困って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;されている&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e2&lt;/code&gt;の駒（ポーン）を前に動かしたとしても、後手（黒）がクィーンで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f1&lt;/code&gt;の玉（キング）を取れば済む話です（&lt;a href=&quot;/software/2024-04-07/tdd&quot;&gt;以前の記事&lt;/a&gt;参照）。その場合、将棋でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;王手放置&lt;/code&gt;は反則と規定されているので正確に言えば先手（白）の反則負けと言うべきですが、いずれにしても後手（黒）の勝ちは揺るぎません。でも将棋と違ってチェスの場合は劣勢だった先手が引き分け（ステイルメイト）に持ち込んだことになります。将棋なら先手（白）負けなのにチェスだと引き分けになります。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;に対応する将棋用語は何かよく分かりませんが、「串刺しにされてる」とか「角の効きに入ってる」とかの表現はありますが、ピッタリした用語が無いのが将棋というゲームが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;をそれほど重要視していないことの証拠にもなるでしょう。&lt;br /&gt;
　将棋アプリを開発する立場で見ても&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;なんて全然気にしていませんでした。チェスのソフトや昔からある将棋ソフトが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;をチェックするアルゴリズムを使っているのは知ってましたが、それは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stockfish&lt;/code&gt;由来のアルゴリズムを流用して作っていたからであって、自分のように一からアルゴリズムも考えて開発するのなら関係のない話だと思っていたし実際に作ることも出来ました。でも、今回の&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;のバグの修正に取り掛かってみて想像以上に面倒臭い作業を強いられて、チェスのステイルメイト（特に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;絡み）に対応するためには将棋とは別のやり方（別のデータ構造と別のアルゴリズム）で作る方がスマートに出来るのだろうということが想像できました。何がそんなに面倒くさいかと言うと長くなるので省略しますが、チェス盤のマス目を一つ一つ移動しながら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;のチェックをするのはかなり&lt;strong&gt;無理がある&lt;/strong&gt;のです。&lt;br /&gt;
　将棋ソフト開発関連の本などをチラ見すると&lt;strong&gt;「データ構造に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;用のフラグを持たせる」&lt;/strong&gt;とか&lt;strong&gt;「合法手を列挙する」&lt;/strong&gt;とか言う表現をよく見かけますが、自分の将棋関連アプリ（&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋&lt;/a&gt;、&lt;a href=&quot;https://happyclam.booth.pm/items/6325376&quot;&gt;５五将棋&lt;/a&gt;、&lt;a href=&quot;https://happyclam.booth.pm/items/6346070&quot;&gt;７七将棋&lt;/a&gt;）はデータ構造に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;用のものはありませんし、「合法手を列挙する」作業も一切していませんが困ることは何もありませんでした。人間が実際に駒を動かすイメージで一つ一つの駒を８方向に動かす作業を想定したアルゴリズムになっていて、普通はそうしたやり方を採用するだろうと思われる極普通のやり方（アルゴリズム）です。「合法手を列挙する」と聞いて、昔から「何でそんなやり方してるのかなぁ？」と不思議に思ってました。もしかして、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stockfish&lt;/code&gt;を作った人は、最初私のようなやり方で&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;を作り始めてステイルメイトの実装に掛かった時に「こりゃダメだ！」「こんなことやってられない！」と感じて新しいやり方（データ構造とアルゴリズム）を捻り出したんじゃないでしょうか？私の勝手な想像ではありますが、今回のバグ修正に取り組んで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stockfish&lt;/code&gt;を作った人の気持ちが分かったような気がしました。&lt;br /&gt;
　今回のバグ修正は&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;が絡むステイルメイトに関わる部分だけ&lt;/strong&gt;が下膨れした感じになっていて、幸いそういうケースはあまりないので全体の処理が重くなったということはありません。&lt;/p&gt;

&lt;h3 id=&quot;ステイルメイトは最善手なのか&quot;&gt;ステイルメイトは最善手なのか？&lt;/h3&gt;
&lt;p&gt;　上に挙げた&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門サイトの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;の問題以外にも興味深い変化を含んでいます。上記のバグをなんとか&lt;strong&gt;無理がある&lt;/strong&gt;方法で修正して過去のテストも全部通過してデグレード（リグレッション）が無いところまでなんとか辿り着いて、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;も含めて&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;すべての問題&lt;/a&gt;に正解することも確認しました。&lt;br /&gt;
　そして、試しに先程の先手が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;と指した下の正解局面から&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;正解盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_02.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_02.png&quot; alt=&quot;ステイルメイト問7-2&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;修正済みの&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;に後手を指させてみると&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;後手がステイルメイトを避けた局面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_07.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_07.png&quot; alt=&quot;アプリ修正後の指し手&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;なんと、先手のクィーンを取らずに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4&lt;/code&gt;と指して王手（チェック）を回避しました。修正する前はちゃんと先手のクィーンを取っていたので、修正前より悪化してるような気もがしますがそうではなく、正しくステイルメイトの局面だと判断できるようになって、後手（アプリ）が「優勢なのにステイルメイトなんかにしてたまるか！」とクィーンを犠牲にしてキングが逃げる手を選んだわけです。その後先手は当然後手のクィーンを取って（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxe4+&lt;/code&gt;）以下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kg5&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qa8&lt;/code&gt;となり後手のキングは大海に逃げ出すことは出来ますが、駒をボロボロ取られて十数手後に結局先手が勝ちます。結局そうなるのなら「ステイルメイトで妥協しておくべきだったんじゃないの？」と言いたくなりますが、自分のチェスアプリは深く読めていない（３〜５手）こともあってこうなります。&lt;br /&gt;
　このステイルメイトを無理やり避ける現象は&lt;a href=&quot;/software/2020-02-11/evaluatechess&quot;&gt;以前の記事&lt;/a&gt;で書いたステイルメイトの局面をどのように評価するか（ステイルメイトの局面に掛ける係数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.7&lt;/code&gt;をどのように決めるか問題）とも関わってくるのですが、自らステイルメイト（引き分け）を受け入れて確定させるより、少しでも勝つ可能性がある手を選ぶ方が最善手と言えなくもないような気もします。&lt;br /&gt;
　それにしても&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;詰めチェス&lt;/code&gt;（チェス・プロブレム）の中には問題の趣旨以外の有効な着手が存在するもの、将棋で言えば&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;余詰め&lt;/code&gt;がある詰将棋のような感じの問題が多いですね。それとも自分がチェス初心者だからそう感じるだけで、ベテランチェスプレイヤーなら上記の局面でステイルメイト（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;）以外は考えられないって感じでしょうか？身近にチェスに詳しい人がいないのでよく分かりません。&lt;br /&gt;
　&lt;a href=&quot;/software/2019-11-09/stalemate3&quot;&gt;以前の記事&lt;/a&gt;に書きましたが、そもそもステイルメイトの局面評価値に係数を掛けようと思ったのは、ステイルメイトの評価値を引き分けなのだからという理由で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;にすると以下の局面で先手が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bf6&lt;/code&gt;という手を選んだからです。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;ステイルメイトが最善手？&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_08.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_08.png&quot; alt=&quot;Stalemateは最善手？&quot; width=&quot;320&quot; height=&quot;467&quot; title=&quot;Stalemateは最善手？&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　先手はビショップとナイトを持っていて後手はルークだけで形勢は先手有利のはずなのに先手から進んでステイルメイト（引き分け）にするのはおかしいだろうと考えたのが事の発端です。この局面の後、指し手を進めても後手玉は捕まらないからステイルメイトにするのが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最善手&lt;/code&gt;なのでしょうか？自分は優勢なのに自ら進んでステイルメイトにするのはおかしいと考えたので、形勢が有利な時はステイルメイトの評価値にマイナスの値を掛けてやや反転？する仕様にした（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kf7&lt;/code&gt;の手を指します）のですが、もし&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bf6&lt;/code&gt;（ステイルメイト）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最善手&lt;/code&gt;というのがチェスプレイヤーの共通認識であるのならステイルメイト局面の評価値は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;のままでいいかもしれません。でも、上の局面で先手のポーンが一つでも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b5&lt;/code&gt;辺りに残っていれば敢えてステイルメイトにする人はいないと思います。そのような局面とも比較するためにもステイルメイトの局面に掛ける係数は必要だと思います。&lt;br /&gt;
　あと、念の為もう一度書いておきますが、&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;は「&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門サイト&lt;/a&gt;のステイルメイトの問題は全問正解します」、正解するけどその後の指し手が問題の趣旨通りには進まないと言うことです。&lt;/p&gt;

&lt;h3 id=&quot;他にも見えてきた問題&quot;&gt;他にも見えてきた問題&lt;/h3&gt;
&lt;p&gt;　上記の&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;の正解手の後の後手の一手（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4&lt;/code&gt;）は&lt;strong&gt;あまりにも無理してステイルメイトを避けている&lt;/strong&gt;ような気もしたので、試しにステイルメイトの局面の評価値に掛けている係数（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.7&lt;/code&gt;）を変更したら、後手（アプリ）は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;と着手してステイルメイトを選ぶことを確認しました。そして、将棋とは違って局面の評価値に使っている最大値や最小値が悪影響を与えてることが見えてきました（あくまでも私が作った評価関数についての話です）。&lt;br /&gt;
　&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;では局面を評価する際の先手勝ちの局面の評価値を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;、後手勝ちの局面の評価値を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;にしているのですが、駒の重みは&lt;a href=&quot;/project/2019-11-16/chessapp&quot;&gt;この記事&lt;/a&gt;のようになっていて、クィーンが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;90&lt;/code&gt;、ルークが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50&lt;/code&gt;…という感じで相手の駒を全部取っても&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;なんていう大きな数値にはなりません。この先手勝ち局面（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;）と後手勝ち局面（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;）のような大きな値にマイナスの係数（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.7&lt;/code&gt;）を掛けても、自分の思惑通りには比較出来ていなかったようです。&lt;br /&gt;
　それでも&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;以外は正解出来ていたのは、&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;のような紛れがなく明快な手しか無かったのでステイルメイトの局面を勝ちあるいは負けとほぼ同等の評価をしていたからでした。&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;のように紛れがある問題だと、負けるぐらいなら他の手を選ぼうとAIが考えてステイルメイトを避けたということです。ということで、&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;で正解後の後手の一手を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4&lt;/code&gt;ではなく&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;を選ぶように調整した結果、ステイルメイトの局面に掛ける係数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.0009&lt;/code&gt;にしました。これで勝敗の決着がつく大きな値（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;や&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;）と、形勢判断時の評価値（駒の重みや駒の働きの合計値）との比較が出来ているようです。ちなみに係数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.001&lt;/code&gt;にすると元通り&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4&lt;/code&gt;と指してステイルメイトを避けます。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  === intro07-2
    --- problem -7-2

8|♜| | | | | | | |
7| | | | | | | | |
6| | | | | | | | |
5| | | |♛| | | |♟|
4| | |♕| | | | |♚|
3| | | | | | |♟| |
2| | | | |♙|♟|♙| |
1| | | | | |♔| | |
  a b c d e f g h

      ✔ expects stalemate -7-2 (686ms)
♕
8|♜| | | | | | | |
7| | | | | | | | |
6| | | | | | | | |
5| | | | | | | |♟|
4| | |♛| | | | |♚|
3| | | | | | |♟| |
2| | | | |♙|♟|♙| |
1| | | | | |♔| | |
  a b c d e f g h

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;これでようやく&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;の正解後も問題の趣旨通りに後手がステイルメイトの手を選ぶようになりました。&lt;br /&gt;
　局面の最大値や最小値なんて閉じたアプリの中での相対的な評価値でしかないので何でもいいと思っていました。将棋アプリも先手の勝ちは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;、後手の勝ちは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;を使っていますし、昔作ったオセロでもよくINT型のMAX値とMIN値を使っていました。でも将棋やオセロと違って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;勝ち&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;負け&lt;/code&gt;以外の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;という&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;勝ち&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;負け&lt;/code&gt;の間にある局面を評価するには工夫する必要があるようです。このステイルメイトの局面に掛ける係数は、その意図は昔書いた記事（&lt;a href=&quot;/software/2020-02-11/evaluatechess&quot;&gt;「チェスだけに必要な局面評価属性」&lt;/a&gt;）の通りですが、もし評価関数が完璧なものであるなら必要ないのだと思います。ステイルメイトは引き分けとして評価値&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;でいいと思うのですが、完璧な評価関数なんて有り得ないので必要になってくるものだと思います。&lt;br /&gt;
　それと一つのケースだけを見て&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.0009&lt;/code&gt;に決めてしまっていいのかと思うかも知れませんが、どのように決めるべきか分かってませんし最大値や最小値も駒の重みに関しても言ってみれば適当に決めた値なので、数は少ないですが過去のステイルメイトのテストケースも通過したことですし当面これで様子見ようと思います。&lt;br /&gt;
　今回、上記の点を弄って個人的にはスッキリしましたが、評価関数は少し変わっただけですし読みの深さも変わっていないので、ステイルメイトの判定が以前より正確になっただけで強くなったわけではないのが残念なところです。&lt;/p&gt;

&lt;h3 id=&quot;アプリのアップデートについて&quot;&gt;アプリのアップデートについて&lt;/h3&gt;
&lt;p&gt;　今回の修正でもうバグは無くなったのでは？と思ってますが、将棋関連アプリに較べるとチェスアプリに関してはステイルメイトというルールのおかげで安心感が無いというのが本音です。何か問題を見つけた場合はメールか&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;Boothサイト&lt;/a&gt;からご連絡下さい。&lt;br /&gt;
　取り敢えず、現在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Booth&lt;/code&gt;で販売している&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;は近いうちに一度今回の修正を反映させてアップデートするつもりです。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Amazon App Store&lt;/code&gt;で公開している&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;に関してはいつ削除されるかも知れませんし、今後はAmazonでは更新しないつもりです。無料のお試し版として残しておきますが、今後はチェスアプリも&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;Booth&lt;/a&gt;で販売する予定です。→&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;Boothで最新版&lt;/a&gt;公開しました。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 15 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2024-12-15/chessPIN</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2024-12-15/chessPIN</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>chess</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>野良アプリ販売始めました</title>
        <description>&lt;h3 id=&quot;google-play-以外でアプリは売れるのか&quot;&gt;Google Play 以外でアプリは売れるのか？&lt;/h3&gt;
&lt;p&gt;　めでたく？&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Play&lt;/code&gt;で公開していたアプリが削除された（Googleが変更した規約に必要な作業をせずに放置していたため）ので、今まで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Play&lt;/code&gt;で公開していたアプリを&lt;strong&gt;広告表示を無しにした野良アプリ&lt;/strong&gt;として販売してみることにしました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Play&lt;/code&gt;を通さずに新規ユーザーを獲得出来るのでしょうか？&lt;/p&gt;

&lt;h3 id=&quot;どこで売るか&quot;&gt;どこで売るか？&lt;/h3&gt;
&lt;p&gt;　最初は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base&lt;/code&gt;で自作のExcelファイル（マクロ付き）を販売している人を見かけたのが始めるキッカケなんですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base&lt;/code&gt;ではスマホからはデジタルコンテンツをダウンロード出来ないようです。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apk&lt;/code&gt;ファイルを商品としてそのままアップロード出来るのはすごく良かったのですが、購入者はPCでダウンロードする必要があるみたいです（スパム対策？GoogleやAppleに忖度？あるいは圧力？）。スマホアプリを販売しているのに購入者はPCが必要というのが納得いかなかったので使うのを止めました。&lt;br /&gt;
　その他は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shopify&lt;/code&gt;は有料、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DLsite&lt;/code&gt;はエロ分野に偏ってる、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stores&lt;/code&gt;は画像ファイル中心でソフトウェアは想定して無さそう？ということで&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Booth&lt;/code&gt;&lt;/a&gt;に決めました。&lt;br /&gt;
　それに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Booth&lt;/code&gt;では&lt;a href=&quot;https://booth.pixiv.help/hc/ja/articles/115002295113-%E3%82%AD%E3%83%A3%E3%83%B3%E3%82%BB%E3%83%AB%E3%81%97%E3%81%9F%E3%81%84%E3%81%A7%E3%81%99-%E3%81%A9%E3%81%86%E3%81%99%E3%82%8C%E3%81%B0%E3%81%84%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B&quot;&gt;「ダウンロード商品に関しては、キャンセルには応じません」&lt;/a&gt;と運営側で謳ってくれているのが、販売者側としては心強いです。ご購入の際はご注意下さい！！！&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/booth_logo.png&quot; alt=&quot;HappyClam&quot; title=&quot;HappyClam&quot; width=&quot;168&quot; height=&quot;60&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;インストール手順&quot;&gt;インストール手順&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;Boothのサイト&lt;/a&gt;の[購入履歴]から[ダウンロード]のリンクをタップしてファイルをスマホにダウンロード&lt;/li&gt;
  &lt;li&gt;ダウンロードしたファイル（*.zip）の拡張子を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apk&lt;/code&gt;に変更&lt;br /&gt;
何でもいいのでファイル管理アプリを使ってファイル名（拡張子）を変更します。アプリによっては拡張子が表示されないので、表示して変更します。私は&lt;a href=&quot;https://tetra-filer-free.softonic.jp/android&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tetra Free&lt;/code&gt;&lt;/a&gt;というアプリを使ってます。&lt;/li&gt;
  &lt;li&gt;拡張子を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apk&lt;/code&gt;に変更したファイルをファイル管理アプリからタップ&lt;br /&gt;
使用するファイル管理アプリによって警告が出たり設定画面に遷移したりしますが、「許可」を選択して進めれば以下のような手順でインストール作業が進みます。&lt;br /&gt;
※Android11以上であれば自動で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Play プロテクト&lt;/code&gt;によるスキャンが実行されます。&lt;br /&gt;
※既に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Play&lt;/code&gt;からインストールされている場合は一度削除する必要があるみたいです。&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/install_1.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/install_1.png&quot; alt=&quot;ファイルクリック時&quot; width=&quot;320&quot; height=&quot;158&quot; title=&quot;ファイルクリック時&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;↓&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/install_2.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/install_2.png&quot; alt=&quot;Google Play プロテクト&quot; width=&quot;320&quot; height=&quot;495&quot; title=&quot;Google Play プロテクト&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;↓&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/install_3.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/install_3.png&quot; alt=&quot;スキャン完了&quot; width=&quot;320&quot; height=&quot;442&quot; title=&quot;スキャン完了&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;↓&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/install_4.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/install_4.png&quot; alt=&quot;インストール完了&quot; width=&quot;320&quot; height=&quot;161&quot; title=&quot;インストール完了&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;ソースファイルも参照可能&quot;&gt;ソースファイルも参照可能&lt;/h3&gt;
&lt;p&gt;　JavaScript製のアプリに関してはダウンロードした&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zip&lt;/code&gt;ファイルを展開することでソースファイルも見ることが出来ます。過去に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Play&lt;/code&gt;で公開していた時は暗号化プラグインを使用してソースを読めないようにしていましたが、&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;Booth&lt;/a&gt;で販売しているものは暗号化していませんのでソースファイルを読むことが出来ます。&lt;br /&gt;
　ただ、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeScript&lt;/code&gt;で開発したものを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Webpack&lt;/code&gt;を使って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;にトランスパイルしたコードなので、整然と書かれていますが一つのファイルに纏まっていて分かりにくいと感じる人もいるかもしれません。元となっている&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のソースコードやテストコードや開発環境（package.json等）そのものが欲しいという方のために今後ソースコードも別途販売するかもしれません。&lt;/p&gt;

&lt;h3 id=&quot;pcで動かすことも可能&quot;&gt;PCで動かすことも可能&lt;/h3&gt;
&lt;p&gt;　実はJavaScript製のアプリに関してはソースファイルの数カ所をコメントアウトするだけでPCで動かすことも可能です。スマホよりハイスペックのPC上のブラウザで動かすことも出来るのですが、これに関しては別記事で紹介するかもしれません。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のソース販売と合わせてニーズがあるかどうか知りたいので、&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;Boothサイト&lt;/a&gt;から是非ご意見をお寄せ下さい。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sat, 30 Nov 2024 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/miscellaneous/2024-11-30/strayapp</link>
        <guid isPermaLink="true">https://happyclam.github.io/miscellaneous/2024-11-30/strayapp</guid>
        
        <category>android</category>
        
        <category>coffeescript</category>
        
        <category>programming</category>
        
        <category>javascript</category>
        
        <category>cordova</category>
        
        
        <category>miscellaneous</category>
        
      </item>
    
      <item>
        <title>Ubuntu Touch を使ってみる</title>
        <description>&lt;h3 id=&quot;開発のネタ探し中&quot;&gt;開発のネタ探し中&lt;/h3&gt;
&lt;p&gt;　スマホアプリ開発はAppleやGoogleというプラットフォーマーが開発者とユーザーの間に割り込んでくるため嫌気が差してきたので、次は何を作ろうかと考えて他の選択肢を探している時に偶々Youtubeの動画を見かけて&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch&lt;/code&gt;を試してみました。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch&lt;/code&gt;のユーザーなんてほとんどいないので何かアプリを作っても小銭稼ぎは期待できませんが、そもそも当ブログでは自分が使ってみたいものを作ってきたので問題無しです。&lt;/p&gt;

&lt;h3 id=&quot;インストール手順&quot;&gt;インストール手順&lt;/h3&gt;
&lt;p&gt;　以下が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch&lt;/code&gt;を試してみたくなった動画です。細かな注意点も解説されていて非常に助かりました。&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/XW8JU1lHLtk?si=y28wRPv6QsI-OKUg&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; referrerpolicy=&quot;strict-origin-when-cross-origin&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;　この動画を見た直後は、いろいろと妄想が膨らんだのですが現実は厳しかったです。&lt;/p&gt;

&lt;h3 id=&quot;必要なもの&quot;&gt;必要なもの&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Pixel 3a XL&lt;/code&gt;&lt;br /&gt;
Amazonの「整備済み品」を18,980円でわざわざ購入しました。&lt;/li&gt;
  &lt;li&gt;UBPortsのインストーラーが使える状態の工場出荷イメージファイル&lt;br /&gt;
&lt;a href=&quot;https://developers.google.com/android/images?hl=ja&quot;&gt;こちら&lt;/a&gt;からイメージファイル（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bonito-pq3b.190801.002-factory-61a2836d.zip&lt;/code&gt;）をダウンロード&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;adb&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fastboot&lt;/code&gt;コマンド
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo apt install android-tools-adb
 sudo apt install fastboot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pixel 3a XL&lt;/code&gt;用のUBPortsインストーラー&lt;br /&gt;
&lt;a href=&quot;https://devices.ubuntu-touch.io/device/bonito/&quot;&gt;こちら&lt;/a&gt;から&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubports-installer_0.10.0_linux_amd64.deb&lt;/code&gt;をダウンロード&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;動画内容と違うところ&quot;&gt;動画内容と違うところ&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;上の動画では&lt;a href=&quot;https://developers.google.com/android/images?hl=ja&quot;&gt;Googleのサイト&lt;/a&gt;から&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;フラッシュ&lt;/code&gt;のリンクを踏んで直接インストールしてますが、自分は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;リンク&lt;/code&gt;からダウンロードしたzipファイルを解凍して、スマホのブートローダを起動してからスクリプトを実行しました。&lt;a href=&quot;https://developers.google.com/android/images?hl=ja&quot;&gt;Googleのサイト&lt;/a&gt;に何時までイメージファイルが存在するか分からないのでダウンロードしておいたほうがいいと思います。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; adb reboot bootloader
 ./flash-all.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;上の動画ではUBPortsインストーラーをdebパッケージからインストールしていますが、自分のUbuntu24.04環境ではインストール出来なかったのでsnapからインストールしました。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo snap install ubports-installer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;上の動画では出てきませんが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;adb&lt;/code&gt;コマンドでPixelと接続する際にPixel側で[設定]-&amp;gt;[システム]-&amp;gt;[開発者向けオプション]-&amp;gt;[デフォルトのUSB設定]で[充電]ではなく[ファイル転送]を選択しておく必要がありました。&lt;br /&gt;
　これをしないとPC側から&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;adb devices&lt;/code&gt;で接続の確認をした際に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;adb: failed to check server version: protocol fault (couldn&apos;t read status): Connection reset by peer&lt;/code&gt;というエラーになります。現在使っているスマホ（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Xperia 10 Ⅲ&lt;/code&gt;）で試してみたら[ファイル転送]になっていなくても接続できたので古いスマホ（Pixel3a）固有の問題かもしれません。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;adb&lt;/code&gt;コマンド使うのも久しぶりだったので、自分が忘れているだけで昔は全部そうだったような気もします。&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/ubuntu-touch.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/ubuntu-touch.png&quot; alt=&quot;Ubuntu Touch&quot; width=&quot;320&quot; height=&quot;640&quot; title=&quot;Ubuntu Touch&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;waydroidはまだまだ&quot;&gt;Waydroidはまだまだ&lt;/h3&gt;
&lt;p&gt;　Linux上でandroidアプリを動かすための&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Waydroid&lt;/code&gt;、上の動画でも言ってますがandroidアプリを使うぐらいならandroidスマホを使うのが良さそうです。自分はスマホの決済機能もあまり使わないしandroidアプリが無くても生活に必要な多くのことはPCで可能なので、androidスマホが無くてもそこそこ生活していけると思っていますが、どうしてもandroidアプリが必要だという時には&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Waydroid&lt;/code&gt;で「ほとんどのアプリは動く」ぐらいの安心感が欲しいですね。&lt;/p&gt;

&lt;h3 id=&quot;libertineも怪しい&quot;&gt;Libertineも怪しい&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch&lt;/code&gt;上でUbuntuのデスクトップアプリを動かす機能ですが、こちらも少し使っただけですが怪しい動きでした。スマホの画面だと狭いからデスクトップアプリが使えないという話ではなく、うまくインストール出来ないものが多かったです。ネットを検索していると「UbuntuのソフトをUbuntu Touchで使いたい」という問いに対して、「ルート（/）以下のディレクトリを書き込み可能にすれば（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo mount -o remount,rw /&lt;/code&gt;）可能ですよ」と言う回答をよく見かけましたが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Libertine&lt;/code&gt;はそういう危険な操作（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo mount -o remount,rw /&lt;/code&gt;）をしなくていい仕組みの筈です。でもインストール直後に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Libertine&lt;/code&gt;を起動してコンテナを作ってデスクトップアプリをインストールすると、うまく行ったり行かなかったりでした。&lt;br /&gt;
　Ubuntu Touchの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Open Store&lt;/code&gt;から&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UT Tweak&lt;/code&gt;というアプリをインストールして、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Make image writable&lt;/code&gt;の機能を使えば&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Libertine&lt;/code&gt;のコンテナ作成に関しては失敗しなかったので元々そうやって使うべきものなのかもしれません。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/ut-tweaks.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/ut-tweaks.png&quot; alt=&quot;UT Tweaksアプリ&quot; width=&quot;320&quot; height=&quot;331&quot; title=&quot;UT Tweaksアプリ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch&lt;/code&gt;をリブートするまで書き込み可にするというオプションが用意してあります（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[Read-Write]Temporary(until reboot)&lt;/code&gt;をタップ）。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apt&lt;/code&gt;コマンドでいろいろなパッケージをインストールする際に、これをOnにしておけば警告が出なくなったりしますが、Ubuntuのデスクトップアプリを何でもインストール出来るわけでは無いようです。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh&lt;/code&gt;を有効にする機能もこのアプリに用意してあるので、まず最初に入れるべきアプリかも。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/ut-ssh.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/ut-ssh.png&quot; alt=&quot;ssh設定&quot; width=&quot;320&quot; height=&quot;640&quot; title=&quot;ssh設定&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;日本語が入力出来ない&quot;&gt;日本語が入力出来ない&lt;/h3&gt;
&lt;p&gt;　モバイルPCとして使えなくても、せめてこのブログの記事を書くことぐらいは出来ないかなぁなんて思っているのですが、今動かしている&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch OTA 5&lt;/code&gt;は日本語入力に対応していません。日本語関係のパッケージを入れてみたりしましたが自分の力では出来そうになかったです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/ut-language.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/ut-language.png&quot; alt=&quot;日本語入力関連&quot; width=&quot;320&quot; height=&quot;640&quot; title=&quot;日本語入力関連&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh&lt;/code&gt;で接続して&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apt&lt;/code&gt;コマンドで言語関連のpackageをインストールしてみました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IBus Preferences&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mozc&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fcitx&lt;/code&gt;の日本語入力関連のアイコンが並んでいて一見使えそうですが、インストール時にエラーが発生していて使えません。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch&lt;/code&gt;自体は何度でもインストールし直せる状態なのでシステムが壊れてもいいからと、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo mount -o remount,rw /&lt;/code&gt;した後にいろいろやって&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch OTA6&lt;/code&gt;にバージョンアップしても違いはなかったです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/OTA6.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/OTA6.png&quot; alt=&quot;OTA6&quot; width=&quot;270&quot; height=&quot;540&quot; title=&quot;OTA6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;アプリ開発は情報が少ない&quot;&gt;アプリ開発は情報が少ない&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Open Store&lt;/code&gt;に用意されているアプリはWebベースのアプリが多いみたいで、ネイティブなものは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qt&lt;/code&gt;を使うようですが情報が少ないので大変そうです。自分が何か開発するとしたらWebベースのものになると思いますが、日本語の情報はほとんど無さそうです。&lt;br /&gt;
　試しに&lt;a href=&quot;https://download.qt.io/archive/online_installers/4.8/&quot;&gt;Qt Creator&lt;/a&gt;を使ってサンプルをコンパイルしてみましたが、Ubuntu上では動くもののUbuntu Touch上では動きませんでした。こっち方面に進むのは茨の道になりそうです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/qt-creator.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/qt-creator.png&quot; alt=&quot;Qt Cretor&quot; width=&quot;320&quot; height=&quot;206&quot; title=&quot;Qt Creator&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;それでも期待したい&quot;&gt;それでも期待したい&lt;/h3&gt;
&lt;p&gt;　動作するスマホの機種が限定されるというのは辛いし今使っているスマホ（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Xperia 10 Ⅲ&lt;/code&gt;）の代替にはなりませんが、今のスマホを買い換える時までに何か変化があって欲しいな（他人任せ）と思ってます。今でも海外なら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch&lt;/code&gt;が動作するハイスペックなスマホは売られてますが、日本だと技適を通過しないことにはマズそう（通話自体は可能？）なので、ここが一番のネックな気がしますね。&lt;br /&gt;
　応援のつもりで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UBPorts&lt;/code&gt;に寄付しようかとやってみたら、なんと日本からの寄付は受け付けていないようで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PayPal&lt;/code&gt;から送金できませんでした。日本人は相手にされていないみたいで何か悲しいです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/ubports_paypal.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/ubports_paypal.png&quot; alt=&quot;paypalのエラー&quot; width=&quot;320&quot; height=&quot;214&quot; title=&quot;paypalのエラー&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;日本語入力出来ました2025-10-08追記&quot;&gt;日本語入力出来ました（2025-10-08追記）&lt;/h3&gt;
&lt;p&gt;　久しぶりに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu Touch&lt;/code&gt;を起動してシステムメニューから&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Update&lt;/code&gt;後、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Upgrade&lt;/code&gt;したら日本語入力が可能になってました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Touch_2404.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Touch_2404.png&quot; alt=&quot;Ubuntu Touch 24.04&quot; width=&quot;270&quot; height=&quot;540&quot; title=&quot;Ubuntu Touch 24.04&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　ChatGPTによると&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;maliit-keyboard が新しい Qt InputMethod Framework に対応&lt;/li&gt;
  &lt;li&gt;fcitx5 と mozc が root ではなく phablet 権限で利用可能&lt;/li&gt;
  &lt;li&gt;日本語ロケール (ja_JP.UTF-8) がデフォルト同梱&lt;/li&gt;
  &lt;li&gt;UIフォントが Noto Sans CJK に統一され文字化けが解消&lt;/li&gt;
  &lt;li&gt;標準のMaliitキーボードが日本語入力対応済み&lt;/li&gt;
  &lt;li&gt;特別な設定やコンテナ導入は不要&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;だそうです。もちろんターミナル上でも入力できます。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/mallit.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/mallit.png&quot; alt=&quot;mallit-keyboard&quot; width=&quot;270&quot; height=&quot;540&quot; title=&quot;Mallit-keyboard&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　これでキーボードとディスプレイを用意すれば出先で使うモバイルPCに近づきそうです:smile:&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sat, 16 Nov 2024 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/hardware/2024-11-16/ubuntu_touch</link>
        <guid isPermaLink="true">https://happyclam.github.io/hardware/2024-11-16/ubuntu_touch</guid>
        
        <category>ubuntu</category>
        
        <category>android</category>
        
        
        <category>hardware</category>
        
      </item>
    
      <item>
        <title>Reader Revenue Manager 止めました</title>
        <description>&lt;h3 id=&quot;またgoogleからの理不尽なメール&quot;&gt;またGoogleからの理不尽なメール&lt;/h3&gt;
&lt;p&gt;　Googleから税務情報の更新を促すメールを貰って、取り敢えず&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader Revenue Manager&lt;/code&gt;を使うのを止めました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader Revenue Manager&lt;/code&gt;と言うのは以前このブログにアクセスすると「支援していただけると励みになります」とダイアログ表示されていた、所謂&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;投げ銭&lt;/code&gt;機能のことです。&lt;/p&gt;

&lt;h3 id=&quot;メールの内容&quot;&gt;メールの内容&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Google に登録されているお客様の税務情報は 2024年12月31日 に失効します。現在のフォームが失効すると、Google は新しい税務フォームが承認されるまで、お支払いから最大 30% の源泉徴収を行うか、お支払いを完全に保留する場合があります。お支払いが期日前に処理され、適切な税金の源泉徴収（該当する場合は最大 30%）が行われるように、税務情報を速やかに更新してください。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　税務情報の更新を怠ると「最大 30% の源泉徴収を行う」は理解できるのですが、「お支払いを完全に保留する場合があります」と書かれています。税務情報を更新しないと「高い税率になるよ〜」というのは分かるのですが、なんで支払いを保留するのでしょうか？こちらとしては高い税率でいいから徴収して残りを振り込んでくれればいいと思っているのですが、何の権限があって支払いを保留するのか分かりません。利用規約上にそのような契約があったとしても日本の法律だと無効になるはずですがどうなんでしょう？&lt;br /&gt;
　以前は税務情報の登録はWeb上で簡単に出来た記憶があるのですが、今回は何やら役所から書類を取り寄せる必要があるみたいで、詳細をGoogleに問い合わせようとしてもなかなか目的のリンクに辿り着けなかったり、要領を得ない回答が返って来ます。仕方がないので[新規フォームの申請]リンクをクリックすると以下のようなダイアログが表示されます。&lt;/p&gt;

&lt;div style=&quot;width:400px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/google_tax.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/google_tax.png&quot; alt=&quot;i新規フォーム申請&quot; width=&quot;406&quot; height=&quot;115&quot; title=&quot;新規フォーム申請&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　「以前送信したフォームは削除されます」!!こういう後戻り出来ないGoogle流のUIが罠なんですよねぇ。ここで[新規フォームの作成を開始]を選んで、面倒くさい作業を強いられて途中で止めたりすると、「税務書類が提出されてない」と言われてまた「アカウント削除するぞ！」と脅されるかもしれませんので、取り敢えず[キャンセル]して今回は放置しておこうと思ってます。「Googleさん、どうぞ高い税率でいいから徴収して下さいよ？」、「何で税金徴収せずに全額ガメるの？」って言いたいです。&lt;/p&gt;

&lt;h3 id=&quot;面倒臭い以外の止める理由&quot;&gt;面倒臭い以外の止める理由&lt;/h3&gt;
&lt;p&gt;　そもそも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AdSense&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader Revenue Manager&lt;/code&gt;も小遣い稼ぎが出来ればいいなぁという軽い気持ちでやっていたので、多くのコスト（時間）を掛けるぐらいなら止めようと思ったのが止める理由ですが、もう一つ、もし&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader Revenue Manager&lt;/code&gt;を有効にしたままGoogleに支払いを保留されると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader Revenue Manager&lt;/code&gt;を使って寄付して頂いても私はそのお金を受け取れないわけで、寄付していただいた方の意志が履行されないことが問題です。&lt;br /&gt;
　寄付してもGoogleにお金が入るだけで私は受け取れないとなると寄付していただいた方も被害者です。そしてそうなることを予見していながら放置しておくことは良くないと思うので、来年どうなるか分かりませんが被害が拡大（そんな心配は無用だとは思いますが）しないためにも、メールを受け取って早々に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader Revenue Manager&lt;/code&gt;の利用を止めました。という訳ですので寄付していただいた数人の方々は「あれっ！寄付してあげたのにどうなったの？」と 思われてるかもしれませんが、今後もブログは続けていきますのでご了承下さい。&lt;br /&gt;
　&lt;a href=&quot;/miscellaneous/2024-05-04/app_private&quot;&gt;以前の記事&lt;/a&gt;に書いたように&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Play&lt;/code&gt;にも不満がありますし、今後は出来るだけGoogleとは距離を置いて行こうと思ってます。&lt;/p&gt;

&lt;h3 id=&quot;kindleはその都度入金&quot;&gt;Kindleはその都度入金&lt;/h3&gt;
&lt;p&gt;　Googleの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AdSense&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AdMob&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader Revenue Manager&lt;/code&gt;も一定金額になるまで支払いは保留されています。そのことについてはこちらも了解済みですので文句はありませんが、Google程の大企業だとその保留分の金利だけでもかなりの儲けになるでしょう。それに対してAmazonの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kindle Direct Publishing&lt;/code&gt;で出版した本の売上はその都度入金されます。振込手数料とかはどうなってるのか知りませんが、この点はAmazonはまともですね。&lt;a href=&quot;https://www.amazon.co.jp/HTML5-CoffeeScriptで作る最強の三目並べプログラム-MIN-MAX法からαβ法へ-happyclam-ebook/dp/B01D1IJ0S0/ref=sr_1_1?s=digital-text&amp;amp;ie=UTF8&amp;amp;qid=1473938717&quot;&gt;Kindleに出品しているこの本&lt;/a&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;380円&lt;/code&gt;ですが、一冊売れるたびに私の口座に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;121円&lt;/code&gt;振り込まれます、さっきAmazonはまともだと言いましたが、ボリ過ぎだろ！&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Mon, 04 Nov 2024 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/miscellaneous/2024-11-04/RRM</link>
        <guid isPermaLink="true">https://happyclam.github.io/miscellaneous/2024-11-04/RRM</guid>
        
        <category>google</category>
        
        <category>epub</category>
        
        
        <category>miscellaneous</category>
        
      </item>
    
  </channel>
</rss>
