<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>自己満足プログラミング</title>
    <description>Reinventing the wheel.</description>
    <link>https://happyclam.github.io/</link>
    <atom:link href="https://happyclam.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 31 Jan 2026 11:32:26 +0900</pubDate>
    <lastBuildDate>Sat, 31 Jan 2026 11:32:26 +0900</lastBuildDate>
    <generator>Jekyll v3.10.0</generator>
    
      <item>
        <title>消える三目並べをマルコフ拡張</title>
        <description>&lt;h3 id=&quot;chatgpt様々&quot;&gt;ChatGPT様々&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://happyclam.booth.pm/items/6582961&quot;&gt;消える三目並べ（Vanishing TicTacToe）アプリ&lt;/a&gt;をリリースしてからかなり経ちますが、&lt;a href=&quot;https://happyclam.booth.pm/items/6582961&quot;&gt;このアプリ&lt;/a&gt;は&lt;a href=&quot;https://happyclam.github.io/project/2016-09-19/tictactoe_evo&quot;&gt;通常の三目並べアプリ&lt;/a&gt;と同様に&lt;a href=&quot;https://hb.afl.rakuten.co.jp/hgc/18980d66.5ec24871.18980d67.e8ecef93/?pc=https%3A%2F%2Fitem.rakuten.co.jp%2Fbook%2F5271872%2F&amp;amp;m=http%3A%2F%2Fm.rakuten.co.jp%2Fbook%2Fi%2F12693001%2F&amp;amp;link_type=text&amp;amp;ut=eyJwYWdlIjoiaXRlbSIsInR5cGUiOiJ0ZXh0Iiwic2l6ZSI6IjI0MHgyNDAiLCJuYW0iOjEsIm5hbXAiOiJyaWdodCIsImNvbSI6MSwiY29tcCI6ImxlZnQiLCJwcmljZSI6MCwiYm9yIjoxLCJjb2wiOjAsImJidG4iOjF9&quot;&gt;「STASTIC HACKS」&lt;/a&gt;という本に書かれていた、勝った時は報酬の石ころを＋３，負けた時は−１与えるという方法（確率的方策によるモンテカルロ制御とか&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ポリアの壺モデル&lt;/code&gt;とか言うそうです。ChatGPTとの会話の中では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;石ころ法&lt;/code&gt;と呼んでました）で強化学習を行い徐々にAIが強くなっていくというものです。でも「消える三目並べ」では「通常の三目並べ」のようには強くなりませんでした。&lt;br /&gt;
　そこで、長年疑問に思っていたことをChatGPTに聞いてみたら、あっさり学習用のサンプルプログラムを出力してくれて、少しは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;マルコフ過程&lt;/code&gt;について理解出来るようになったので経緯を紹介します。&lt;/p&gt;

&lt;h3 id=&quot;何かが足りないとは思っていた&quot;&gt;「何かが足りない」とは思っていた&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://happyclam.booth.pm/items/6582961&quot;&gt;消える三目並べアプリ&lt;/a&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;αβ法を使った最強の消える三目並べプログラム&lt;/code&gt;相手に10,000局対戦学習させてリリースしています。消える三目並べは先手必勝のゲームなので、「少なくとも先手の時は人間には負けなくなる」ぐらいにまで確認したかったのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11手読み（消える三目並べは初手から11手読みをすれば先手必勝です）の最強プログラム&lt;/code&gt;を使って学習するのは非常に時間がかかります（昔の私のPC環境で10,000局の学習で一週間ぐらい？）ので、そこまでは確認できませんでした。&lt;br /&gt;
　それに&lt;a href=&quot;https://happyclam.github.io/programming/2016-11-03/ml_miscellaneous2&quot;&gt;昔の記事&lt;/a&gt;にも書いてますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「消える三目並べ」では通常の三目並べと違い６手目以降は駒が消えていくので現在の局面（９マスの配置）を見ただけでは最善手の判断が出来ません&lt;/code&gt;。次にどの駒（×か○か）が消えるのかを知っていなければ学習しようがないはずで、強化学習プログラムとしては何か足りないのでは？と思っていました。&lt;br /&gt;
　でも、出来上がったプログラムは&lt;a href=&quot;https://happyclam.github.io/tictactoe-van/&quot;&gt;PC版&lt;/a&gt;で実際に対局してもらえば解ると思いますがそこそこ強いです。先手必勝手順を知らなければAIが後手でも人間によく勝ちます。なので、強くなっていることに嘘はないから「強くはなるけど正解ではないな」と思いながらも妥協して&lt;a href=&quot;https://happyclam.booth.pm/items/6582961&quot;&gt;アプリ&lt;/a&gt;をリリースしていました。&lt;/p&gt;

&lt;h3 id=&quot;マルコフ連鎖との出会い&quot;&gt;マルコフ連鎖との出会い&lt;/h3&gt;
&lt;p&gt;　マルコフ連鎖なんて言葉自体も知りませんでしたが、ある時&lt;a href=&quot;https://hb.afl.rakuten.co.jp/ichiba/18980d66.5ec24871.18980d67.e8ecef93/?pc=https%3A%2F%2Fitem.rakuten.co.jp%2Fbook%2F1480131%2F&amp;amp;link_type=hybrid_url&amp;amp;ut=eyJwYWdlIjoiaXRlbSIsInR5cGUiOiJoeWJyaWRfdXJsIiwic2l6ZSI6IjI0MHgyNDAiLCJuYW0iOjEsIm5hbXAiOiJyaWdodCIsImNvbSI6MSwiY29tcCI6ImRvd24iLCJwcmljZSI6MSwiYm9yIjoxLCJjb2wiOjEsImJidG4iOjEsInByb2QiOjAsImFtcCI6ZmFsc2V9&quot;&gt;「確率の話」&lt;/a&gt;という古い本を見つけて読んでいると「確率で英語を作ってみよう」というタイトルでマルコフ過程の話が書かれていて、「これって消える三目並べにも使えるんじゃないか？」と直感してマルコフ連鎖に関する本を２冊買いましたが、難しい数式ばかり出てきて自分が知りたいことは書かれてなく、自分にとっては睡眠薬代わりにしかなりませんでした。&lt;br /&gt;
　&lt;a href=&quot;https://hb.afl.rakuten.co.jp/ichiba/18980d66.5ec24871.18980d67.e8ecef93/?pc=https%3A%2F%2Fitem.rakuten.co.jp%2Fbook%2F1480131%2F&amp;amp;link_type=hybrid_url&amp;amp;ut=eyJwYWdlIjoiaXRlbSIsInR5cGUiOiJoeWJyaWRfdXJsIiwic2l6ZSI6IjI0MHgyNDAiLCJuYW0iOjEsIm5hbXAiOiJyaWdodCIsImNvbSI6MSwiY29tcCI6ImRvd24iLCJwcmljZSI6MSwiYm9yIjoxLCJjb2wiOjEsImJidG4iOjEsInByb2QiOjAsImFtcCI6ZmFsc2V9&quot;&gt;「確率の話」&lt;/a&gt;に出てきた、英語の文書を学習して次に来るアルファベットを確率で選んで英文を作るという方法、「次の状態の分布が、現在の状態だけで決まる」という状態が、消える三目並べの「次にどの駒が消えるかを知っていれば次の手が決まる状態」と似てると思ったのですが、長年どのように実装すればいいか見当付きませんでした。&lt;br /&gt;
　そこで先日ChatGPTに「消える三目並べというゲームは、２重マルコフ過程を組み込んだ学習だと早く学習が完了する気がするのですが？」と聞いてみたところ「あなたの洞察は正しいです。２手前の自分の駒が消えるという２手履歴依存のルールなので、このゲームには非常に効果があります」と言われました。&lt;br /&gt;
　ただ、自分が想像していたこととChatGPTが示すマルコフ過程の実装方法は全然違っていました。私は指し手を選択する際に局面毎に９箇所に溜め込まれている石の数の合計を正規化して確率で指し手を選択（ルーレット選択）している部分を、過去の指し手の履歴を参照しながら更に確率選択するようなことを考えていたのですが、そうではなく消える三目並べというゲームの非マルコフの状態をマルコフ性を持つ状態にすることが大事だということらしいです。つまり&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;状態遷移（stateメソッド）&lt;/code&gt;を変えることが大事で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;行動選択（choose_actionメソッド）&lt;/code&gt;は変える必要はなく、難しい数式も必要ないとのことでした。&lt;br /&gt;
　また、マルコフ連鎖に関する本についても説明してくれました。数式が自分には難しすぎたと言ったら、あの手の本は「状態が既にマルコフである」前提で書かれていて、「あなたは今マルコフでないものを、どうやってマルコフにするか」をやっているので、定理、行列、極限定理について書かれている本は一切役に立たないと言われました。数式は「裏付けとして読むもので、実装に必要なものではありません」とも言われて、なるほど！と思いましたし、やる気にさせるのもうまいなぁと思いました。確かに昔「日経平均先物・オプションのシミュレーター」（&lt;a href=&quot;https://happyclam.github.io/project/2014-05-24/my-posi&quot;&gt;「先物・オプションのシミュレーションサイト」&lt;/a&gt;、&lt;a href=&quot;https://happyclam.github.io/miscellaneous/2014-05-27/my-posi_vola&quot;&gt;「ボラティリティについて」&lt;/a&gt;）を作ったときも、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ブラックショールズ方程式&lt;/code&gt;なんて全然分からなくても作れました。&lt;br /&gt;
　結局、マルコフ過程なんて全く知らなかった自分の直感（洞察）は正しかったのですが、実装方法は全く見当違いの考えに向かっていたようです:sweat_smile:ChatGPTが修正してくれました:pray:&lt;/p&gt;

&lt;h3 id=&quot;chatgptのサンプルコードが分かりやす過ぎる&quot;&gt;ChatGPTのサンプルコードが分かりやす過ぎる&lt;/h3&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;div align=&quot;center&quot;&gt;ソースコード&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/tictactoe-van.git&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;消える三目並べ強化学習プログラム&quot; title=&quot;消える三目並べ強化学習プログラム&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;　ChatGPTに「石ころ法とマルコフ法が比較できる消える三目並べの強化学習プログラムの例」を出して貰いました。まず驚いたのはソースコードの短さ、シンプルさです。非常に分かりやすいので、今後改良していくとしてもこのサンプルを使うことにして、自分が書いた元のプログラムはもう更新しないつもりですが、自分のものとChatGPT版との違いを書いておきます。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;masterブランチ&lt;/th&gt;
      &lt;th&gt;chatGPTブランチ&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;対戦相手&lt;/td&gt;
      &lt;td&gt;αβ法を使った11手読みのプログラム&lt;/td&gt;
      &lt;td&gt;自己対戦&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;プレイヤー&lt;/td&gt;
      &lt;td&gt;先手・後手の２インスタンス&lt;/td&gt;
      &lt;td&gt;１インスタンス&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;学習データ&lt;/td&gt;
      &lt;td&gt;局面（配列）を持つオブジェクトのツリー構造&lt;/td&gt;
      &lt;td&gt;局面（配列）をキーとするハッシュテーブル&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　石ころ法（DisappearingTicTacToeクラス）とマルコフ法（DisappearingMarkovクラス）を定義したファイルを使い分ければ比較が出来ます。&lt;br /&gt;
　自分のやり方との一番の違いはプレイヤーを分けてないことだと思います。自分はプレイヤーを分けなければいけないと思ってそうしたのですが、その所為でコード量が増えました。ChatGPTによるとプレイヤーを分けなくても、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;にプレイヤー情報が含まれてるので、先手（×）と後手（○）の戦略が混ざることは無いらしいです。&lt;/p&gt;

&lt;h3 id=&quot;サンプルプログラムの強化学習の結果は&quot;&gt;サンプルプログラムの強化学習の結果は？&lt;/h3&gt;
&lt;p&gt;　消える三目並べは先手必勝のゲームなので、学習がうまく進んでいるかを確認する分かりやすい指標があります。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|8|9|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　消える三目並べでは初手で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;辺&lt;/code&gt;の位置（上記図の2,4,6,8）を選べば勝てるので、初期盤面の学習データを見ればある程度学習が正しく進んでいるか確認できます。実際の&lt;a href=&quot;https://happyclam.booth.pm/items/6582961&quot;&gt;アプリ&lt;/a&gt;のデータとは少し違うのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;masterブランチ&lt;/code&gt;のデータ作成スクリプト（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test.sh&lt;/code&gt;）を走らせて作った学習済み初期データの中の初期盤面のデータはだいたい以下のように&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;辺&lt;/code&gt;の値が最大になります。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[1.8780000000000001, 2.4969999999999994, 1.9093333333333335, 1.0266666666666668, 1.8543333333333336, 1.6765714285714288, 1.6146666666666667, 49.082161893662, 1.6433333333333335]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　しかし、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chatGPTブランチ&lt;/code&gt;のマルコフ法（DisappearingMarkovクラス）でデータ作成プログラム（learning.rb）をエピソード数を100,000回とか300,000回にして走らせて作った学習データは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;角&lt;/code&gt;や&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;真ん中&lt;/code&gt;が最大値になってしまい、1,000,000回！以上自己対戦することでようやく安定して以下のように&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;辺&lt;/code&gt;の位置が最大値で安定するようになりました。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&quot;_________X[]&quot;, 3]=&amp;gt;586.0,
[&quot;_________X[]&quot;, 1]=&amp;gt;43124.0,
[&quot;_________X[]&quot;, 7]=&amp;gt;721704.0,
[&quot;_________X[]&quot;, 0]=&amp;gt;2910.0,
[&quot;_________X[]&quot;, 8]=&amp;gt;26665.0,
[&quot;_________X[]&quot;, 5]=&amp;gt;2107147.0,
[&quot;_________X[]&quot;, 6]=&amp;gt;6506.0,
[&quot;_________X[]&quot;, 4]=&amp;gt;21.0,
[&quot;_________X[]&quot;, 2]=&amp;gt;3743.0,
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;https://happyclam.github.io/software/2019-07-19/self-play&quot;&gt;通常の三目並べの時&lt;/a&gt;もそうでしたが、単純に自己対戦に変えるだけだと試行回数を増やす必要があるみたいです。&lt;br /&gt;
　また、試してもらえば分かりますが、単純な&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;石ころ法（DisappearingTicTacToeクラス）&lt;/code&gt;の方はエピソード数をいくら増やしても全然初手が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;辺&lt;/code&gt;に偏りません。&lt;a href=&quot;https://happyclam.booth.pm/items/6582961&quot;&gt;自分のアプリ&lt;/a&gt;（masterブランチ）は２手分の着手の履歴を持たない（非マルコフ）のまま&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;αβ法のプログラムと対戦させたらうまく学習できたのになぜ？&lt;/code&gt;と思ったのですが、これもChatGPTに聞いてみると、αβ法のプログラムと対戦させることで「環境が事実上マルコフ化」したということのようです。これもChatGPTに聞かないと気づけなかったかもしれません、つまりαβ法のプログラムは２手分の履歴を持ってなくても&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;同じ局面で最善手が変わること&lt;/code&gt;を分かっているので正しく学習出来たということです。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;分かっていないもの同士の自己対戦&lt;/code&gt;ではそれが出来ません。ここでも自己対戦による学習と疑似教師あり学習の違いが出たってことですね。&lt;br /&gt;
　念の為書いておきますが通常の三目並べの場合は状態が既にマルコフなので、&lt;a href=&quot;https://happyclam.github.io/software/2019-07-19/self-play&quot;&gt;自己対戦での学習&lt;/a&gt;でもうまくいったということでしょう。&lt;/p&gt;

&lt;h3 id=&quot;それでも弱すぎる&quot;&gt;それでも弱すぎる&lt;/h3&gt;
&lt;p&gt;　初手に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;辺&lt;/code&gt;を選ぶことは学習出来たようですが、対人戦用のプログラム（play.rb）で対戦してみると非常に弱いです。体感では&lt;a href=&quot;https://happyclam.booth.pm/items/6582961&quot;&gt;自分のアプリ&lt;/a&gt;よりかなり弱いので、せっかくマルコフ化して改良したのだから、自己対戦学習で、少なくとも&lt;a href=&quot;https://happyclam.github.io/tictactoe-van/&quot;&gt;疑似教師学習したアプリ&lt;/a&gt;よりかは強くなるようにしたいと思ってます。もちろんChatGPTの助けが必要になると思います。&lt;br /&gt;
　&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 25 Jan 2026 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2026-01-25/markov_chain</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2026-01-25/markov_chain</guid>
        
        <category>coffeescript</category>
        
        <category>cordova</category>
        
        <category>tictactoe</category>
        
        <category>android</category>
        
        <category>javascript</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>PINされたステイルメイト</title>
        <description>&lt;h3 id=&quot;pin絡みのステイルメイトはレアケース&quot;&gt;PIN絡みのステイルメイトはレアケース？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;以前の記事&lt;/a&gt;で&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;販売中のチェスアプリ&lt;/a&gt;が、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;自分の駒がPINされた状態でのステイルメイト問題&lt;/code&gt;を解くことが出来なかったという話を書きましたが、一つのケースしか試せなかったので他にも似たようなテストケースは無いものかと探していて&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kindle&lt;/code&gt;で&lt;a href=&quot;https://www.amazon.co.jp/Mate-Threats-Defense-Tactical-Examples-ebook/dp/B0F7QZC1P1/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=GOV4ROULTR05&amp;amp;dib=eyJ2IjoiMSJ9.KpMtE999j0FdWDJH1xg8BA.aRAMtoW_coazhXgP2UDnec3AIZRrUn9n8-7PbES4Df4&amp;amp;dib_tag=se&amp;amp;keywords=Mate+Threats+and+Defense+-+1000+Tactical+Examples&amp;amp;qid=1747650832&amp;amp;s=digital-text&amp;amp;sprefix=mate+threats+and+defense+-+1000+tactical+examples+%2Cdigital-text%2C153&amp;amp;sr=1-1&quot;&gt;「Mate Threats and Defense - 1000 Tactical Examples」&lt;/a&gt;という本を購入しました。将棋で言えば「次の一手問題集」みたいなものだと思いますが、問題がテーマ毎に分類されていて&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;だけを取り扱った章もあるので、これなら自分が探している問題もあるだろうと期待して購入しました。&lt;/p&gt;

&lt;h3 id=&quot;探しているのはpinされたステイルメイト問題&quot;&gt;探しているのはPINされたステイルメイト問題&lt;/h3&gt;
&lt;p&gt;　自分が探しているテストケースは&lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;前回の記事&lt;/a&gt;で紹介したような「味方の駒が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;された状態に持ち込むステイルメイト」問題です。&lt;a href=&quot;https://www.amazon.co.jp/Mate-Threats-Defense-Tactical-Examples-ebook/dp/B0F7QZC1P1/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=GOV4ROULTR05&amp;amp;dib=eyJ2IjoiMSJ9.KpMtE999j0FdWDJH1xg8BA.aRAMtoW_coazhXgP2UDnec3AIZRrUn9n8-7PbES4Df4&amp;amp;dib_tag=se&amp;amp;keywords=Mate+Threats+and+Defense+-+1000+Tactical+Examples&amp;amp;qid=1747650832&amp;amp;s=digital-text&amp;amp;sprefix=mate+threats+and+defense+-+1000+tactical+examples+%2Cdigital-text%2C153&amp;amp;sr=1-1&quot;&gt;「Mate Threats and Defense」&lt;/a&gt;では、問題がテーマ毎に分類されていると言っても流石に「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;されたステイルメイト」というテーマはなかったので、第7章（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「STALEMATE IDEAS」&lt;/code&gt;）の中から探してみるとNo.91からNo.106までの16問の問題の内２問だけ目的のものが見つかりました。第１３章（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「PINNING」&lt;/code&gt;）も中も探しましたが、そこでは主に相手の駒を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;して動けないようにして自玉（King）を守る問題が紹介されていて、特にステイルメイトとは関係無い問題のようです。自分が確認したのは第７章とそれに続く第８章と第１３章だけなのでもしかしたら他の問題の中にも自分が探しているケースがあるかもしれませんが、意外と少ないようです。&lt;br /&gt;
　チェスプレイヤーがステイルメイトで勝負を引き分けに持ち込むときに、自分の駒がPINされてるかどうかなんて二の次であまり意識しないでしょうから&lt;a href=&quot;https://www.amazon.co.jp/Mate-Threats-Defense-Tactical-Examples-ebook/dp/B0F7QZC1P1/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=GOV4ROULTR05&amp;amp;dib=eyJ2IjoiMSJ9.KpMtE999j0FdWDJH1xg8BA.aRAMtoW_coazhXgP2UDnec3AIZRrUn9n8-7PbES4Df4&amp;amp;dib_tag=se&amp;amp;keywords=Mate+Threats+and+Defense+-+1000+Tactical+Examples&amp;amp;qid=1747650832&amp;amp;s=digital-text&amp;amp;sprefix=mate+threats+and+defense+-+1000+tactical+examples+%2Cdigital-text%2C153&amp;amp;sr=1-1&quot;&gt;この本&lt;/a&gt;の著者がそういう分類をしていないのは当然でしょう。でも、&lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;以前の記事&lt;/a&gt;で書いたように、開発者にとってはそこが大きな問題だったりします。ユーザーのニーズを実現するための苦労が、ユーザーがまったく気が付かないところにあったなんてことは業務ソフトの開発現場でもよくあることですね。&lt;br /&gt;
　それと、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;有用なテストケース&lt;/code&gt;に出会えるかどうかがソフト開発に大事だったりしますが、&lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;以前の記事&lt;/a&gt;のケースは本当に助かりました。&lt;a href=&quot;https://www.amazon.co.jp/Mate-Threats-Defense-Tactical-Examples-ebook/dp/B0F7QZC1P1/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=GOV4ROULTR05&amp;amp;dib=eyJ2IjoiMSJ9.KpMtE999j0FdWDJH1xg8BA.aRAMtoW_coazhXgP2UDnec3AIZRrUn9n8-7PbES4Df4&amp;amp;dib_tag=se&amp;amp;keywords=Mate+Threats+and+Defense+-+1000+Tactical+Examples&amp;amp;qid=1747650832&amp;amp;s=digital-text&amp;amp;sprefix=mate+threats+and+defense+-+1000+tactical+examples+%2Cdigital-text%2C153&amp;amp;sr=1-1&quot;&gt;今回購入した本&lt;/a&gt;のステイルメイト問題は、自分のようなチェス初心者から見ると「ステイルメイトを狙わないと絶対負ける」とも言えないような曖昧なものが多かったので少し物足りませんでした。もっと分かりやすいテストケースが欲しかったです。&lt;/p&gt;

&lt;h3 id=&quot;ステイルメイト千日手&quot;&gt;ステイルメイト＝千日手？&lt;/h3&gt;
&lt;p&gt;　チェスに詳しくない自分の認識ではステイルメイト（Stalemate、合法手が無い手詰まり状態）と千日手（Threefold Repetition、同一局面の３回繰り返し）は全く別物だと思っていたのですが、&lt;a href=&quot;https://www.amazon.co.jp/Mate-Threats-Defense-Tactical-Examples-ebook/dp/B0F7QZC1P1/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=GOV4ROULTR05&amp;amp;dib=eyJ2IjoiMSJ9.KpMtE999j0FdWDJH1xg8BA.aRAMtoW_coazhXgP2UDnec3AIZRrUn9n8-7PbES4Df4&amp;amp;dib_tag=se&amp;amp;keywords=Mate+Threats+and+Defense+-+1000+Tactical+Examples&amp;amp;qid=1747650832&amp;amp;s=digital-text&amp;amp;sprefix=mate+threats+and+defense+-+1000+tactical+examples+%2Cdigital-text%2C153&amp;amp;sr=1-1&quot;&gt;「Mate Threats and Defense」&lt;/a&gt;の第７章（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「STALEMATE IDEAS」&lt;/code&gt;）に続く第８章（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「COMBINATIONS」&lt;/code&gt;）では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;が絡み合う問題が紹介されてます。形勢不利な白番（先手）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;に持ち込もうとして黒番（後手）がそれを避けようとすると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;になってしまうという感じです。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;でチェスの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;について調べていると以下のように指南されました。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;日本では、将棋の千日手（同じ局面が繰り返される場合）と混同されがちですが、チェスの千日手は「合法な手がない状態」を指すため、局面の繰り返し（三回繰り返しによる引き分け）とは異なることに注意してください。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;は別物だよと念を押してるわけですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;の日本語訳が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;だと思ってるのでしょうか？日本の将棋プレイヤーにとっては将棋のルールにない&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;は、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に言われるまでもなく&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;とはまったく違う特殊なものと認識しているので、むしろ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;が似ていることに驚きました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;を日本語に訳す時に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;膠着状態&lt;/code&gt;と訳す場合もあるみたいですが、たしかに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;膠着状態&lt;/code&gt;には違いないですね。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;も引き分けの一種という認識が正しいようです。&lt;br /&gt;
　あまり深く考えたことがなかったのですが、将棋の棋書で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;だけを取り扱った棋書なんて見たことない（かなり昔の角換わり腰掛け銀の千日手定跡の解説は見たことが有ります）ので、戦術や戦略の分析・分類という点では将棋よりチェスの方が進んでいるのかもしれません。そして「こうこうこういう理由でこの局面では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;千日手&lt;/code&gt;が避けられないんだよ」と解説している将棋の棋書があれば読んでみたい気もしますが、そういう棋書を書くのはチェスよりも難しそうですね。&lt;/p&gt;

&lt;h3 id=&quot;pinが絡むステイルメイトの問題例&quot;&gt;PINが絡むステイルメイトの問題例&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://www.amazon.co.jp/Mate-Threats-Defense-Tactical-Examples-ebook/dp/B0F7QZC1P1/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=GOV4ROULTR05&amp;amp;dib=eyJ2IjoiMSJ9.KpMtE999j0FdWDJH1xg8BA.aRAMtoW_coazhXgP2UDnec3AIZRrUn9n8-7PbES4Df4&amp;amp;dib_tag=se&amp;amp;keywords=Mate+Threats+and+Defense+-+1000+Tactical+Examples&amp;amp;qid=1747650832&amp;amp;s=digital-text&amp;amp;sprefix=mate+threats+and+defense+-+1000+tactical+examples+%2Cdigital-text%2C153&amp;amp;sr=1-1&quot;&gt;「Mate Threats and Defense」&lt;/a&gt;の中から一つ例を取り上げてみます。&lt;/p&gt;

&lt;h5 id=&quot;chapter-7-no105&quot;&gt;Chapter 7 No.105&lt;/h5&gt;
&lt;p&gt;　白（先手）劣勢？ですが、ここからステイルメイトに持ち込みます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;開始局面（クリックで拡大）&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_105_1.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_105_1.png&quot; alt=&quot;Stalemate Ideas No.105&quot; width=&quot;320&quot; height=&quot;251&quot; title=&quot;No.105&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;解答手順：1.♘g6+ ♜xg6 2.♖xh7+ ♚xh7 3.♕xg7+ ♚xg7&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;ステイルメイト局面（クリックで拡大）&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_105_2.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_105_2.png&quot; alt=&quot;Stalemate Ideas No.105&quot; width=&quot;320&quot; height=&quot;357&quot; title=&quot;No.105&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;g3の♗（ビショップ）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;されていて白番（先手）は指す手が無くなりステイルメイト完成です。&lt;br /&gt;
　なぜこの局面がステイルメイトだと判断するのが難しかったのかというと、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;駒の利きだけを見て判断すると&lt;/code&gt;g6の黒（後手）の♜（ルーク）の利きはg5,g4,g3と下方に伸びているのですが、g3に白（先手）の♗（ビショップ）が存在するのでそこで駒の利きが遮られるのでその先のg1にある白（先手）の♔（キング）までg6の♜（ルーク）が利いていると判断出来ないからです。そのため&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stockfish&lt;/code&gt;では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN用のフラグ&lt;/code&gt;を持たせて制御しているようですが、&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;自分のアプリ&lt;/a&gt;ではそのようなデータは持たせていないので苦労しました。でも、&lt;a href=&quot;https://www.amazon.co.jp/Mate-Threats-Defense-Tactical-Examples-ebook/dp/B0F7QZC1P1/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=GOV4ROULTR05&amp;amp;dib=eyJ2IjoiMSJ9.KpMtE999j0FdWDJH1xg8BA.aRAMtoW_coazhXgP2UDnec3AIZRrUn9n8-7PbES4Df4&amp;amp;dib_tag=se&amp;amp;keywords=Mate+Threats+and+Defense+-+1000+Tactical+Examples&amp;amp;qid=1747650832&amp;amp;s=digital-text&amp;amp;sprefix=mate+threats+and+defense+-+1000+tactical+examples+%2Cdigital-text%2C153&amp;amp;sr=1-1&quot;&gt;今回購入した本&lt;/a&gt;に収録されている問題をいくつか解けたので、とりあえずこれで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PINされたステイルメイトのケース&lt;/code&gt;も問題なくなったと思ってます（&lt;a href=&quot;https://happyclam.github.io/software/2018-06-10/droppawncheck&quot;&gt;打ち歩詰めチェックの記事&lt;/a&gt;に書いたような、先読みをして&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;を掛けるという方法が取れないのが辛いところです）。どのように解決したかアルゴリズムを解説すると長くなるのですが、簡単に言うと♔（キング）側から８方向に敵の駒にぶつかるまでチェックしていくという方法です。いつか別の記事で書くかもしれませんが、気になる方は&lt;a href=&quot;https://github.com/happyclam/chessCUI.git&quot;&gt;ソースファイル&lt;/a&gt;を見ていただきたいと思います。&lt;br /&gt;
　あと、この問題を開始局面から解くには５手読みが必要で、&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;実際のアプリ&lt;/a&gt;では３手読みしかしていないので正解出来ません。あくまでも読みを深くすれば正解出来るのかどうかのテストです。ちなみに開始局面から２手進めた局面（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;♘g6+ ♜xg6&lt;/code&gt;）から自分のPC環境で３手読みすると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6.93秒&lt;/code&gt;で解答できるのですが、開始局面から５手読みすると解答までに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1987.61秒（約３３分）&lt;/code&gt;掛かってしまいます。&lt;/p&gt;

&lt;h3 id=&quot;チェスはcuiでも試しやすい&quot;&gt;チェスはCUIでも試しやすい&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://www.amazon.co.jp/Mate-Threats-Defense-Tactical-Examples-ebook/dp/B0F7QZC1P1/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=GOV4ROULTR05&amp;amp;dib=eyJ2IjoiMSJ9.KpMtE999j0FdWDJH1xg8BA.aRAMtoW_coazhXgP2UDnec3AIZRrUn9n8-7PbES4Df4&amp;amp;dib_tag=se&amp;amp;keywords=Mate+Threats+and+Defense+-+1000+Tactical+Examples&amp;amp;qid=1747650832&amp;amp;s=digital-text&amp;amp;sprefix=mate+threats+and+defense+-+1000+tactical+examples+%2Cdigital-text%2C153&amp;amp;sr=1-1&quot;&gt;「Mate Threats and Defense」&lt;/a&gt;に収められている問題は一つのテストファイル（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test/tactical.coffee&lt;/code&gt;）にまとめています。チェスは将棋と違って駒をキャラクター表示できるのでCUI環境でも遊べると思います。ただ、等幅フォントを使っても表示がズレる環境（特にWindows）は多いと思いますが、自分は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ubuntu + guake + Monospace 10フォント&lt;/code&gt;でうまく表示出来てます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;div align=&quot;center&quot;&gt;ソースコード&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/chessCUI.git&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;チェスアプリCUIのみ&quot; title=&quot;チェスアプリCUIのみ&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;　テスト（test/tactical.coffee）を実行するには&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_OPTIONS=&quot;--max-old-space-size=24576&quot; mocha --require coffeescript/register --require test/setup.coffee &quot;test/tactical.coffee&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　テスト（test/tactical.coffee）ファイル内の上記の例だけを実行するには&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_OPTIONS=&quot;--max-old-space-size=24576&quot; mocha --require coffeescript/register --require test/setup.coffee -g &quot;stalemate_105-1&quot; &quot;test/tactical.coffee&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;です。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Tue, 30 Dec 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-12-30/pin_induced_stalemate</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-12-30/pin_induced_stalemate</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>chess</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>将棋＆チェスアプリの高速化</title>
        <description>&lt;h3 id=&quot;効果は微々たるもの&quot;&gt;効果は微々たるもの&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2025-08-23/JSvsCPlus&quot;&gt;前回の記事&lt;/a&gt;で書いたChatGPTからのアドバイス（駒種判定のためのメソッド呼び出しをやめた件）をCoffeeScript(JavaScript)版にも取り入れて少しは速度アップ（README.mdの例で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1781ミリ秒&lt;/code&gt;掛かっていた処理が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1279ミリ秒&lt;/code&gt;、約25%アップ）しましたが体感できるほどではありません（&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;masterのlistPiecesタグ&lt;/a&gt;）。&lt;br /&gt;
　そこで、その最新バージョンを元に将棋盤を配列として扱う形に変更して、Pieceオブジェクトで座標管理するのをやめてみました（&lt;a href=&quot;https://github.com/happyclam/shogi33simple/tree/arrayBoard&quot;&gt;arrayBoardブランチ&lt;/a&gt;）。そして、取り敢えず速度の比較が出来るところまで作り込んだだけで全然未完成なのですが、取り敢えず気になっていたことを確認してみました。&lt;/p&gt;

&lt;h3 id=&quot;何が気になっていたのか&quot;&gt;何が気になっていたのか&lt;/h3&gt;
&lt;p&gt;　現行のプログラムでは将棋盤オブジェクト(Board)で全ての駒オブジェクト(Piece)のリストを管理していて、盤上の座標位置は駒オブジェクトに持たせています。普通に考えれば将棋盤クラスで座標（段・列）を管理することを考えると思いますが、駒台が必要なので駒台にある駒と将棋盤上にある駒を区別して管理するのが面倒です。作ったのはかなり昔なのでその時の動機をはっきりと憶えているわけではありませんが、着手した手を元に戻す操作を実装する際に、持ち駒を打ったのか盤上の駒を動かしたのかによって処理が分かれるので、局面を読み進める際に「指しては戻し、打っては戻し、取った相手の駒を駒台から盤上に戻す、という操作を繰り返しながら整合性を保つのは大変だ、絶対バグる」と考えたのだと思います。Pieceオブジェクトで座標を管理していれば、持ち駒も盤上の駒も区別なくPieceオブジェクトが持つ座標を書き換えるだけで済むというメリットがあります。&lt;br /&gt;
　&lt;a href=&quot;/software/2023-11-18/abmethod_skipped&quot;&gt;マンカラアプリの解説記事&lt;/a&gt;でも書いていますが、マンカラで着手した一手を元に戻すのは「横取り」のルール等もあって非常にややこしいので、マンカラの先読み過程では一手毎にマンカラの盤ごとコピーして、着手して局面を評価した後に破棄するというやり方で実装しました。着手を元に戻すという処理をしていません。マンカラの場合は豆の数が入った単なる一つの配列なのでコピーしても負荷は小さいですが、将棋盤オブジェクトとそこにある駒オブジェクトの局面ごとコピーするのはかなりの負荷なので、将棋プログラムでマンカラと同じやり方で実装すると実行速度アップは望めません。&lt;br /&gt;
　なので、マンカラほど複雑ではないとはいえ、頑張って着手を元に戻す処理（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;revert処理&lt;/code&gt;）さえ正確に実装すれば将棋盤と駒台が分かれていても速度アップできるのかな？と考えてそれを確かめるために&lt;a href=&quot;https://github.com/happyclam/shogi33simple/tree/arrayBoard&quot;&gt;arrayBoard&lt;/a&gt;ブランチを作って試してみたわけです。&lt;br /&gt;
　&lt;a href=&quot;/software/2025-08-23/JSvsCPlus&quot;&gt;前回の記事&lt;/a&gt;で「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT&lt;/code&gt;が将棋盤を配列にしろ」と言ってましたが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に聞いても同じアドバイスをされました。どうやら生成AIにとっては「これが正解」という将棋プログラムの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;クラス設計&lt;/code&gt;がはっきりしているということかもしれません。速くなるのなら独自のやり方に拘るつもりもないので、将来的には&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;が示すやり方で仕上げてみようかとも思ってます。&lt;/p&gt;

&lt;h3 id=&quot;具体的な変更箇所&quot;&gt;具体的な変更箇所&lt;/h3&gt;
&lt;p&gt;　やったことを簡単に言えばPieceクラスから座標を管理するための&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@posiメンバー&lt;/code&gt;を削除して、Boardクラスを配列クラスの継承クラスにし、駒のリストを管理する&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@piecesメンバー&lt;/code&gt;を削除しただけなのですが、これをすることによって&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dest = (v for v in @pieces when v.posi? &amp;amp;&amp;amp; v.posi[0] == d_posi[0] &amp;amp;&amp;amp; v.
posi[1] == d_posi[1])[0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;このように全ての駒を走査してその場所に存在する駒を取得していた処理が&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dest = @[d_posi[0] - 1][d_posi[1] - 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;とBoardオブジェクトの配列を参照する処理だけで済みます。&lt;br /&gt;
現在リリースしているアプリも今回の改良版（&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;master&lt;/a&gt;）でも、最も頻繁に呼び出されるであろう着手可能かどうかを判定するメソッド（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check_move&lt;/code&gt;）内でこの作業を毎回やっていて、流石にこれは冗長だろうと考えてPlayer.think内ではわざわざ盤面用の２元配列を用意して（Player.think内のsrc変数）Pieceオブジェクトをその配列に配置し直して駒のリストを全探索しないで済むように改良した経緯があります。&lt;br /&gt;
　そんなこと（駒オブジェクトで管理している座標を元に将棋盤の配列を生成）しているぐらいなら、元からBoardクラスを配列にしていた方が速くなるのかな？と考えて今回実験してみたのですが、結果は？&lt;/p&gt;

&lt;h3 id=&quot;arrayboardブランチの実験結果&quot;&gt;arrayBoardブランチの実験結果&lt;/h3&gt;
&lt;p&gt;　README.mdの対局例を実行した結果は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1700ミリ秒&lt;/code&gt;ぐらいかかって、現在リリースしているバージョンとほぼ変わりませんでした。現在リリース中のアプリより若干改良高速化した後での結果ですから、Boardクラスを配列にしただけでは却って遅くなったと言えます。結局、将棋盤上の駒を取得する処理が軽くなっても指し手の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;revert処理&lt;/code&gt;は複雑になってしまいましたし、トレードオフの関係にあるのでしょう。&lt;br /&gt;
　とはいえBoardクラスを配列にすると他にも高速化の手法がありそうなので今後も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arrayBoardブランチ&lt;/code&gt;を育てていくかもしれませんが、取り敢えずはここで打ち切ろうと思ってます。&lt;br /&gt;
　それと今回やった作業は駒の数が少ない３三将棋だから効果が薄かったのかもしれませんので、７七将棋でも試したいと思ってますが、現状の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arrayBoardブランチ&lt;/code&gt;はまだまだやり足りないことがいっぱいなので、完成するのはかなり先の話になると思います。&lt;br /&gt;
　そして完成したからといって速くなってる保証もありません:sweat_smile:ただ、そのソースを元に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えたら&lt;a href=&quot;/software/2025-08-23/JSvsCPlus&quot;&gt;前回の記事&lt;/a&gt;の結果とは違って速くなる、なんてことになるような気がします。&lt;/p&gt;

&lt;h3 id=&quot;今後のアプリの予定&quot;&gt;今後のアプリの予定&lt;/h3&gt;
&lt;p&gt;　冒頭で書いたように現在リリースしているものより若干は速くなったので&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;master（listPiecesタグ）&lt;/a&gt;の内容を反映して、将棋アプリもチェスアプリも順次リリースしていこうと思ってます。ついでに、最近はハイスペックなスマホも増えているので、どうせならAIのレベルを一手づつ読む深さを深くしてリリースしてみたいと思っているのですが、そうすると最強レベルだと現在以上に指し手が遅くなりますので、アプリを使う気が無くなるぐらい遅くなるかもしれません。でも、AIのレベルを下げれば今まで通りの指し手になるわけですから、あってもいいんじゃないかと思ってます。 全然ハイスペックではありませんが、私自身つい先日スマホを買い替えた（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pixel10Ⅶ&lt;/code&gt;）ので、それで試してから決めようと思ってます。一手深く読めば指し手がどのように変わるのか楽しみですよね？私は楽しみです:smile:&lt;br /&gt;
　いずれにしても&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;私のアプリ&lt;/a&gt;を使う人は指し手を気長に待てる人にしか向いてないと思います。&lt;/p&gt;

&lt;h3 id=&quot;よく分からない2025-10-15追記&quot;&gt;よく分からない（2025-10-15追記）&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://github.com/happyclam/shogi33simple/tree/arrayBoard&quot;&gt;arrayBoardブランチ&lt;/a&gt;がバグってて、&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;master（listPiecesタグ）&lt;/a&gt;より遅いのはそのままですが、バグを修正したら差が縮まってほぼ違いがないぐらいになりました（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1338ミリ秒&lt;/code&gt;、arrayBoardブランチは修正済み）。それならと、７七将棋アプリで同じことを試してみたら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;配列バージョン&lt;/code&gt;よりやはり&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;駒リストバージョン&lt;/code&gt;のほうが速かったです。う〜ん、成功する（させることが出来る）テスト自体まだ少ないのですが、将棋の駒が多い分効果が出るかと思ったのですが、よく分かりません。いつも開発作業を進めながら記事を書くことが多くて、早合点が多くて良くないですね。いずれにしても、もう少し突き詰めてから結論出そうと思います。&lt;br /&gt;
　と、いうことで新バージョンのリリースはもう少し後にしようと思います。&lt;/p&gt;

&lt;h3 id=&quot;７七将棋なら効果あり2025-10-25追記&quot;&gt;７七将棋なら効果あり（2025-10-25追記）&lt;/h3&gt;
&lt;p&gt;　３三将棋と同じところまで７七将棋の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;配列バージョン&lt;/code&gt;の対応を済ませてテストスクリプトの実行時間を確認したところ、３三将棋とは違って明確に速くなっているので取り敢えず７七将棋だけ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;配列バージョン&lt;/code&gt;に変更してリリースしてみようと思います。&lt;br /&gt;
　&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;３三将棋&lt;/a&gt;でも一部のテスト結果が旧版の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;駒リストバージョン&lt;/code&gt;とは違う結果（テスト失敗）になっていますが、７七将棋でも指し手に変化が出るようです。局面の静的評価に関わる数値は一切変更していないのに、指し手に変化が出る理由がはっきり分からないのですが、読む深さを変えるとテスト結果を旧版と同じにすることが可能なケースがほとんどなので今のところ大きな問題はないと思ってます。&lt;br /&gt;
　また、劇的に速くなったわけではないので、読みの深さを一手深くするのは今回は諦めます（新しいスマホ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pixel10Ⅶ&lt;/code&gt;で現状のアプリを動かしてみても、遅すぎてとても一手深くする状況ではないです）。読みの深さを変えなくても指し手が変わるので、それをしばらく楽しんでみようというのが本音です。何か問題があるかもしれませんが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「Done is better than perfect」&lt;/code&gt;なんて言いますし…:sweat_smile:&lt;/p&gt;

&lt;h3 id=&quot;７七将棋での効果も限定的2026-01-03追記&quot;&gt;７七将棋での効果も限定的（2026-01-03追記）&lt;/h3&gt;
&lt;p&gt;　「７七将棋なら効果あり」と書いてますが、その効果も限定的なので念の為補足しておきます。初めてリリースした時から変わっていませんが、新しくリリースした&lt;a href=&quot;https://happyclam.booth.pm/items/6346070&quot;&gt;７七将棋アプリ&lt;/a&gt;の最強モードでも３手読みまでしかしていません。その３手読みに関してはレスポンスタイムが約半分ぐらいに短縮出来ましたが、テストスクリプトでは５手読み、７手読みのテストもしていて、一つのテストに１時間ぐらいかかるものもあります。そしてそういう長手数のテストの実行時間を比較すると以前と大してレスポンスが変わっていません。&lt;br /&gt;
　つまり&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;駒リストバージョン&lt;/code&gt;から&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;配列バージョン&lt;/code&gt;に変えても３手読みまでは効果はあるけど、将棋盤を配列にしたことでメモリー消費も増えて、良い事尽くしって訳ではないです。今後、駒情報をキャッシュして差分更新するようなことを考えていますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript(Javascript)&lt;/code&gt;のままではコードが増える毎にパフォーマンスが落ちる気もします。しかし前述したようにそこまで手を尽くしてから&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えれば速くなると思ってます。&lt;br /&gt;
　ということで、とりあえず&lt;a href=&quot;https://happyclam.booth.pm/items/6346070&quot;&gt;７七将棋アプリ&lt;/a&gt;は試しに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;配列バージョン&lt;/code&gt;に置き換えましたが、他の将棋関連アプリやチェス関連アプリは当面&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;駒リストバージョン&lt;/code&gt;のままにしておくつもりです。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 12 Oct 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-10-12/ListOrArray</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-10-12/ListOrArray</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>c++</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>C++よりJSの方が速い！？</title>
        <description>&lt;h3 id=&quot;期待が高過ぎたみたい&quot;&gt;期待が高過ぎたみたい&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2025-08-07/OOP&quot;&gt;前回の記事&lt;/a&gt;で&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;３三将棋アプリ&lt;/code&gt;&lt;/a&gt;のソースを元に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えた話を書きましたが、なんと出来上がった&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++製&lt;/code&gt;のプログラムは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript(JavaScript)製&lt;/code&gt;のものより遅い結果となりました。当ブログで度々「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にすればもっと深く読めるのに〜」なんて書いてきましたが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に対する期待が高過ぎたようです。たとえ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にとって不利なデータ構造であっても、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にはそんなものでは超えられないほどの実行速度の優位性があると信じていたのですが、認識が間違っていたようです。&lt;br /&gt;
　実行速度を比較する際は、実際に作ってみないと正確には分からないという点が辛いところですが、今回は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok4&lt;/code&gt;にほぼ丸投げで試すことが出来たので、その点は助かりました。&lt;/p&gt;

&lt;h3 id=&quot;c版がどれぐらい遅いのか&quot;&gt;C++版がどれぐらい遅いのか&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;CoffeeScriptの３三将棋アプリのレポジトリ&lt;/a&gt;と&lt;a href=&quot;https://github.com/happyclam/shogi33.git&quot;&gt;C++版のリポジトリ&lt;/a&gt;の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;README.mdファイル&lt;/code&gt;に、先手・後手双方をAI同士で対戦させた実行例を記載していますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1781ミリ秒&lt;/code&gt;で終了する対局が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;では倍以上の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4434ミリ秒&lt;/code&gt;掛かっています。興味のある方は開発環境を用意すれば再現できます。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;が提案するコンパイルオプションもいろいろ試しましたが、ほとんど効果はありませんでした。&lt;/p&gt;

&lt;h3 id=&quot;chatgptgpt-5によるアドバイス&quot;&gt;ChatGPT(GPT-5)によるアドバイス&lt;/h3&gt;
&lt;p&gt;　以下の質問から始めて、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;にいろいろアドバイスを求めました。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;同じアルゴリズムとデータ構造で作ったJavascriptとC++のゲームプログラムがあって、Javascript製の方が実行速度が速いとき、どのような原因が考えられますか？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　会話の中で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;に言われたことをいくつか箇条書きにしてみます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;「同じアルゴリズム・データ構造で作ったゲームプログラムで、C++よりJavaScriptの方が速い」というのは直感に反しますが、実際に起こり得ます。&lt;/li&gt;
  &lt;li&gt;なるほど！Piece という抽象クラスがあって、それを継承した Pawn, Rook, Bishop … みたいな形で設計されているわけですね。これはオブジェクト指向的にきれいなんですが、将棋AIの「思考部分（探索＋評価）」ではかなり不利です。&lt;/li&gt;
  &lt;li&gt;なるほど…😅将棋AIをオブジェクト指向で作っている場合、&lt;strong&gt;「設計としてはきれい」だけど「パフォーマンス的には厳しい」&lt;/strong&gt;という典型的な状況にハマっていますね。&lt;/li&gt;
  &lt;li&gt;今の実装は「オブジェクト指向的にはきれい」だけど、性能的には JS エンジンの hidden class 最適化に負けているのが原因です。抽象クラスを廃止して struct+enum にするだけで、C++ の方が確実に速くなるはずです。&lt;/li&gt;
  &lt;li&gt;ここが C++ 版が JS に負けている一番の原因候補です。JS のオブジェクトは 実際には JIT によって連続配列のように最適化されます。一方 C++ の「駒ごとのオブジェクト集合＋ポインタ参照」はメモリがバラバラに配置される、毎回ポインタを間接参照する、キャッシュミスが頻発するので「CPU が待ち時間ばかり」で全然速くならない、という現象が起こります。&lt;br /&gt;
　実際、将棋エンジンやチェスエンジンは &lt;strong&gt;必ず「盤面を配列で表現」&lt;/strong&gt;しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　巷に出回っている将棋ソフトの真似ではなく自分で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;オプジェクト志向&lt;/code&gt;で作ってみたいと思って作り始めた（元々は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;で作ってました）ので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;に指摘された内容はある程度認識していましたが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;のようなコンバイラ言語なら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript(JavaScript)&lt;/code&gt;より遅くなることはないだろう、なんて勝手に思っていました。それに&lt;strong&gt;JS エンジンの hidden class 最適化&lt;/strong&gt;なんてことは、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;に指摘されるまで知りませんでした。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;って自分が思っていたより元々速いんですね。&lt;br /&gt;
　そう言えば同じアルゴリズムとデータ構造で昔作った&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;製の将棋ソフトより&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;の方が断然速いなぁとは感じてました。&lt;/p&gt;

&lt;h3 id=&quot;小さなリファクタリング&quot;&gt;小さなリファクタリング&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;に、大きなリファクタリングが大変なら以下のような高速化案がありますと言われました。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;vtableを極力通さない&lt;br /&gt;
もし 駒種はコンストラクタで固定なら、Piece に「enum型のメンバー」を持たせておけば仮想関数を呼ばずに済みます。→ piece-&amp;gt;type に直接アクセスできれば、仮想関数呼び出しを消せる。&lt;/li&gt;
  &lt;li&gt;駒オブジェクトをヒープでなく配列に置く&lt;br /&gt;
new してポインタ管理するのではなく、最初にstatic Piece allPieces[MAX_PIECES];を作って Board はポインタではなく インデックス（int）で参照する。&lt;br /&gt;
これなら 全駒が連続配置されるのでキャッシュ効率が改善します。&lt;/li&gt;
  &lt;li&gt;評価関数の高速化&lt;br /&gt;
もし各駒に evaluate() があるなら呼ばずに、
switch(piece-&amp;gt;type)
あるいは pieceSquareTable の配列参照に置き換えるだけでもだいぶ速くなるはず。&lt;/li&gt;
  &lt;li&gt;コンパイルオプションで粘る&lt;br /&gt;
既に -O2 をお使いですが、&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ -O3 -march=native -flto=8 -funroll-loops -DNDEBUG&lt;/code&gt;&lt;br /&gt;
を試すと、関数インライン化やループ展開が強化されて多少マシになります。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　簡単に試せそうなのでソース全体を通して1.の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT(GPT-5)&lt;/code&gt;からのアドバイスを実装してみました（koma-&amp;gt;getKind()で駒種を取得していた処理をやめて、publicなenum型のconstメンバ変数を追加してkoma-&amp;gt;typeで駒種を判定）が、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4434ミリ秒&lt;/code&gt;掛かっていた処理が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;400m秒&lt;/code&gt;程短縮出来ただけで全然&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript(JavaScript)&lt;/code&gt;には敵いません。&lt;br /&gt;
　ということで、今の&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;将棋・チェス関連アプリ&lt;/a&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JS&lt;/code&gt;のまま置いておくのが一番良いのかなと思っていて、改善するにしても今の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のまま改善していく方向で考えています。&lt;/p&gt;

&lt;h3 id=&quot;それでもoopが好き&quot;&gt;それでもOOPが好き&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP（オブジェクト指向プログラミング）&lt;/code&gt;を絶対視する気はありませんが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP言語&lt;/code&gt;を使う限りは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;すべきなんじゃない？なんて思ってましたが、実効性を重視するなら拘らないほうがいいのかもしれません。昔、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rails&lt;/code&gt;のプロジェクトでありながら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORM（O/Rマッパー）&lt;/code&gt;を使わずに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL文&lt;/code&gt;を書いているなんてプロジェクトの話を聞いたことがありますし、もしかして&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Go言語&lt;/code&gt;や&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt;など&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;非OOP言語&lt;/code&gt;が勢力を伸ばして来ているのは、よく知りませんが、実行速度を上げること（PCが処理しやすい）を重視する流れなのかもしれません。&lt;strong&gt;今後プログラムは人間が書くものではなくAIが書くもの？&lt;/strong&gt;という流れの一貫で、人間側に寄せるのか？プログラムを実行するコンピュータ側に寄せるのか？という話なのかもしれません。&lt;br /&gt;
　でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rails&lt;/code&gt;が出てきた頃に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORM&lt;/code&gt;に感動した自分としては、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rails&lt;/code&gt;を使いながら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL文&lt;/code&gt;を書くなんていう本末転倒なプロジェクトには参加したくありませんし、今後も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;で作りたいと思ってます。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「OOPとは何か？」&lt;/code&gt;なんて話をすると主語が大きくなりすぎて自分には語れませんが、直感的に人間が理解しやすいと思うんですよねぇ。今回のケースも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;が悪いということではなく、まだまだ改善の余地があると思ってます。というか、取り敢えず機能を実現することを優先していて、高速化に関しては深く考えていませんでした。後は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にすれば自然と速くなるだろう、なんて考えながらも手を付けられずに長い間放置していた感じです。&lt;br /&gt;
　新規に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GUI&lt;/code&gt;から作ることを考えれば現状の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のリファクタリング＆高速化に着手するほうが楽ですし、どれ程の結果が出るか未知数ですがいつくかアイデアもあるので試してみたいと思ってます。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sat, 23 Aug 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-08-23/JSvsCPlus</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-08-23/JSvsCPlus</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>c++</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>３三将棋CUI版のC++バージョン</title>
        <description>&lt;h3 id=&quot;共通点はオブジェクト指向プログラミング言語&quot;&gt;共通点はオブジェクト指向プログラミング言語&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2025-06-07/kotlins_recursion&quot;&gt;前回の記事&lt;/a&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;製のウォーターソートパズル解答プログラムを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok4&lt;/code&gt;を使って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;や&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えましたが、極短時間で移行出来たのは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;オブジェクト指向プログラミング（OOP）言語&lt;/code&gt;だったということも一つの要因だと思います。&lt;br /&gt;
　現在公開している&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;「３三将棋の簡易版」&lt;/code&gt;&lt;/a&gt;も一応&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP言語&lt;/code&gt;である&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;で書いているので、移行しやすいだろうと思いやってみました。もし元のコードが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;素のJavascript（Vanilla JS）&lt;/code&gt;だったら大変だったろうと思います。&lt;/p&gt;

&lt;h3 id=&quot;coffeescriptはoopオブジェクト指向プログラミング言語&quot;&gt;CoffeeScriptはOOP（オブジェクト指向プログラミング）言語&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;もどんどん変化していて現在はそうでもありませんが、私は昔は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;が嫌いでした。でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cordova&lt;/code&gt;を使って手軽に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Androidアプリ&lt;/code&gt;を作成するために必要だったので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AltJS&lt;/code&gt;である&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;なら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;出来ると喜んで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;の替わりに使ったのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;を意識しながら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;を使っていた人は少ないと思います。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rails&lt;/code&gt;のプロジェクト内でちょっとした関数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;で作ってみるぐらいが普通の使われ方だったと思います。&lt;br /&gt;
　でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;は一応&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP言語&lt;/code&gt;で、static変数・メソッドとインスタンス変数・メソッド、publicな変数・メソッドとprivateな変数・メソッドを区別して記述することが出来ますし、クラスの継承も可能です。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AltJS&lt;/code&gt;なので結局は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;の制限に縛られるので、スコープの有効性等がどれだけ厳密に守られてるのかは知らないのですが気分は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;のままコードが書けます。&lt;br /&gt;
　ということで、公開している&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript製&lt;/code&gt;の&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋の簡易版」リポジトリ&lt;/a&gt;を元に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えればいいのですが、&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;このリポジトリ&lt;/a&gt;は全然更新していないので内部で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval関数&lt;/code&gt;を使っていたり古いコードになっているため今回は無視して、&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋アプリ&lt;/a&gt;の最新版のソースを元に書き換えました。なので&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋の簡易版」リポジトリ&lt;/a&gt;のコードと比較すると少し内容に違いがあることを先にことわっておきます。でも、やってることは同じで出力結果は同じになる&lt;strong&gt;はず&lt;/strong&gt;ですし、&lt;a href=&quot;/project/2018-06-30/9masushogi_solver&quot;&gt;「CUIで９マス将棋を解く」&lt;/a&gt;の記事に書かれている内容もほぼ当て嵌まります。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;span&gt;３三将棋CUI版のC++バージョンのソースコード&lt;/span&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/shogi33.git&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;３三将棋簡易版のC++バージョン&quot; title=&quot;３三将棋簡易版のC++バージョン&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;コーディング力では生成aiにはかなわない&quot;&gt;コーディング力では生成AIにはかなわない&lt;/h3&gt;
&lt;p&gt;　過去にも将棋関連アプリの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のソースを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に移行してみようと思ったことはあったのですが、一つのソースで３三将棋から７七将棋まで遊べるようにしようとしたり、将棋AI部分を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;で作ってもAndroid用GUIが作れない（不可能ではないでしょうが難易度高過ぎ）所為もあって、モチベーションが上がらずやりかけては中断することを繰り返してました。それに、例えば「抽象クラスをインスタンス化したくなったときはどうすべきなんだろう（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;では出来てしまう）」とか&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP&lt;/code&gt;に関するに言語仕様の違いについて迷うことが出てきて手が止まることも多かったです。そういう時に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok4&lt;/code&gt;は複数の選択肢を挙げてくれましたしコード化してくれました。&lt;a href=&quot;/software/2025-06-07/kotlins_recursion&quot;&gt;前回の記事&lt;/a&gt;でも、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt;で配列の比較をしている部分を、演算子のオーバーロードが使えない&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;ではequalsメソッドを追加・修正して実現しましたし、何も言わなくても&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;演算子のオーバーロード&lt;/code&gt;で実現してくれました。こうあるべきという綺麗なコードを一瞬で出力してくれました。&lt;br /&gt;
　自分の場合、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;なら自分が思いついたアイデアをすぐにコードにして試せるので好きなのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;で書くとなると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;自分の中では要件が明確なのにも関わらず&lt;/code&gt;コードにするとなると時間がかかってしまいます。でも、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;を使いながらもアイデアをすぐにコード化出来るという&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++の達人&lt;/code&gt;もいるでしょうから、プログラミング言語の違いは大きな問題ではないでしょう。どういう書式で書くのか、どういう型を使うのか、どういう関数を使うのか、OOP的にはどう書くべきかというプログラミングのテクニカルな部分、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;コーディング力&lt;/code&gt;とでもいうのでしょうか？に関しては&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;には敵わないなと感じました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;は世界中のソースコードから学習しているわけですから、少し寂しい気持ちもありますが、そうなるのは仕方がないことでしょう。前向きに捉えて&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;を使っていくのがいいと思います。&lt;br /&gt;
　現に今まで中途半端にしか進められなかった&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;への移行が、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;を使うことで極短時間で出来たわけですから喜ぶべきでしょう。今回もほとんどデバッグ作業は必要なかったです。&lt;br /&gt;
　但し、今回は試しにやってみたという感じなので、３三将棋から７七将棋まで対応可能なソースの一本化はとりあえず見送りました。&lt;/p&gt;

&lt;h3 id=&quot;大事なのはアルゴリズムを生み出す発想力&quot;&gt;大事なのはアルゴリズムを生み出す発想力&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;アルゴリズムを生み出す&lt;/code&gt;と言っても新しい汎用的なソートアルゴリズムを発見するとかいう大袈裟なものではなく、データ構造を含めたアルゴリズムを生み出す作業とは、世のプログラマが普通にやってることです。業務ソフトでもユーザーの要望を聞いてこういう関数を作ってみよう、こういうクラス構成にしてみよう、こういう手順で実行させようとアイデアを出して日々やっている（押し付けられている？:sweat_smile:）作業です。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;コンピュータが要件を満たせるレベルまで細分化して明確にしていく作業&lt;/code&gt;と言えばいいかもしれません。多くのユーザーは、人間がやっていることをコンピュータにやらせるレベルまでには要件を明確に出来ていませんので、プログラマが業務ソフト毎にデータ構造を含めた新しいアルゴリズムを日々生み出してます。&lt;br /&gt;
　当ブログで紹介してきたプログラミング事例でも、特に苦労せず実現できたものやネット上からのコピペも多いですが、以下のアルゴリズムは実現までに結構悩まされてなんとか生み出した、アイデアを絞り出したという感じです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将棋アプリの打ち歩詰め判定 -&amp;gt; &lt;a href=&quot;/software/2018-06-10/droppawncheck&quot;&gt;「打ち歩詰め判定は必要なのか」&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;チェスアプリのゲーム終了条件 -&amp;gt; &lt;a href=&quot;/software/2019-10-27/stalemate&quot;&gt;「将棋の評価関数とチェスの評価関数−１」&lt;/a&gt;、&lt;a href=&quot;/software/2024-04-07/tdd&quot;&gt;「チェスAIとテスト駆動開発」&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;チェスアプリのPIN絡みのステイルメイト判定 -&amp;gt; &lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;「チェスのStalemateとPINの話」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　その人間が生み出したアルゴリズムもどんどん生成AIの餌になっていくわけですから、いずれはすべてAIがやるようになるのかもしれません。それに人間側が、AIが処理しやすいように業務内容を変えていく動きもありますね。&lt;/p&gt;

&lt;h3 id=&quot;生成aiはコーディングスキルだけなのか&quot;&gt;生成AIはコーディングスキルだけなのか？&lt;/h3&gt;
&lt;p&gt;　今回の記事も、元になる&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のソースコードから&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に移行しただけで、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;を使って０からアプリを作った経験はないので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;アルゴリズムを生み出す&lt;/code&gt;という点でどこまで役に立つのか分からないのですが、そういう部分ではまだまだ人間の方に分があるのではないでしょうか？&lt;br /&gt;
　機会があれば生成AIを使って０から何か作ってみたいと思ってます。&lt;/p&gt;

&lt;h3 id=&quot;３三将棋の簡易版リポジトリ更新しました2025-08-16追記&quot;&gt;&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋の簡易版」リポジトリ&lt;/a&gt;更新しました（2025-08-16追記）&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋の簡易版」リポジトリ&lt;/a&gt;を&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋アプリ&lt;/a&gt;の最新版のソースに更新しました。これでリポジトリ名は変えてませんが、「簡易版」ではなく、&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋アプリ&lt;/a&gt;のソースファイル一式になります。&lt;br /&gt;
　これで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok4&lt;/code&gt;を使って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に移行する際に、極一部の処理（候補手のソート等）に変更を加えましたが、ほぼ丸々一式&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;「３三将棋アプリ」リポジトリ&lt;/a&gt;を元にして&lt;a href=&quot;https://github.com/happyclam/shogi33.git&quot;&gt;「３三将棋のC++バージョン」&lt;/a&gt;を作成した形になります。&lt;br /&gt;
　ところが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Player.think&lt;/code&gt;メソッド（全件探索、全幅探索）は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript版&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++版&lt;/code&gt;も同様に動いています（&lt;strong&gt;但し、実行速度が速くなってない！&lt;/strong&gt;）が、肝心の候補手を絞って深く読む&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Player.prepare&lt;/code&gt;メソッドが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript版&lt;/code&gt;では問題なく動いているのに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++版&lt;/code&gt;ではうまく動いていない状況です。これに関しては別記事に書こうと思ってます。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Thu, 07 Aug 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-08-07/OOP</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-08-07/OOP</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>c++</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>Kotlinで再帰関数（AIに丸投げ）</title>
        <description>&lt;h3 id=&quot;ウォーターソートパズルを題材に&quot;&gt;ウォーターソートパズルを題材に&lt;/h3&gt;
&lt;p&gt;　もう６年以上前の話ですが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;が流行り始めた当時、将棋関連アプリ（&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋&lt;/a&gt;、&lt;a href=&quot;https://happyclam.booth.pm/items/6325376&quot;&gt;５五将棋&lt;/a&gt;、&lt;a href=&quot;https://happyclam.booth.pm/items/6346070&quot;&gt;７七将棋&lt;/a&gt;）のAI部分の高速化を考えていた私は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript(Javascript)&lt;/code&gt;のソースコードを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に書き換えてみたことがあります。でも文法だけ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に書き換えてもわずか&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;３手読み&lt;/code&gt;ですぐにスタックオーバーフローが発生して、末尾再帰の形になるようにソースコードを書き換えなければならないことが分かって挫折しました。&lt;br /&gt;
　でも、&lt;a href=&quot;/software/2025-04-27/waterbottle&quot;&gt;前回の記事&lt;/a&gt;で作った&lt;a href=&quot;https://github.com/happyclam/water_sort_puzzle&quot;&gt;プログラム&lt;/a&gt;なら、将棋関連アプリに較べればかなり単純な構造の再帰関数なので、これなら出来るんじゃないか？と興味が湧いて、これを題材にして末尾再帰に書き換える作業を体験することにしました。&lt;/p&gt;

&lt;p&gt;※&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;製の５五将棋プログラムは今でもソースが残ってますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Null Safety&lt;/code&gt;なんて全く気にしていない&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoffeeScript&lt;/code&gt;のソースコードをそのまま&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に移行して、とにかくコンパイルを通すために&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nullable&lt;/code&gt;な変数を無理やり&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-null&lt;/code&gt;に強制的に変換する演算子&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!!&lt;/code&gt;（ビックリマーク２つ）だらけの、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin使い&lt;/code&gt;に言わせれば汚いコードでした。&lt;/p&gt;

&lt;h3 id=&quot;grokに聞いてみる&quot;&gt;Grokに聞いてみる&lt;/h3&gt;
&lt;p&gt;　プログラミングの際に本やGoogle検索を使うよりもリファレンスとして&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;は有用だなと思っていたので、まずは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に慣れていない私は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のソースコードを貼り付けて「このコードをKotlinに書き換えて！」と丸投げしてみました。コンパイルエラーが出ても実行時エラーが出ても「エラー出てるよ！」と返して、修正されたコードをまたコピペして実行するだけでこちらはあくまでも受け身の姿勢です。&lt;br /&gt;
　そしてエラーは無くなったけど期待した結果が返ってこない状態になって、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;配列A == 配列B&lt;/code&gt;の比較をしている部分は「Kotlinでは無理だろうな」と当たりをつけて&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;equalsメソッド&lt;/code&gt;を改変したら（ここも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に丸投げ）すぐに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;は完成しました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;が吐き出すコードを碌に確認もせずデバッグ作業も全くしてません。そして肝心のNodeクラス内の再帰関数メソッドに較べて再帰がやや複雑になっている&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;も「dfs関数も末尾再帰に書き換えて！」と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に丸投げしただけで完成しました:astonished:&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;div align=&quot;center&quot;&gt;ソースコード&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/water_sort_kotlin&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;ウォーターソートパズル解答プログラム（Kotlin版）&quot; title=&quot;ウォーターソートパズル解答プログラム（Kotlin版）&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;　「どうせどこかでトラブってデバッグ作業させられるんだろうなぁ」と期待せずにダラダラと始めた作業なのですが、正味の作業時間は１時間もかかっていません。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;とのやり取りも数回だけです、公開するのは少し恥ずかしいですが、&lt;a href=&quot;https://x.com/i/grok/share/MA2ogBDeGSppQ2poNu8tRDmom&quot;&gt;Grokとのやり取り&lt;/a&gt;の一部始終を公開しますので興味ある方は確認してみてください。&lt;/p&gt;

&lt;h3 id=&quot;生成aiの実力を認めざるを得ない&quot;&gt;生成AIの実力を認めざるを得ない&lt;/h3&gt;
&lt;p&gt;　この記事は「自作の再帰関数を末尾再帰に書き換えるためにはこんな作業が必要でした」という内容になる予定だったのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に丸投げするだけで済んでしまったので書くことが無くなりました。もしそういう内容を期待してた方は&lt;a href=&quot;https://x.com/i/grok/share/MA2ogBDeGSppQ2poNu8tRDmom&quot;&gt;Grokの履歴&lt;/a&gt;を見てもらえば各再帰関数の変更前と変更後のソースも見れますし、解説もされているのでそちらを見ていただきたいと思います。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dfs関数&lt;/code&gt;の末尾再帰化された後のコードは自分自身もよく理解できていません。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;はプログラミング時のリファレンスには使えるぐらいの認識だったのですが、完全に自分が教えて貰ってる状態です。未だに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT&lt;/code&gt;もほとんど使ってないし&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Copilot&lt;/code&gt;もよく知りません（何を使っても中身は同じ？）が、積極的に使ったほうが開発効率は上がりそうですね。&lt;br /&gt;
　とは言っても今回のケースは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;の正解がある状態、アルゴリズムに問題が無いことが分かっている状態から始めたので、一から&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;でプログラミングしていたら例え&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;に手伝ってもらってもこんなに簡単には完成しなかったとは思います。しかし&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のような&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;軽量プログラミング言語（Lightweight Languages）&lt;/code&gt;でサクッとプロトタイプを作ってから&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;を使って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;のようなコンパイラ言語に置き換えるのも一つの使い方としてアリかもしれません。将棋関連アプリの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++（STL使用）&lt;/code&gt;への変換も試してみようと思ってます。&lt;/p&gt;

&lt;h3 id=&quot;ちょっと怪しい&quot;&gt;ちょっと怪しい…&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vscode&lt;/code&gt;上で実行していた時は気づかなかったのですが、コマンドラインでコンパイルすると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;warning&lt;/code&gt;が出てました&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kotlinc -include-runtime -d ./game.jar waterBottles
waterBottles/game.kt:72:21: warning: recursive call is not a tail call.
    val subResult = dfs(node, temp, depth - 1, 0, 0, false, newResult)
                    ^^^
waterBottles/node.kt:52:22: warning: recursive call is not a tail call.
        } else if (c.add(nd, target, 0)) {
                     ^^^
waterBottles/node.kt:77:22: warning: recursive call is not a tail call.
        } else if (c.replace(nd, target, 0)) {
                     ^^^^^^^
waterBottles/node.kt:94:22: warning: recursive call is not a tail call.
        } else if (c.search(target, 0)) {
                     ^^^^^^
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　コンパイラは「末尾再帰になってませんよ」と言ってます&lt;br /&gt;
どうやら末尾再帰化が中途半端になっているようですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dfs関数&lt;/code&gt;に関しては&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;による末尾再帰化を施さないと期待通り動かなかったので、間違った変更を加えたわけではないようですし、内部の処理が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;とどのような違いがあるのかは分かりません。それより驚いたのは、完成した&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;のプログラムで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のプログラムと同じ問題を解かせてみると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;も&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin版&lt;/code&gt;の方が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby版&lt;/code&gt;よりもかなり遅かったことです&lt;/strong&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;に合わせて敢えて不要な部分で可変長の配列を使ってるところとか、確かに実行速度を上げることを目指したコードではないですが、まさか&lt;strong&gt;同じデータ構造とアルゴリズムで&lt;/strong&gt;インタプリタ言語の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;より大幅に実行速度が遅くなるとは思いませんでした。&lt;/p&gt;

&lt;h3 id=&quot;kotlinjavaって再帰関数が苦手なの&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin(Java)&lt;/code&gt;って再帰関数が苦手なの？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2025-04-27/waterbottle&quot;&gt;前回の記事&lt;/a&gt;の冒頭の問題を解かせて見たところ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.151秒&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5530.022秒（約１時間半！！）&lt;/code&gt;でした、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;では&lt;a href=&quot;/software/2025-04-27/waterbottle&quot;&gt;前回の記事&lt;/a&gt;でも書いた通り&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.016248494秒&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;279.599430481秒（約４分半）&lt;/code&gt;です。再帰関数ではないはずの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;の遅さが目立ちますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;でも内部では再帰関数であるNodeクラスの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addメソッド&lt;/code&gt;を頻繁に呼び出すので、念の為Node.addメソッドを末尾再帰ではない元々のコードに戻して試してみましたが実行時間に違いはありませんし、スタックオーバーフローも発生しません。末尾再帰化はスタックオーバーフローを避けるためのものなので、実行速度は変わらない（あるいは若干遅くなる）はずで、まぁこうなるところでしょう。それよりなにより&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;より遅いのならそもそも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に書き換える意味がありません。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt;は昔に較べて速くなってると聞いていたし、原因はいろいろあると思いますが、もしかして&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin(Java)&lt;/code&gt;は末尾再帰化されているかどうかに関わらす再帰関数を使うと遅くなるのでしょうか？とにかくモチベーションが一気に下がりました。&lt;br /&gt;
　結局、末尾再帰化は中途半端になりましたが、速度アップには繋がらないし、スタックオーバーフローが発生しているわけでもないのでここで止めておきます。昔、GOTO文も駆使しながらスタックの消費を抑えている&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C言語&lt;/code&gt;のソースを見たことがありますが、そこまでする必要はないでしょう、というかそこまでやる人に敬意を表しますが私には出来そうにないです。&lt;br /&gt;
　もう&lt;a href=&quot;https://github.com/happyclam/water_sort_kotlin&quot;&gt;このKotlin版&lt;/a&gt;の高速化に時間を掛けようとは思いませんが、その昔将棋関連アプリを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に書き換えることを早々に諦めたことは私にとって良かったのかもしれません。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;が存在しなかった当時、スタックオーバーフローを避けるために苦労して末尾再帰に書き換えても実行速度が遅くなったのではさぞ虚しかったことでしょう。&lt;/p&gt;

&lt;h3 id=&quot;やはり高速化ならc&quot;&gt;やはり高速化なら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;　将棋関連アプリの高速化のために将棋AI部分を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;で書き直したとしても、GUIを何で作るかという問題が残りますのでこれについては今後も模索中です。Kotlinで高速なものが作れれば、AndroidアプリのGUIもKotlinで作れるのでよかったのですが、残念です。&lt;br /&gt;
　現在販売中の&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋アプリ&lt;/a&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;評価値でソートして候補手を絞る関数&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;局面を先読みする関数&lt;/code&gt;の２つの関数を再帰呼出ししている面白い処理（&lt;a href=&quot;/software/2019-02-26/iterativedeeping&quot;&gt;「反復深化？を工夫してより深く読む」&lt;/a&gt;参照）をしているので、GUI付きのアプリとして販売するかどうかに関わらず一度&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;で実装してみたいとは思っています。&lt;/p&gt;

&lt;h3 id=&quot;生成aiはアルゴリズムを勝手に変更する2025-06-08追記&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生成AI&lt;/code&gt;はアルゴリズムを勝手に変更する？（2025-06-08追記）&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;に書き換えたら速くなることを確認するため一応&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;でも上記の方法で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;を使ってやってみました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;div align=&quot;center&quot;&gt;ソースコード&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/water_sort_cPlus&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;ウォーターソートパズル解答プログラム（C++版）&quot; title=&quot;ウォーターソートパズル解答プログラム（C++版）&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;/software/2025-04-27/waterbottle&quot;&gt;前回の記事&lt;/a&gt;の冒頭の問題を解かせて見たところ&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.00225114秒&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11.9202秒！！&lt;/code&gt;でした。流石に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;は速いです。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;から&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;に移植した時と違い、何回かデバッグ作業を強いられました。それに、「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のコードを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;にして！」と依頼しているのに、AIが勝手に判断して変更するケースもあるようです。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;のコードでは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.makeHash&lt;/code&gt;メソッド内で局面を文字列化するときに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MD5&lt;/code&gt;のハッシュ値を使用しているのですが、私はボトルの数が増えると局面を表現するための文字列がどんどん長くなっていくのでそれを防ぐ意味でハッシュ値を使用していたのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;はそういう私の意図などお構いなしに勝手にハッシュ化のためのコードを削除しました:sweat_smile:&lt;br /&gt;
　まぁそれは良いとしても、アルゴリズムに影響を与える勝手な変更も一部あって、その所為で一時は問題を解くのに時間がかかる結果になってしまいました。その時はボトルの水を移動する回数（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cnt変数&lt;/code&gt;でカウント）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ruby&lt;/code&gt;と較べて異常に増えていたのですぐにおかしいと気付いたのですが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin版&lt;/code&gt;に関してはそういう明確な出力の違いがないので&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin版&lt;/code&gt;が遅い原因は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin(Java)&lt;/code&gt;自体にあるとみてます。&lt;br /&gt;
　将棋でも一度&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI&lt;/code&gt;のアドバイスを貰うと「その次の手はどう指すの？」、「その次は？」と際限なく聞きたくなってきて、自分の頭で考えなくなってしまいますので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI&lt;/code&gt;の使い方には気をつけないとダメですね。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sat, 07 Jun 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-06-07/kotlins_recursion</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-06-07/kotlins_recursion</guid>
        
        <category>ruby</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>kotlin</category>
        
        <category>c++</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>ウォーターソートパズルの答えが知りたい</title>
        <description>&lt;h3 id=&quot;暇潰しに丁度いい&quot;&gt;暇潰しに丁度いい&lt;/h3&gt;
&lt;p&gt;　スマホ弄っていたら広告を見かける人も多いと思いますが、最近ボトルに色分けされた水が入っていてそのボトル内の水を同一色に並べ替えるゲームに嵌っています。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ウォータソートパズル&lt;/code&gt;とか&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;水選別パズル&lt;/code&gt;とか呼ばれてるようで、大抵の問題は何回かやり直せば正解にたどり着けるのですが、どうしても解けないパターンに出会って、「そもそもこれに解答は存在するのか？」という疑問を持ったのでプログラムを作って確認することにしました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;どうしても解けなかったパターン
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;/images/watersort00.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/watersort00.png&quot; alt=&quot;解けない？パターン&quot; width=&quot;200&quot; height=&quot;200&quot; title=&quot;解けない？問題&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;とりあえずgrokに聞いてみる&quot;&gt;とりあえずGrokに聞いてみる&lt;/h3&gt;
&lt;p&gt;　最近プログラミングに関する技術的な調べものをする際に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grok&lt;/code&gt;を何度か使ってみて、Googleで調べるより効率的かもと思っていたので試してみました。&lt;br /&gt;
　上記の画像ファイルをアップロードしてGrokに「このウォータソートパズルの解答手順を教えてください」と聞いてみたところ&lt;br /&gt;
「ボトルは１２本ですね」とか言いながら解答手順を即答しましたが、&lt;br /&gt;
画像の認識が間違っているので「よく見てください、ボトルは１３本です」と送ると&lt;br /&gt;
「申し訳ありません、画像をよく確認したところ、ボトルは12本ではなく13本ですね」とかいいながら、また間違った問題のまま解答手順を列挙してきました。&lt;br /&gt;
更に「ボトルは上段に７本、下段に６本です。下段の右側に空のボトルが２本有ります」と訂正すると&lt;br /&gt;
「ご指摘ありがとうございます」とかいいながら、またまた間違った問題のまま解答手順を列挙してきました。&lt;br /&gt;
こんな感じでやり取りが延々続いて解答は得られませんでした。問題の画像を正確に認識するのが難しいみたいです。それにしても解答の速さに驚いたのですが、画像の認識さえ正確に出来れば解答手順も正確に答えられるのでしょうか？
以下のテキストを貼り付けて再度Grokに聞いてみました。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      [RED, SKY_BLUE, RED, YELLOW],
      [MAGENTA, PINK, AQUA_GREEN, RED],
      [AQUA_GREEN, YELLOW_GREEN, PURPLE, BLUE],
      [SKY_BLUE, MAGENTA, ORANGE, YELLOW],
      [PURPLE, PINK, ORANGE, YELLOW_GREEN],
      [PURPLE, BLUE, PINK, AQUA_GREEN],
      [ORANGE, YELLOW, AQUA_GREEN, PURPLE],
      [SKY_BLUE, BLUE, GRAY, GRAY],
      [SKY_BLUE, YELLOW_GREEN, MAGENTA, RED],
      [YELLOW, MAGENTA, ORANGE, GRAY],
      [YELLOW_GREEN, GRAY, PINK, BLUE],
      [],
      []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　すると今度は「提供された色のリストに基づき、ウォーターソートパズルの解答手順を日本語で説明します」と言いながら手順を示してきたのですが、ボトルの最上段に存在しない色を移動していたり、ルールを無視した手順を何回も示してきました。&lt;br /&gt;
根気よく訂正し続ければ解答できるのかもしれませんが、自分には無理そうに思えたので諦めました。&lt;/p&gt;

&lt;h3 id=&quot;自分で解答プログラムを作る&quot;&gt;自分で解答プログラムを作る&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2018-08-18/puzzle&quot;&gt;以前の記事&lt;/a&gt;で紹介した&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;将棋パズル解答プログラム&lt;/code&gt;とほぼ同じコードで解決できそうなのでやってみました。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS（幅優先探索）&lt;/code&gt;を使って一手ずつ局面を進めてすべてのボトルの色が一色に揃う解答画面に辿り着いた時点で探索を終了し、その手順を遡って表示します。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS&lt;/code&gt;では解答までの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最短手順&lt;/code&gt;を表示しますが、実行時間がかなりかかります。PCのスペックにもよりますし、問題によってもかなり解答までの時間が大きく変化するのですが、ボトル５本（内、空ボトル２本）なら１秒も掛かりませんけど、ボトル９本（内、空ボトル２本）だと&lt;del&gt;３〜４時間掛かりました。&lt;/del&gt;冒頭で紹介しているボトル１３本（内、空ボトル２本）では&lt;del&gt;数日掛かるのでしょうか？&lt;/del&gt;実際に作ってみる前の想像以上に時間が掛かるのは&lt;a href=&quot;/software/2020-06-07/mancala&quot;&gt;マンカラの時&lt;/a&gt;と同じですね。&lt;/p&gt;

&lt;h3 id=&quot;dfs深さ優先探索版も作ってみる&quot;&gt;DFS（深さ優先探索）版も作ってみる&lt;/h3&gt;
&lt;p&gt;　解答を得るのにあまりにも時間がかかりそうなので&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;も作ってみました。すると&lt;del&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;だと数日掛かると思われた上記の問題が&lt;/del&gt;１秒掛からずに解答を得ることが出来ました:sweat_smile:&lt;br /&gt;
　但し&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で得られた解答手順は最短手順とは限りません。でも、そもそも&lt;strong&gt;解答が存在するのかどうかを知りたい&lt;/strong&gt;というのが目的だったので満足です。上記の問題も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で出力された解答手順通りにやればアプリ上で実際に解けました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;div align=&quot;center&quot;&gt;ソースコード&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/happyclam/water_sort_puzzle&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/github-mark.png&quot; alt=&quot;ウォーターソートパズル解答プログラム&quot; title=&quot;ウォーターソートパズル解答プログラム&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;解けない問題はあるのか&quot;&gt;解けない問題はあるのか？&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;で問題を解くためにあまりに時間が掛かるので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;を作ってみるまでは「この問題には解が存在しない」と言い切るための条件はなんだろう？とか「解が存在することを証明するにはどうすればいいのか？」なんて難しく考えていたのですが時間の無駄でした。解けるかどうか判断するには「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS&lt;/code&gt;アルゴリズムで作られた解答プログラムで確認すればいいだけ」ですね、スタックオーバーフローに見舞われない限りは…。&lt;br /&gt;
　逆に空ボトル２本で解けない問題を作る方が難しいのかもしれません。ちなみに空ボトルを１本にすれば解けない問題はすぐに出来上がりますが、&lt;strong&gt;解は存在するけど解くのが難しい問題&lt;/strong&gt;というのを意図的に作るのは難しいと思います。&lt;a href=&quot;/software/2018-08-18/puzzle&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;将棋パズル&lt;/code&gt;の記事&lt;/a&gt;や&lt;a href=&quot;/project/2018-01-01/33shogiapp&quot;&gt;３三将棋アプリの記事&lt;/a&gt;でも書きましたが、&lt;strong&gt;問題を解くよりも、難しい問題を作る方が難しい&lt;/strong&gt;というのはウォーターソートパズルに関しても言えそうです。&lt;br /&gt;
　あと「ボトルの数がどれぐらい増えれば空ボトルが最低３本必要になるのか？」とか「空ボトル２本で解けるのは全体のボトル数が何本が限界？」とかの問題を考えるのも面白いかもしれませんが、ボトル１本あたりの色の数とかも考慮し出すとキリが無いので何か汎用的な法則を見つけ出すのは大変でしょうね。&lt;/p&gt;

&lt;h3 id=&quot;ヒント機能はどうなってるのか&quot;&gt;ヒント機能はどうなってるのか？&lt;/h3&gt;
&lt;p&gt;　アプリの中にはヒント機能が実装されているものも有ります。ヒント機能があるということはアプリが解答も知っているということなので、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;を作ってみるまでは予め用意した問題だけを出題してるのだろうか？と考えたりしましたが、そんなことはなく&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS&lt;/code&gt;ならランダムに問題を生成してその場でヒントが出せそうです。つまり、確認はしてませんが&lt;strong&gt;ヒント機能があるウォーターソートパズルアプリが出すヒントは最短手順のヒントではない&lt;/strong&gt;と思われます。&lt;/p&gt;

&lt;h3 id=&quot;プログラムの解説nodeクラスの役割&quot;&gt;プログラムの解説（Nodeクラスの役割）&lt;/h3&gt;
&lt;p&gt;　プログラムは水を入れる入れ物である&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bottleクラス&lt;/code&gt;、ボトルを収納する&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Boxクラス&lt;/code&gt;、開始局面を頂点とする&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ゲーム木&lt;/code&gt;を生成して格納する&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;の３つのクラスを使っていますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;について解説します。&lt;br /&gt;
　まず&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS&lt;/code&gt;の場合は、一手目の操作で現れ得る局面をすべて調べてから二手目の局面を調べるという順番なので&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ゲーム木&lt;/code&gt;を横方向に走査していく形になります。同じ手数の局面を横方向に全部調べてから次の手数の局面を全部調べるので、最終的に解答手順を表示する時に縦の手順に変えなければいけません。横方向に局面を蓄積（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addメソッド&lt;/code&gt;）していって、最終的に辿り着いた完成局面から、今度は開始局面までを縦方向に手順を再帰的に遡って辿り着くようにして表示しているのが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;の役割です。&lt;br /&gt;
　次に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS&lt;/code&gt;の場合は開始局面から指定された深さの末端ノードまで一気に読み進めて、末端ノードを調べ尽くしたら指し手を遡ってまた隣の経路を末端ノードまで読むという感じで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ゲーム木&lt;/code&gt;を縦方向に読み進めます。だから&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS&lt;/code&gt;のように&lt;strong&gt;局面を蓄積していく必要はなく&lt;/strong&gt;、毎回辿った履歴を上書き（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replaceメソッド&lt;/code&gt;）していけば最終的に辿り着いた完成局面までの履歴が残ります。今回作ったプログラムは先に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS&lt;/code&gt;のプログラムを作ったので&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;のようなものを使っていますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;だけ作ることを考えるのなら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodeクラス&lt;/code&gt;のようなもので再帰的に局面を辿るようにしなくても、外部変数の配列を一つ用意して局面が進む度に上書きしていけば開始局面から完成局面までの一本のルートが配列に残ります。昔、オセロのパズル（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;）を作った時はそんな感じで作りました。→&lt;a href=&quot;https://github.com/happyclam/othello&quot;&gt;github&lt;/a&gt;&lt;br /&gt;
　偉そうに解説していますが、実際そうなっているかどうか詳しく確認していませんし、バグってるかもしれません。自己責任でご利用ください。&lt;br /&gt;
　将棋もプログラミングも&lt;strong&gt;直感精読!!&lt;/strong&gt;、特に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;直感&lt;/code&gt;が大事だと思います。&lt;/p&gt;

&lt;h3 id=&quot;答えを知るために必要なプログラムの変更箇所&quot;&gt;答えを知るために必要なプログラムの変更箇所&lt;/h3&gt;
&lt;p&gt;　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;game_bfs.rb&lt;/code&gt;でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;game_dfs.rb&lt;/code&gt;でも、ボトルを格納するための&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Box&lt;/code&gt;オブジェクト生成部分を書き換えればいろんな問題に対応できます。色数を増やす場合は色の定義ファイル（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const.rb&lt;/code&gt;）と表示部分（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;box.rb&lt;/code&gt;）を修正する必要があります。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; box = Box.new(
   [
     Bottle.new([PINK, YELLOW_GREEN, GRAY, PINK]),
     Bottle.new([BLUE, YELLOW_GREEN, ORANGE, YELLOW]),
     Bottle.new([ORANGE, YELLOW, BLUE, PINK]),
     Bottle.new([RED, ORANGE, ORANGE, PINK]),
     Bottle.new([GRAY, YELLOW, BLUE, RED]),
     Bottle.new([YELLOW_GREEN, RED, BLUE, GRAY]),
     Bottle.new([YELLOW_GREEN, GRAY, RED, YELLOW]),
     Bottle.new,
     Bottle.new
   ]
  )

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;追記2025-05-06&quot;&gt;追記（2025-05-06）&lt;/h3&gt;
&lt;p&gt;　記事を公開した後にディスプレイが壊れた&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M1 Macbook Pro&lt;/code&gt;で記事冒頭に紹介した問題を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;で 解かせていたのですが、いつまで（数日）経ってもプログラムが終了しないのでおかしいと思ったらやはりバグってました:sweat_smile:&lt;br /&gt;
　バグと言うか同じ結果は得られるはずですが、同一局面の判定に無意味なことをしていて&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;のレスポンスが極端に悪くなっていました。&lt;a href=&quot;https://github.com/happyclam/water_sort_puzzle&quot;&gt;github&lt;/a&gt;のソースは修正済みですが、それでも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS版&lt;/code&gt;は時間が掛かって、記事冒頭の問題の最短手順の答えを得るまでに、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;279.599430481秒（約４分半）&lt;/code&gt;掛かり、最短手数は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;36手&lt;/code&gt;でした。同じPCで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;で解いてみると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.016248494秒&lt;/code&gt;で、手数は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;46手&lt;/code&gt;でした。&lt;br /&gt;
　今回の修正は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS版&lt;/code&gt;には影響ないはずです。&lt;br /&gt;
　やはり&lt;strong&gt;直感精読&lt;/strong&gt;の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;精読&lt;/code&gt;も大事ですね:sweat_smile:&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 27 Apr 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-04-27/waterbottle</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-04-27/waterbottle</guid>
        
        <category>ruby</category>
        
        <category>shogi</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>lichessに挑戦</title>
        <description>&lt;h3 id=&quot;チェスサイトのaiはすべてstockfish&quot;&gt;チェスサイトのAIはすべてStockfish？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/project/2019-11-16/chessapp&quot;&gt;以前の記事&lt;/a&gt;で&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;&lt;/a&gt;のAIと&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;との対戦成績を紹介したので、今度は&lt;a href=&quot;https://lichess.org/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lichess&lt;/code&gt;&lt;/a&gt;で試してみました。でも中で動いているAIは&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;&lt;/a&gt;も&lt;a href=&quot;https://lichess.org/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lichess&lt;/code&gt;&lt;/a&gt;も&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stockfish&lt;/code&gt;を使っているようで大きな違いは無いようです。対戦結果も&lt;a href=&quot;/project/2019-11-16/chessapp&quot;&gt;以前の記事&lt;/a&gt;と似たようなものだったので、同じAIが動いていると思われますが、自分の&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;が勝つ時はある特定のパターンがありそうです。そしてチェス対戦サイトのAI（&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://lichess.org/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lichess&lt;/code&gt;&lt;/a&gt;）の&lt;strong&gt;ある特徴&lt;/strong&gt;に気付きました…。&lt;/p&gt;

&lt;h3 id=&quot;チェスアプリが勝った対局&quot;&gt;&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;が勝った対局&lt;/h3&gt;
&lt;p&gt;　レベル４で１０戦して３勝７敗だったのですが、&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;が勝った３局をgifファイルで紹介します。gitファイルの下側が&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;です。テキストの棋譜は&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;に入力して再現することも可能です。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;序盤は大抵&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;側が劣勢になります。&lt;/p&gt;

    &lt;div align=&quot;center&quot;&gt;勝局１:劣勢から逆転&lt;/div&gt;
    &lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess01.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess01.gif&quot; alt=&quot;vs.lichess_level04_1&quot; width=&quot;320&quot; height=&quot;373&quot; title=&quot;vs.lichess_level04_1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess01.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess01.png&quot; alt=&quot;vs.lichess_level04_1&quot; width=&quot;480&quot; height=&quot;218&quot; title=&quot;vs.lichess_level04_1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1. e3 e6 2. Qg4 f5 3. Qf4 g5 4. Qf3 g4 5. Qf4 Bh6 6. Qe5 Nf6 7. h4 Nc6 8. Qb5 a6 9. Qc4 b5 10. Qc3 b4 11. Qc4 Bb7 12. a4 d5 13. Qb3 a5 14. Bb5 O-O 15. Bxc6 Bxc6 16. d4 Bg7 17. Nd2 Ra6 18. Qd3 Rb6 19. f3 Qe7 20. Ne2 h5 21. Kf2 Ne4+ 22. Kf1 Bd7 23. Ke1 Nd6 24. Ng3 Be8 25. Kf2 f4 26. exf4 Rf6 27. Nxh5 g3+ 28. Nxg3 Bg6 29. f5 Nxf5 30. Nde4 Nd6 31. Nxf6+ Kf7 32. Nge4 Qxf6 33. Nxf6 Bxd3 34. cxd3 Bxf6 35. Be3 Nf5 36. Rac1 c6 37. g4 Nxd4 38. g5 Bh8 39. g6+ Kxg6 40. Rhg1+ Kh5 41. Rg5+ Kh6 42. Rxd5+ Kh7 43. Rd7+ Kg8 44. Bxd4 Bxd4+ 45. Rxd4 c5 46. Rxc5 Kf7 47. Rf4+ Ke7 48. Rxa5 Kd7 49. Rg5 Kc7 50. Rg7+ Kd6 51. Rf8 Ra6 52. Rd8+ Kc6 53. Re8 Kd6 54. Rd8+ Kc5 55. Rg5+ e5 56. Rxe5+ Kc6 57. Re7 b3 58. Rd4 Kc5 59. Rde4 Rf6 60. R4e6 Rxe6 61. Rxe6 Kb4 62. Ra6 Kc5 63. f4 Kb4 64. h5 Kc5 65. f5 Kd5 66. Re6 Kc5 67. Re4 Kd6 68. Re1 Kc5 69. Re4 Kd6 70. Re6+ Kc7 71. d4 Kc8 72. Re3 Kc7 73. Rxb3 Kd8 74. Rc3 Ke7 75. b4 Kd8 76. a5 Ke7 77. b5 Kf6 78. Rf3 Kg5 79. d5 Kxh5 80. d6 Kg5 81. d7 Kf6 82. d8=Q+ Ke5 83. Qe7+ Kd4 84. a6 Kd5 85. Rg3 Kd4 86. Rg4+ Kd3 87. Qc7 Kd2 88. Rd4# 1-0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;なんと！６手（将棋で言うと１２手）でチェックメイト。lichessAIは一手詰めを読んでない？&lt;br /&gt;
　棋譜解析によると&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nf3&lt;/code&gt;が悪手で、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d4&lt;/code&gt;と着手すればlichessAI側が優勢のままだったようです。&lt;/p&gt;

    &lt;div align=&quot;center&quot;&gt;勝局２:６手でチェックメイト&lt;/div&gt;
    &lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess02.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess02.gif&quot; alt=&quot;vs.lichess_level04_2&quot; width=&quot;320&quot; height=&quot;373&quot; title=&quot;vs.lichess_level04_2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess02.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess02.png&quot; alt=&quot;vs.lichess_level04_2&quot; width=&quot;480&quot; height=&quot;218&quot; title=&quot;vs.lichess_level04_2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1. g4 d5 2. g5 e5 3. Bg2 Qxg5 4. Bxd5 Bc5 5. Nf3 Qg2 6. Rg1 Qxf2# 0-1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;の序盤は相変わらず定跡無視の乱戦、終盤は５手詰め以内の詰みならほぼ逃すことはありませんが、大優勢な局面であっても詰みがない局面だとも勝ち切るまでがもたつきます。評価関数の出来の悪さとしか言えません。&lt;/p&gt;

    &lt;div align=&quot;center&quot;&gt;勝局３:終盤はもたつく&lt;/div&gt;
    &lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess03.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess03.gif&quot; alt=&quot;vs.lichess_level04_3&quot; width=&quot;320&quot; height=&quot;373&quot; title=&quot;vs.lichess_level04_3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;/images/vs_lichess03.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_lichess03.png&quot; alt=&quot;vs.lichess_level04_3&quot; width=&quot;480&quot; height=&quot;218&quot; title=&quot;vs.lichess_level04_3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1. c4 e5 2. Nc3 Qh4 3. e3 a5 4. g3 Qg5 5. h4 Qf5 6. g4 Qf6 7. g5 Qf5 8. e4 Qe6 9. Nd5 Kd8 10. Bh3 Qc6 11. d4 Qxc4 12. Qh5 Bb4+ 13. Nxb4 axb4 14. g6 Qxd4 15. gxf7 Qxe4+ 16. Kf1 Ne7 17. Bg2 Qd3+ 18. Qe2 Qxe2+ 19. Nxe2 Rf8 20. a3 d5 21. Be3 Rxf7 22. Rh2 Bg4 23. Bc5 Nd7 24. Be3 Ra6 25. Bd2 Nc5 26. Bxb4 Nd3 27. Bxe7+ Kxe7 28. Nc1 Rxf2+ 29. Kg1 Nxc1 30. Kxf2 Nb3 31. Rg1 Rf6+ 32. Kg3 Be6 33. Rhh1 Rf4 34. Re1 Rg4+ 35. Kf2 e4 36. Rd1 b5 37. Bf1 Rf4+ 38. Kg2 Rg4+ 39. Kh2 Rxh4+ 40. Kg2 Rg4+ 41. Kf2 Rf4+ 42. Ke1 e3 43. Bg2 Nd4 44. Rc1 Nf3+ 45. Bxf3 Rxf3 46. Rg1 Rf4 47. Rxc7+ Kd6 48. Rcxg7 d4 49. Rxh7 d3 50. Rg6 Rc4 51. Kd1 Rf4 52. Ke1 Rc4 53. Rxe6+ Kxe6 54. Rh6+ Kd7 55. Rh7+ Kd6 56. Rh6+ Kc7 57. Kd1 Rf4 58. Ke1 Rg4 59. Rh7+ Kc6 60. Rh1 Rf4 61. Rh5 Rg4 62. Rh1 Rg2 63. a4 bxa4 64. b4 axb3 65. Rh6+ Kb7 66. Kf1 Rf2+ 67. Kg1 Rf4 68. Rh3 e2 69. Kg2 e1=Q 70. Rh7+ Ka8 71. Rh8+ Ka7 72. Rh7+ Ka8 73. Kh3 Qe5 74. Rh6 Rf2 75. Kg4 Qg7+ 76. Rg6 Qxg6+ 77. Kh3 d2 78. Kh4 Rh2# 0-1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;lichessのaiは先読み探索をしていない&quot;&gt;lichessのAIは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み（探索）&lt;/code&gt;をしていない？&lt;/h3&gt;
&lt;p&gt;　AIの強さを調整する（適度に弱くする）のはなかなか難しいと思いますが、上記の２番目の勝局のように１手詰め（詰めろ）を受けないというのはどういうことでしょうか？lichessAIが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rg1&lt;/code&gt;と指したところで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rf1&lt;/code&gt;と指して１手詰めを受けていればまだまだ勝負は分からなかったと思います。それをせずにわざと負ける（チェックメイトされる）ような手を選ぶのは、「何回かに一回はわざと負けてあげる」というようなことをしているわけではなく、AIのレベルが低い時（今回の場合はレベル４）は「&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み&lt;/code&gt;を一切しない」というような調整の仕方をしている気がします。&lt;br /&gt;
　一般的に学習型のAIは詰将棋（チェスプロブレム）は苦手と言われますが、それを補うためにまず短い手数の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み（探索）&lt;/code&gt;を行い、詰みが無ければ学習データを利用した静的評価関数で指し手を決めるようになっていると聞きますが、その&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み&lt;/code&gt;（よく&lt;strong&gt;力任せ&lt;/strong&gt;とか&lt;strong&gt;brute-force&lt;/strong&gt;と表現される指し手の探索）をせずに静的評価関数のみ（計算式のパラメータ調整のみ？）で指し手を決めているのかも知れません。冒頭で&lt;strong&gt;ある特徴&lt;/strong&gt;と書いたのはこのことです。&lt;br /&gt;
　実際のところは分かりませんし、他にも強さ調整のためにいろいろやってると思いますが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先読み（探索）&lt;/code&gt;をしなければサイトの負荷軽減にもなるので当たってる気がします。&lt;br /&gt;
　ちなみに先読みをしないという点では&lt;a href=&quot;https://happyclam.booth.pm/items/6582961&quot;&gt;「消える三目並べ」アプリ&lt;/a&gt;も同じような作りになっています。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;モンテカルロ法&lt;/code&gt;を使った強化学習で学習データを作り、そのデータに基づいて確率によって指し手を選択します。確率によって指し手を選択するので一手詰め（あと一手でラインが揃う）を見逃したりするのですが、学習が進むにつれて間違う確率が低くなっていきます。最近「消える三目並べ」を検索ワードにした当ブログへの訪問者が増えてるので、また記事を書くかも知れません。&lt;/p&gt;

&lt;h3 id=&quot;chesscomも同じ&quot;&gt;chess.comも同じ？&lt;/h3&gt;
&lt;p&gt;　以下の対局は&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;のAI（Santa BOT）&lt;/a&gt;と&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;の対戦ですが&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;chess.com AI が必勝局面から３手詰め頓死&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/vs_chesscom01.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/vs_chesscom01.gif&quot; alt=&quot;vs.chesscom_santa_1&quot; width=&quot;320&quot; height=&quot;373&quot; title=&quot;vs.chesscom_santa_1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. e4 e5 2. Nf3 Qf6 3. Bc4 a5 4. O-O g5 5. Qe2 h5 6. Bd5 g4 7. Ne1 Ne7 8. Kh1
Rg8 9. Nd3 Nxd5 10. exd5 Bd6 11. Nc3 h4 12. Ne4 Qf5 13. Nxd6+ cxd6 14. b3 h3 15.
Kg1 hxg2 16. Re1 g3 17. hxg3 Qh3 18. f4 Rxg3 19. Nf2 Qh6 20. fxe5 Ke7 21. exd6+
Kf8 22. Qe8+ Kg7 23. Re3 Qh2+ 24. Kxh2 g1=Q# 0-1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;AI&lt;/a&gt;が必勝局面で23手目&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Re3&lt;/code&gt;と指したことで３手詰が生じて頓死です。これも&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;のAI&lt;/a&gt;が短手数の詰みを読んでいなかった（先読み探索をしてなかった）のだと思います。&lt;br /&gt;
　自分の&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;が勝つ時はだいたいこんな感じで、出来の悪い評価関数のせいで序盤からずっと劣勢でなんとか終盤まで縺れた時に相手の頓死で勝つパターンが多いです。&lt;br /&gt;
　あと、&lt;a href=&quot;https://lichess.org/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lichess&lt;/code&gt;&lt;/a&gt;の方は&lt;a href=&quot;https://www.chess.com/home&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chess.com&lt;/code&gt;&lt;/a&gt;と違って無料の棋譜解析の回数制限が無いようなのでお勧めです。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 05 Jan 2025 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2025-01-05/lichess</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2025-01-05/lichess</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>chess</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>ミニチェスアプリもテスト</title>
        <description>&lt;h3 id=&quot;ミニチェスアプリは盤面編集可能&quot;&gt;ミニチェスアプリは盤面編集可能&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;前回記事&lt;/a&gt;の内容を&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;でもテストしてみました。&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門&lt;/a&gt;のステイルメイトの問題集を6x6のミニチェス用にアレンジして解かせてみると、元々の問題の趣旨とは違った発見があります。&lt;br /&gt;
　&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;は&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;と違って盤面編集機能があるので、暇な方は試してみて下さい。もしソースコードを見るつもりの方はアンパッサンとかキャスリングの実装でかなり汚くなっている&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;のコードよりも&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;の方をお勧めします。&lt;/p&gt;

&lt;h3 id=&quot;問題３&quot;&gt;&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;問題３&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;　元々の問題は以下の局面です。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;元の問題、初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q3_org.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q3_org.png&quot; alt=&quot;ステイルメイト問題３&quot; width=&quot;320&quot; height=&quot;459&quot; title=&quot;ステイルメイト問題３&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　正解は白&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc8+&lt;/code&gt;で、以下黒&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc8&lt;/code&gt;と進み、白がステイルメイトに持ち込むという問題です。&lt;br /&gt;
これを以下のように6x6に編集してみました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;６ｘ６初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q3-1.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q3-1.png&quot; alt=&quot;ステイルメイト問題３ー１&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題３ー１&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;ここからAI同士で対戦させると以下のように進みます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;詰みあり&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/chess66_3-1.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/chess66_3-1.gif&quot; alt=&quot;ステイルメイト問題３&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題３&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　6x6に編集した結果、詰みがある局面になってしまったので黒を詰ましてしまいましたが、当然こうなるべきでしょう。&lt;br /&gt;
今度は黒のキングを一路ずらして配置してみます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;初期盤面を変更&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q3-2.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q3-2.png&quot; alt=&quot;ステイルメイト問題３ー２&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題３ー２&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;ここからAI同士で対戦させると以下のように進みます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;ステイルメイト&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/chess66_3-2.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/chess66_3-2.gif&quot; alt=&quot;ステイルメイト問題３&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題３&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　白が劣勢ですが一旦&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;と黒のキングにチェックを掛けて、その後はステイルメイトが最善と判断して&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc6+&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc6&lt;/code&gt;とステイルメイトに持ち込みました、最善の応酬だと思います。下手に勝とうと思って白が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qd5&lt;/code&gt;（詰めろ）なんていう手を選ぶと、黒に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qd1+&lt;/code&gt;とチェックされてクィーンを交換後に戦力不足で白が負けてしまいます。&lt;/p&gt;

&lt;h3 id=&quot;問題７&quot;&gt;&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;問題７&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;　元々の問題は以下の局面です。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;元の問題、初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_01.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_01.png&quot; alt=&quot;ステイルメイト問題７&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問題７&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　正解は白&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;で白がステイルメイトに持ち込むという問題です。&lt;br /&gt;
これを以下のように6x6に編集してみました。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;６ｘ６初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q7-1.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q7-1.png&quot; alt=&quot;ステイルメイト問題７ー１&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題７ー１&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;ここからAI同士で対戦させると以下のように進みます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;白、負けは避けられない&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/chess66_7.gif&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/chess66_7.gif&quot; alt=&quot;ステイルメイト問題７&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題７&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　元々の問題のようにステイルメイトを狙って白が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qa4+&lt;/code&gt;なんてやると、黒が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxa4&lt;/code&gt;とクィーンで取ってくれれば良いのですが、以下のように&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rxa4&lt;/code&gt;とルークで白のクィーンを取られて&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;黒はステイルメイトを避ける&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/Q7-2.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/Q7-2.png&quot; alt=&quot;ステイルメイト問題７ー２&quot; width=&quot;320&quot; height=&quot;500&quot; title=&quot;ステイルメイト問題７ー２&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　白は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c3&lt;/code&gt;しか指す手がなくなり黒&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qb3#&lt;/code&gt;とチェックメイトになります。結局この問題は白の負けが避けられないので、上記の変化は最善の応酬だったことが分かります。もちろん黒がルークで白のクィーンを取る（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rxa4&lt;/code&gt;）ことも確認済みです。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  === intro07-2
    --- problem -7-2

6|♜| | | | | |
5| |♛| | | |♟|
4|♕| | | | |♚|
3| | | | |♟| |
2| | |♙|♟|♙| |
1| | | |♔| | |
  a b c d e f

      ✔ expects checkmate -7-2 (206ms)
♕
6| | | | | | |
5| |♛| | | |♟|
4|♜| | | | |♚|
3| | | | |♟| |
2| | |♙|♟|♙| |
1| | | |♔| | |
  a b c d e f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;チェスアプリ&lt;/a&gt;も&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;も多くのソースコードは同じなので問題がなくて当然なのですが、&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;に関しては&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mocha&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chai&lt;/code&gt;のテストを省略していたので、あらためてテストスクリプトを書いて確認してみました。&lt;/p&gt;

&lt;h3 id=&quot;ステイルメイトの評価値について&quot;&gt;ステイルメイトの評価値について&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2024-12-15/chessPIN&quot;&gt;前回の記事&lt;/a&gt;で先手勝ちの評価値を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;、後手勝ちの評価値を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;、ステイルメイトの局面に掛ける係数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.0009&lt;/code&gt;にして様子を見ると書きましたが、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.0009&lt;/code&gt;という値があまりにも小さすぎて奇異に感じるので先手勝ちを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;500&lt;/code&gt;、後手勝ちを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-500&lt;/code&gt;、係数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.09&lt;/code&gt;にして試してみたのですが、今度は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;駒の重み&lt;/code&gt;に使ってる値とバランスが取れず？に&lt;strong&gt;不都合&lt;/strong&gt;が出てきたので止めました。もし値を変えるとしたら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;駒の重み&lt;/code&gt;の数値も全面的に見直さないといけないんだろうなぁと思っていたところ、タイミング良く？&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X（Twitter）&lt;/code&gt;で&lt;a href=&quot;https://x.com/yaneuraou/status/1870996558600441943&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;やねうら王&lt;/code&gt;開発者のポスト&lt;/a&gt;を見かけました。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;やねうら王&lt;/code&gt;では&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;400&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-400&lt;/code&gt;を最大・最小値として使用しているそうで、以前&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;やねうら王&lt;/code&gt;をインストールした時（&lt;a href=&quot;/software/2024-06-12/yaneuraou&quot;&gt;「Ubuntuでやねうら王」&lt;/a&gt;）のソースを&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;すると確かにそのようです（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval_limit&lt;/code&gt;定数）。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;やねうら王&lt;/code&gt;のソースを読んでみてもいいのですが、理解するのは大変でしょうし何かアイデアが浮かばない限り当面はこのままにしておくつもりです。&lt;/p&gt;

&lt;p&gt;※&lt;strong&gt;不都合&lt;/strong&gt;とは何か…自分のアプリの場合、単純に評価値の最大・最小値を小さな値にすると「相手キングを積極的に詰ましにいかなくなる」、「千日手になりやすくなる」という現象を確認してます。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 22 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2024-12-22/chess66_test</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2024-12-22/chess66_test</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>chess</category>
        
        
        <category>software</category>
        
      </item>
    
      <item>
        <title>チェスのStalemateとPINの話</title>
        <description>&lt;h3 id=&quot;チェスアプリのバグを見つけてしまいました&quot;&gt;チェスアプリのバグを見つけてしまいました&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門&lt;/a&gt;というサイトのステイルメイトの問題集を&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;で解いてみると８問中１問間違えてしまいました。ステイルメイトの問題集はあまり見かけないので、十分なテストをしてなかったのが原因です。&lt;a href=&quot;https://happyclam.booth.pm/items/6325341&quot;&gt;マンカラアプリ&lt;/a&gt;もそうですが（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;詰めマンカラ問題集&lt;/code&gt;なんて聞いたことがありません）、問題集が手に入らないのである程度のところでテストを打ち切ってリリースしていたのですが、実際に解けない問題を見つけてしまった以上、対処することにしました。&lt;/p&gt;

&lt;h3 id=&quot;pinが絡む問題に問題がある&quot;&gt;PINが絡む問題に問題がある&lt;/h3&gt;
&lt;p&gt;　解けなかったのは&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門サイトの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;で、以下の局面です。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;初期盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_01.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_01.png&quot; alt=&quot;ステイルメイト問7-1&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　正解手は以下のようにQueenをc4に移動する&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;です。先手（白）劣勢ですが「王手クイーン取り」を掛けてステイルメイト（引き分け）に持ち込むという問題です。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;正解盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_02.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_02.png&quot; alt=&quot;ステイルメイト問7-2&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;でも、初期盤面から&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;に指させてみると、以下のように&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxd5&lt;/code&gt;と黒のクイーンを取ります。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;不正解&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_03.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_03.png&quot; alt=&quot;ステイルメイト問7-3&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　クィーンは取れるのですが次に後手（黒）がルークをa1に移動（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ra1&lt;/code&gt;）して合い駒効かずでチェックメイトされて先手（白）が負けます。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;不正解後の変化&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_04.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_04.png&quot; alt=&quot;ステイルメイト問7-4&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;正解手が指せないからといってバグとは限らないのですが、この問題の場合は３手の読みでステイルメイトに気付いて５手読めば&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ra1&lt;/code&gt;からの負けに気付くので、候補手を絞っている可能性があるので一概には言えませんが５手読めば正解できるはずです。&lt;br /&gt;
　では、手動で先手（白）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;と指した局面で&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;に指させてみると&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;先手（白）のクィーンを取る、正しい応手？&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_05.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_05.png&quot; alt=&quot;ステイルメイト問7-5&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-5&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;相手のクィーンを取って（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;）ステイルメイトと判定してゲーム終了となるのでこれも問題ありません。&lt;br /&gt;
　しかし、手動で先手（白）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;と指した局面から後手（黒）も手動で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;と指すと以下のようになります。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;手動で指すと「後手勝ち」の判定！！！&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_06.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_06.png&quot; alt=&quot;ステイルメイト問7-6&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　これはイケマセン。ステイルメイトなのに「後手の勝ちです」と判定してしまってます。これは明らかなバグです。&lt;br /&gt;
どうやらチェスで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;と呼ばれる状態の時にSTALEMATEの判定を間違うようです。
このステイルメイトの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;のミソは他の問題とは違って、単に「王手クィーン取り」を掛けてステイルメイトに持ち込むだけではなく、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;状態に持ち込むところです。初手は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qd4+&lt;/code&gt;でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4+&lt;/code&gt;でもダメで、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;でなければならないのです。&lt;/p&gt;

&lt;h3 id=&quot;将棋ではpinは大した問題ではない&quot;&gt;将棋ではPINは大した問題ではない&lt;/h3&gt;
&lt;p&gt;　上の図の終局の局面は将棋でも珍しくない形だと思います。将棋なら先手（白）は指す手が無くて投了するしか無い局面です。もし将棋初心者が指す手に困って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;されている&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e2&lt;/code&gt;の駒（ポーン）を前に動かしたとしても、後手（黒）がクィーンで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f1&lt;/code&gt;の玉（キング）を取れば済む話です（&lt;a href=&quot;/software/2024-04-07/tdd&quot;&gt;以前の記事&lt;/a&gt;参照）。その場合、将棋でも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;王手放置&lt;/code&gt;は反則と規定されているので正確に言えば先手（白）の反則負けと言うべきですが、いずれにしても後手（黒）の勝ちは揺るぎません。でも将棋と違ってチェスの場合は劣勢だった先手が引き分け（ステイルメイト）に持ち込んだことになります。将棋なら先手（白）負けなのにチェスだと引き分けになります。&lt;br /&gt;
　&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;に対応する将棋用語は何かよく分かりませんが、「串刺しにされてる」とか「角の効きに入ってる」とかの表現はありますが、ピッタリした用語が無いのが将棋というゲームが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;をそれほど重要視していないことの証拠にもなるでしょう。&lt;br /&gt;
　将棋アプリを開発する立場で見ても&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;なんて全然気にしていませんでした。チェスのソフトや昔からある将棋ソフトが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;をチェックするアルゴリズムを使っているのは知ってましたが、それは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stockfish&lt;/code&gt;由来のアルゴリズムを流用して作っていたからであって、自分のように一からアルゴリズムも考えて開発するのなら関係のない話だと思っていたし実際に作ることも出来ました。でも、今回の&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;のバグの修正に取り掛かってみて想像以上に面倒臭い作業を強いられて、チェスのステイルメイト（特に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;絡み）に対応するためには将棋とは別のやり方（別のデータ構造と別のアルゴリズム）で作る方がスマートに出来るのだろうということが想像できました。何がそんなに面倒くさいかと言うと長くなるので省略しますが、チェス盤のマス目を一つ一つ移動しながら&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;のチェックをするのはかなり&lt;strong&gt;無理がある&lt;/strong&gt;のです。&lt;br /&gt;
　将棋ソフト開発関連の本などをチラ見すると&lt;strong&gt;「データ構造に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;用のフラグを持たせる」&lt;/strong&gt;とか&lt;strong&gt;「合法手を列挙する」&lt;/strong&gt;とか言う表現をよく見かけますが、自分の将棋関連アプリ（&lt;a href=&quot;https://happyclam.booth.pm/items/6323599&quot;&gt;３三将棋&lt;/a&gt;、&lt;a href=&quot;https://happyclam.booth.pm/items/6325376&quot;&gt;５五将棋&lt;/a&gt;、&lt;a href=&quot;https://happyclam.booth.pm/items/6346070&quot;&gt;７七将棋&lt;/a&gt;）はデータ構造に&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;用のものはありませんし、「合法手を列挙する」作業も一切していませんが困ることは何もありませんでした。人間が実際に駒を動かすイメージで一つ一つの駒を８方向に動かす作業を想定したアルゴリズムになっていて、普通はそうしたやり方を採用するだろうと思われる極普通のやり方（アルゴリズム）です。「合法手を列挙する」と聞いて、昔から「何でそんなやり方してるのかなぁ？」と不思議に思ってました。もしかして、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stockfish&lt;/code&gt;を作った人は、最初私のようなやり方で&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;を作り始めてステイルメイトの実装に掛かった時に「こりゃダメだ！」「こんなことやってられない！」と感じて新しいやり方（データ構造とアルゴリズム）を捻り出したんじゃないでしょうか？私の勝手な想像ではありますが、今回のバグ修正に取り組んで&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stockfish&lt;/code&gt;を作った人の気持ちが分かったような気がしました。&lt;br /&gt;
　今回のバグ修正は&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;が絡むステイルメイトに関わる部分だけ&lt;/strong&gt;が下膨れした感じになっていて、幸いそういうケースはあまりないので全体の処理が重くなったということはありません。&lt;/p&gt;

&lt;h3 id=&quot;ステイルメイトは最善手なのか&quot;&gt;ステイルメイトは最善手なのか？&lt;/h3&gt;
&lt;p&gt;　上に挙げた&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門サイトの&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PIN&lt;/code&gt;の問題以外にも興味深い変化を含んでいます。上記のバグをなんとか&lt;strong&gt;無理がある&lt;/strong&gt;方法で修正して過去のテストも全部通過してデグレード（リグレッション）が無いところまでなんとか辿り着いて、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;も含めて&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;すべての問題&lt;/a&gt;に正解することも確認しました。&lt;br /&gt;
　そして、試しに先程の先手が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qc4+&lt;/code&gt;と指した下の正解局面から&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;正解盤面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_02.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_02.png&quot; alt=&quot;ステイルメイト問7-2&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;修正済みの&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;に後手を指させてみると&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;後手がステイルメイトを避けた局面&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_07.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_07.png&quot; alt=&quot;アプリ修正後の指し手&quot; width=&quot;320&quot; height=&quot;365&quot; title=&quot;ステイルメイト問7-7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;なんと、先手のクィーンを取らずに&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4&lt;/code&gt;と指して王手（チェック）を回避しました。修正する前はちゃんと先手のクィーンを取っていたので、修正前より悪化してるような気もがしますがそうではなく、正しくステイルメイトの局面だと判断できるようになって、後手（アプリ）が「優勢なのにステイルメイトなんかにしてたまるか！」とクィーンを犠牲にしてキングが逃げる手を選んだわけです。その後先手は当然後手のクィーンを取って（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxe4+&lt;/code&gt;）以下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kg5&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qa8&lt;/code&gt;となり後手のキングは大海に逃げ出すことは出来ますが、駒をボロボロ取られて十数手後に結局先手が勝ちます。結局そうなるのなら「ステイルメイトで妥協しておくべきだったんじゃないの？」と言いたくなりますが、自分のチェスアプリは深く読めていない（３〜５手）こともあってこうなります。&lt;br /&gt;
　このステイルメイトを無理やり避ける現象は&lt;a href=&quot;/software/2020-02-11/evaluatechess&quot;&gt;以前の記事&lt;/a&gt;で書いたステイルメイトの局面をどのように評価するか（ステイルメイトの局面に掛ける係数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.7&lt;/code&gt;をどのように決めるか問題）とも関わってくるのですが、自らステイルメイト（引き分け）を受け入れて確定させるより、少しでも勝つ可能性がある手を選ぶ方が最善手と言えなくもないような気もします。&lt;br /&gt;
　それにしても&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;詰めチェス&lt;/code&gt;（チェス・プロブレム）の中には問題の趣旨以外の有効な着手が存在するもの、将棋で言えば&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;余詰め&lt;/code&gt;がある詰将棋のような感じの問題が多いですね。それとも自分がチェス初心者だからそう感じるだけで、ベテランチェスプレイヤーなら上記の局面でステイルメイト（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;）以外は考えられないって感じでしょうか？身近にチェスに詳しい人がいないのでよく分かりません。&lt;br /&gt;
　&lt;a href=&quot;/software/2019-11-09/stalemate3&quot;&gt;以前の記事&lt;/a&gt;に書きましたが、そもそもステイルメイトの局面評価値に係数を掛けようと思ったのは、ステイルメイトの評価値を引き分けなのだからという理由で&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;にすると以下の局面で先手が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bf6&lt;/code&gt;という手を選んだからです。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;ステイルメイトが最善手？&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/stalemate_08.png&quot;&gt;&lt;img src=&quot;https://happyclam.github.io/images/stalemate_08.png&quot; alt=&quot;Stalemateは最善手？&quot; width=&quot;320&quot; height=&quot;467&quot; title=&quot;Stalemateは最善手？&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　先手はビショップとナイトを持っていて後手はルークだけで形勢は先手有利のはずなのに先手から進んでステイルメイト（引き分け）にするのはおかしいだろうと考えたのが事の発端です。この局面の後、指し手を進めても後手玉は捕まらないからステイルメイトにするのが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最善手&lt;/code&gt;なのでしょうか？自分は優勢なのに自ら進んでステイルメイトにするのはおかしいと考えたので、形勢が有利な時はステイルメイトの評価値にマイナスの値を掛けてやや反転？する仕様にした（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kf7&lt;/code&gt;の手を指します）のですが、もし&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bf6&lt;/code&gt;（ステイルメイト）が&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最善手&lt;/code&gt;というのがチェスプレイヤーの共通認識であるのならステイルメイト局面の評価値は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;のままでいいかもしれません。でも、上の局面で先手のポーンが一つでも&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b5&lt;/code&gt;辺りに残っていれば敢えてステイルメイトにする人はいないと思います。そのような局面とも比較するためにもステイルメイトの局面に掛ける係数は必要だと思います。&lt;br /&gt;
　あと、念の為もう一度書いておきますが、&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;は「&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;チェス入門サイト&lt;/a&gt;のステイルメイトの問題は全問正解します」、正解するけどその後の指し手が問題の趣旨通りには進まないと言うことです。&lt;/p&gt;

&lt;h3 id=&quot;他にも見えてきた問題&quot;&gt;他にも見えてきた問題&lt;/h3&gt;
&lt;p&gt;　上記の&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;の正解手の後の後手の一手（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4&lt;/code&gt;）は&lt;strong&gt;あまりにも無理してステイルメイトを避けている&lt;/strong&gt;ような気もしたので、試しにステイルメイトの局面の評価値に掛けている係数（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.7&lt;/code&gt;）を変更したら、後手（アプリ）は&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;と着手してステイルメイトを選ぶことを確認しました。そして、将棋とは違って局面の評価値に使っている最大値や最小値が悪影響を与えてることが見えてきました（あくまでも私が作った評価関数についての話です）。&lt;br /&gt;
　&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;では局面を評価する際の先手勝ちの局面の評価値を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;、後手勝ちの局面の評価値を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;にしているのですが、駒の重みは&lt;a href=&quot;/project/2019-11-16/chessapp&quot;&gt;この記事&lt;/a&gt;のようになっていて、クィーンが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;90&lt;/code&gt;、ルークが&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50&lt;/code&gt;…という感じで相手の駒を全部取っても&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;なんていう大きな数値にはなりません。この先手勝ち局面（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;）と後手勝ち局面（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;）のような大きな値にマイナスの係数（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.7&lt;/code&gt;）を掛けても、自分の思惑通りには比較出来ていなかったようです。&lt;br /&gt;
　それでも&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;以外は正解出来ていたのは、&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;のような紛れがなく明快な手しか無かったのでステイルメイトの局面を勝ちあるいは負けとほぼ同等の評価をしていたからでした。&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;のように紛れがある問題だと、負けるぐらいなら他の手を選ぼうとAIが考えてステイルメイトを避けたということです。ということで、&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;で正解後の後手の一手を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4&lt;/code&gt;ではなく&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qxc4&lt;/code&gt;を選ぶように調整した結果、ステイルメイトの局面に掛ける係数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.0009&lt;/code&gt;にしました。これで勝敗の決着がつく大きな値（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;や&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;）と、形勢判断時の評価値（駒の重みや駒の働きの合計値）との比較が出来ているようです。ちなみに係数を&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.001&lt;/code&gt;にすると元通り&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qe4&lt;/code&gt;と指してステイルメイトを避けます。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  === intro07-2
    --- problem -7-2

8|♜| | | | | | | |
7| | | | | | | | |
6| | | | | | | | |
5| | | |♛| | | |♟|
4| | |♕| | | | |♚|
3| | | | | | |♟| |
2| | | | |♙|♟|♙| |
1| | | | | |♔| | |
  a b c d e f g h

      ✔ expects stalemate -7-2 (686ms)
♕
8|♜| | | | | | | |
7| | | | | | | | |
6| | | | | | | | |
5| | | | | | | |♟|
4| | |♛| | | | |♚|
3| | | | | | |♟| |
2| | | | |♙|♟|♙| |
1| | | | | |♔| | |
  a b c d e f g h

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;これでようやく&lt;a href=&quot;https://chess-primer.jp/stalemate-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;問題７&lt;/code&gt;&lt;/a&gt;の正解後も問題の趣旨通りに後手がステイルメイトの手を選ぶようになりました。&lt;br /&gt;
　局面の最大値や最小値なんて閉じたアプリの中での相対的な評価値でしかないので何でもいいと思っていました。将棋アプリも先手の勝ちは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;50000&lt;/code&gt;、後手の勝ちは&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-50000&lt;/code&gt;を使っていますし、昔作ったオセロでもよくINT型のMAX値とMIN値を使っていました。でも将棋やオセロと違って&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;勝ち&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;負け&lt;/code&gt;以外の&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ステイルメイト&lt;/code&gt;という&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;勝ち&lt;/code&gt;と&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;負け&lt;/code&gt;の間にある局面を評価するには工夫する必要があるようです。このステイルメイトの局面に掛ける係数は、その意図は昔書いた記事（&lt;a href=&quot;/software/2020-02-11/evaluatechess&quot;&gt;「チェスだけに必要な局面評価属性」&lt;/a&gt;）の通りですが、もし評価関数が完璧なものであるなら必要ないのだと思います。ステイルメイトは引き分けとして評価値&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;でいいと思うのですが、完璧な評価関数なんて有り得ないので必要になってくるものだと思います。&lt;br /&gt;
　それと一つのケースだけを見て&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0.0009&lt;/code&gt;に決めてしまっていいのかと思うかも知れませんが、どのように決めるべきか分かってませんし最大値や最小値も駒の重みに関しても言ってみれば適当に決めた値なので、数は少ないですが過去のステイルメイトのテストケースも通過したことですし当面これで様子見ようと思います。&lt;br /&gt;
　今回、上記の点を弄って個人的にはスッキリしましたが、評価関数は少し変わっただけですし読みの深さも変わっていないので、ステイルメイトの判定が以前より正確になっただけで強くなったわけではないのが残念なところです。&lt;/p&gt;

&lt;h3 id=&quot;アプリのアップデートについて&quot;&gt;アプリのアップデートについて&lt;/h3&gt;
&lt;p&gt;　今回の修正でもうバグは無くなったのでは？と思ってますが、将棋関連アプリに較べるとチェスアプリに関してはステイルメイトというルールのおかげで安心感が無いというのが本音です。何か問題を見つけた場合はメールか&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;Boothサイト&lt;/a&gt;からご連絡下さい。&lt;br /&gt;
　取り敢えず、現在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Booth&lt;/code&gt;で販売している&lt;a href=&quot;https://happyclam.booth.pm/items/6346197&quot;&gt;ミニチェスアプリ&lt;/a&gt;は近いうちに一度今回の修正を反映させてアップデートするつもりです。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Amazon App Store&lt;/code&gt;で公開している&lt;a href=&quot;https://www.amazon.co.jp/dp/B082412BRQ/ref=sr_1_1?qid=1575089134&amp;amp;refinements=p_4%3Ahappyclam&amp;amp;s=mobile-apps&amp;amp;search-type=ss&amp;amp;sr=1-1&quot;&gt;チェスアプリ&lt;/a&gt;に関してはいつ削除されるかも知れませんし、今後はAmazonでは更新しないつもりです。無料のお試し版として残しておきますが、今後はチェスアプリも&lt;a href=&quot;https://happyclam.booth.pm/&quot;&gt;Booth&lt;/a&gt;で販売する予定です。→&lt;a href=&quot;https://happyclam.booth.pm/items/6399553&quot;&gt;Boothで最新版&lt;/a&gt;公開しました。&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 15 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://happyclam.github.io/software/2024-12-15/chessPIN</link>
        <guid isPermaLink="true">https://happyclam.github.io/software/2024-12-15/chessPIN</guid>
        
        <category>coffeescript</category>
        
        <category>javascript</category>
        
        <category>shogi</category>
        
        <category>chess</category>
        
        
        <category>software</category>
        
      </item>
    
  </channel>
</rss>
