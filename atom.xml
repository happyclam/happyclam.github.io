<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>自己満足プログラミング</title>
 <link href="https://happyclam.github.io/" rel="self"/>
 <link href="https://happyclam.github.io"/>
 <updated>2018-11-12T18:39:44+09:00</updated>
 <id>https://happyclam.github.io</id>
 <author>
   <name>happyclam</name>
   <email>happyclam.u@gmail.com</email>
 </author>

 
 <entry>
   <title>不成の詰将棋</title>
   <link href="https://happyclam.github.io/software/2018-10-27/unpromote"/>
   <updated>2018-10-27T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2018-10-27/unpromote</id>
   <content type="html">&lt;h3 id=&quot;打ち歩詰めを回避するための不成&quot;&gt;打ち歩詰めを回避するための不成&lt;/h3&gt;
&lt;p&gt;　真偽の程はわからないのですが、最新の将棋ソフトを以ってしても角不成を含む詰将棋を解くことが出来ないと小耳に挟みました。自分は最新の将棋ソフトの動向には疎くソフトも古いのしか持っていないので確認出来ませんが、有名な&lt;a href=&quot;https://shogi100.com/2018/03/14/1-13/&quot;&gt;「谷川九段の角不成」&lt;/a&gt;という実践詰将棋があって、機械学習（おそらくディープラーニングを使ったもの）を用いた最新のソフトでも６七角引不成（&lt;a href=&quot;http://i2chmeijin.blog.fc2.com/blog-entry-1955.html&quot;&gt;参考記事&lt;/a&gt;）からの１９手詰めが解けないそうです。学習型の将棋ソフトは終盤が弱いとは聞いていました。でも自分が持っている相当古いソフト（１０年以上前に購入した「AI将棋 Version13」&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;）で試してみたところ、見事に詰め上げることが出来たので結局はソフトに依るということでしょう。ただ最新のソフトがなぜ解けないのか、なぜそうなっている（あるいはそうしている）のでしょう？もしかしたら結構難しいのでしょうか？データ構造によっては難しい処理を強いられるかもしれないなぁとは思います。原因というか不成を読まない？理由についてはもしかしてと思い当たることもあるのですが、想像の域を出ないので他人様のことは置いといて、とりあえず自分の作ったソフトが成りと不成をちゃんと区別出来るか確認することにしました。打ち歩詰めに関しても詰将棋に関しても成る・成らないに関しても一応テストはしてますが、&lt;strong&gt;打ち歩詰めを回避するために敢えて成らない&lt;/strong&gt;ということが出来るかどうかちょっと心配になったからです&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;１９手詰めで確認したいけど&quot;&gt;１９手詰めで確認したいけど&lt;/h3&gt;
&lt;p&gt;　有名な角不成の１９手詰の詰将棋をそのまま自分のソフトで試してみたいところですが、自分のソフトでは１９手詰めなんて出来ません。何度かこのブログでも書いていますが、有名な将棋ソフトは大抵、将棋盤をビットパターンで表現して高速に先読み出来るようになっています（BitBoardと呼ばれているようです）が、自分のソフトは通常の多次元配列データで将棋盤を表現しているので到底太刀打ち出来ません。将棋ソフトに革命をもたらしたボナンザ（Bonanza）は独自の評価関数や学習機能で有名ですが、BitBoardを最初に将棋ソフトに取り入れたのも同じ開発者（保木氏）なのでしょうか？よく知らないのですが、もしそうならそのことももっと評価されるべきだと思いますけどどうなのでしょう？&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;BitBoardをJavaScriptで作る人は…いないでしょうね&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　話が逸れましたが、長手数の詰将棋は無理なので、&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi55.io.github.happyclam&quot;&gt;５五将棋&lt;/a&gt;の形に修正した短手数の詰将棋問題で確認することにしました。９×９の本将棋のままでは時間が掛かり過ぎるからです。&lt;br /&gt;
　&lt;strong&gt;以下のテストは５五将棋の盤面（５×５）ですが、通常の本将棋（９×９）と同じように先手は３段目で成ることが出来、後手は５段目だけで成ることが出来るよう特殊な設定にしています。また、詰みに影響を与えないように双玉の形にして後手（玉方）の持ち駒は時間短縮のため金一枚にしました。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;打ち歩詰め回避詰将棋 - 角不成（&lt;a href=&quot;https://books.google.co.jp/books?id=Ze7DCAAAQBAJ&amp;amp;pg=PA108&amp;amp;lpg=PA108&amp;amp;dq=角不成+詰将棋&amp;amp;source=bl&amp;amp;ots=SVjU7lWwSg&amp;amp;sig=CU4yi7RK8IsYeDGyRZoslpCT19I&amp;amp;hl=ja&amp;amp;sa=X&amp;amp;ved=2ahUKEwj-1Jvw84LeAhXCM94KHbo3DEA4FBDoATABegQICBAB#v=onepage&amp;amp;q=角不成%20詰将棋&amp;amp;f=false&quot;&gt;出典&lt;/a&gt;）:&lt;br /&gt;
&lt;a href=&quot;/images/tume1.gif&quot;&gt;&lt;img src=&quot;/images/tume1.gif&quot; alt=&quot;角不成詰将棋&quot; title=&quot;角不成詰将棋&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
先手持ち駒＝無し&lt;br /&gt;
詰み手順＝２三角不成、１一玉、１二歩、２二玉、３二飛成、まで５手詰め&lt;br /&gt;
&lt;strong&gt;初手２三角成は打ち歩詰めになります。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打ち歩詰め回避詰将棋 - 歩不成（&lt;a href=&quot;https://www.shogitown.com/beginner/5te_2008/5te_tume08-12.html&quot;&gt;出典&lt;/a&gt;）:&lt;br /&gt;
&lt;a href=&quot;/images/tume2.gif&quot;&gt;&lt;img src=&quot;/images/tume2.gif&quot; alt=&quot;歩不成詰将棋&quot; title=&quot;歩不成詰将棋&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
先手持ち駒＝歩一枚&lt;br /&gt;
詰み手順＝３二歩不成、１二玉、１三歩、２二玉、３三飛成、まで５手詰め&lt;br /&gt;
&lt;strong&gt;初手３二歩成は打ち歩詰めになります。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打ち歩詰め回避詰将棋 - その他（&lt;a href=&quot;https://ja.wikipedia.org/wiki/打ち歩詰め&quot;&gt;出典&lt;/a&gt;）:&lt;br /&gt;
&lt;a href=&quot;/images/tume3.gif&quot;&gt;&lt;img src=&quot;/images/tume3.gif&quot; alt=&quot;打ち歩詰め回避詰将棋&quot; title=&quot;打ち歩詰め回避詰将棋&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
先手持ち駒＝桂一枚、歩一枚&lt;br /&gt;
詰み手順＝２四桂、同龍、１三歩、同龍、２一銀不成、まで５手詰め&lt;br /&gt;
&lt;strong&gt;すぐに１三歩は打ち歩詰めになるので、桂馬で王手して龍で打ち歩を取らざるを得ないようにして打ち歩詰めを回避します。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;玉方打ち歩詰め誘導 - 飛不成（&lt;a href=&quot;https://ja.wikipedia.org/wiki/打ち歩詰め&quot;&gt;出典&lt;/a&gt;）:&lt;br /&gt;
&lt;a href=&quot;/images/tume4.gif&quot;&gt;&lt;img src=&quot;/images/tume4.gif&quot; alt=&quot;玉方飛不成詰将棋&quot; title=&quot;玉方飛不成詰将棋&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
先手持ち駒＝桂一枚、歩一枚&lt;br /&gt;
正解手順＝２四桂、同飛不成で１三歩が打ち歩詰めになるようにして即詰みを逃れます（結局は詰まされますが…）。&lt;br /&gt;
&lt;strong&gt;玉方が飛不成で打ち歩詰めに誘導することで即詰みを逃れます。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;玉方打ち歩詰め誘導の反証テスト：&lt;br /&gt;
&lt;a href=&quot;/images/tume5.gif&quot;&gt;&lt;img src=&quot;/images/tume5.gif&quot; alt=&quot;玉方飛不成詰将棋の反証&quot; title=&quot;玉方飛不成詰将棋の反証&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
先手持ち駒＝桂一枚、香一枚&lt;br /&gt;
正解手順＝２四桂、同飛成&lt;br /&gt;
&lt;strong&gt;桂馬を打たれた時に先手の持ち駒が歩ではなく香車だった場合には飛車が成る（最善手）ことを確認。（持ち駒に歩ではなく香車がある場合は、１三香と打てば詰みなので２四桂馬は悪手ですが、テストのために人間が指してます）&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　一応すべてのテストで正解でした。但し、このテストは実際のアプリより深く読むように設定し、敢えて指し手の候補手を絞り込まない（全件探索）ようにして実施しています。&lt;/p&gt;

&lt;h3 id=&quot;詰将棋を解くことと勝負に勝つことは別物&quot;&gt;詰将棋を解くことと勝負に勝つことは別物&lt;/h3&gt;
&lt;p&gt;　ＡＩ同士で対戦させて上記のテストを実施したのですが、1.と5.のテストはＡＩ対人間でテストしています。1.は後手側、5.は先手側を人間が担当しています。ちなみに1.のケースで先手・後手ともにＡＩにしてＡＩ同士で対戦させると以下のように対局が進行します。&lt;br /&gt;
&lt;a href=&quot;/images/tume_example.gif&quot;&gt;&lt;img src=&quot;/images/tume_example.gif&quot; alt=&quot;駒余り&quot; title=&quot;駒余り&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
　ＡＩは特別な処理をしない限り駒が余ることに拘らないので駒余りの手順を選んでしまいました。受ける側（後手）が正確に駒が余らないように&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;応じないと、詰将棋として正解手順にならないので玉方（後手）は人間が指すことにしたわけです。「駒が余ってはいけない」という詰将棋独自のルールをソフトに実装するのは結構手間がかかりそうです。また、&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi55.io.github.happyclam&quot;&gt;５五将棋&lt;/a&gt;では王手が掛かっていなくても玉が自殺する手しか存在しない時がよくあります（&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;３三将棋&lt;/a&gt;だともっと頻繁に現れます）。そのような時、ＡＩにとっては連続王手で綺麗に詰ますのも、相手の指す手を無くしてゲーム終了させるのも同じ&lt;strong&gt;「勝ち」&lt;/strong&gt;なので、綺麗な詰み手順があるのにそれを選ばない時がよくあります&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。そういう時に端から見ている開発者としてはがっかりするのですが、「駒が余ってはいけない」という詰将棋独自のルールも含めて、そうなるように作っていないので仕方がありません&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　言いたいことは、以下の３つは微妙に意味が異なるということです。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;詰将棋を解く（駒を余らせない、無駄合いをしない等の詰将棋独自のルールにもしたがう）&lt;/li&gt;
  &lt;li&gt;相手玉を詰まして勝つ（詰みを逃さない、詰みを優先する）&lt;/li&gt;
  &lt;li&gt;将棋に勝つ（連続王手による詰み手順に拘らない）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　たぶん機械学習（ディープラーニング含む）によるＡＩだと1.と2.の機能を実装するのは難しいのだと思います。特に1.の機能は、勝手な想像ですが外国人の開発者が将棋ソフトを作ったらよほどの将棋好きでもない限り省く（実装しようとさえ思わない）と思いますし、話題になったAlphaZeroも今後1.の機能を実装することはないでしょう（予言）&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　2.の機能は昔からノウハウが蓄積されてる詰み判定ルーチン（学習によるものではなく力技の探索機能）を併用することで、程度の差こそあれ実現出来るような気がします。&lt;br /&gt;
　ということで、角不成の詰将棋が解けない最新のＡＩっていうのは、純粋に機械学習によるＡＩ機能だけで将棋を強くすることを目指していて、敢えて力技による先読み機能を実装していないソフトなのかも知れません、私の単なる憶測ですが。&lt;/p&gt;

&lt;h3 id=&quot;追記&quot;&gt;追記&lt;/h3&gt;
&lt;p&gt;　この記事を書いた時点では「最新の将棋ソフト」と聞いただけで特定のソフトを想定して書いていたわけではないのですが、最新の将棋ソフトの一つで最も有名？な&lt;a href=&quot;https://book.mynavi.jp/yaneura/&quot;&gt;「将棋神やねうら王」&lt;/a&gt;はオプションで不成の指し手を読むように変更出来るそうです（&lt;a href=&quot;https://twitter.com/yaneuraou/status/1060264215175299074&quot;&gt;開発者のTweet&lt;/a&gt;）。オプション設定で簡単に変更出来るということは、「やねうら王」に関しては不成の指し手を敢えて読んでいなかっただけみたいです。「やねうら王」はLinuxでも動作させることが可能だと聞いたので、いつか製品版にこの機能が組み込まれたら購入して試してみようと思ってます。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Windows用のまともなPCを持ってないので、Windows向けソフトをLinux上でWineを使って動かしてます。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;誰かが作ったというより多くの人の手によって改良されてきているのかもしれませんし、もっと古くから実装されてそうな気もします。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;詰将棋では同じ詰まされるにしても受ける側（玉方）が攻める側になるべく多くの駒を使わせるのが最善手。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;ここで言っているのは連続王手の三手詰めが存在しているのに王手を掛けずに、同じく三手で勝つことがあるという意味です。三手で勝てるのに勝ちを逃して（手数を伸ばして）勝ってしまうという意味ではありません。「詰みより必至」という話とも違います。 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>BFSで将棋パズルを解く</title>
   <link href="https://happyclam.github.io/software/2018-08-18/puzzle"/>
   <updated>2018-08-18T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2018-08-18/puzzle</id>
   <content type="html">&lt;h3 id=&quot;将棋パズルとは&quot;&gt;将棋パズルとは&lt;/h3&gt;
&lt;p&gt;　数年前にTwitterで女流棋士の中倉彰子さんの呟きを見てその存在を知りました、最近&lt;a href=&quot;https://www.amazon.co.jp/脳がぐんぐん成長する-将棋パズル-中倉-彰子/dp/486280604X&quot;&gt;書籍&lt;/a&gt;を出されたようです。子供の頃４×４の１６マスのケースに１〜１５までの数字が書かれたバラバラのピースを数字の順に並べ直すというパズルをやったことがありますが、それの将棋版と思えばいいと思います。但し盤面は３×３で先手番の駒だけを自由に配置し、スタートの局面から将棋の駒を動かしてゴールの局面に変化させるというもので、まず将棋の駒の動きを覚えないと出来ません。パズルの存在を知った時は解答を得るためのプログラムを作ろうなんて思いませんでしたが、&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;３三将棋アプリ&lt;/a&gt;を作った直後なので、プログラムに必要な部品が全て揃っているので作ってみました。&lt;/p&gt;

&lt;h3 id=&quot;必要な作業&quot;&gt;必要な作業&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;駒の動きを定義したPieceクラス（作成済み）&lt;/li&gt;
  &lt;li&gt;駒の制御を行うBoardクラス（作成済み）&lt;/li&gt;
  &lt;li&gt;盤面を多分木データとして格納するNodeクラス（今回作成）&lt;/li&gt;
  &lt;li&gt;BFS（幅優先探索）で存在し得る全ての盤面を生成してNodeオブジェクトに追加&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　１５ピースパズルや迷路を解く時なんかは１、２は不要なので簡単ですが、将棋パズル解答プログラムを一から作るとなると結構大変です。でも今回は&lt;a href=&quot;/project/2018-06-30/9masushogi_solver&quot;&gt;前回の記事&lt;/a&gt;で使用したソースを若干修正してそのまま利用出来ます。&lt;/p&gt;

&lt;h3 id=&quot;nodeクラス&quot;&gt;Nodeクラス&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-CoffeeScript&quot;&gt;class Node
    _counter = 0
    _duplication = []

    # 同じ駒が複数使用されていることもあるので座標も含めてソート
    _sortCoordinate = (a, b) -&amp;gt;
        kinds = [&quot;Ou&quot;, &quot;Hi&quot;, &quot;Ka&quot;, &quot;Ki&quot;, &quot;Gi&quot;, &quot;Ke&quot;, &quot;Ky&quot;, &quot;Fu&quot;]
        return kinds.indexOf(a[&quot;kind&quot;]) - kinds.indexOf(b[&quot;kind&quot;]) || a[&quot;posi0&quot;] - b[&quot;posi0&quot;] || a[&quot;posi1&quot;] - b[&quot;posi1&quot;]

    # 局面を比較するためHashを生成
    @make_hash = (board) -&amp;gt;
        rec = []
        for koma in board.pieces
            buf = {}
            buf[&quot;kind&quot;] = koma.kind()
            buf[&quot;turn&quot;] = koma.turn
            buf[&quot;status&quot;] = koma.status
            buf[&quot;posi0&quot;] = koma.posi[0]
            buf[&quot;posi1&quot;] = koma.posi[1]
            rec.push(buf)
        rec.sort _sortCoordinate
        return crypto.createHash('md5').update(JSON.stringify(rec)).digest(&quot;hex&quot;)

    # 重複局面をチェックするために局面のHash値を追加
    @set_dup = (hash) -&amp;gt;
        _duplication.push(hash)

    # 出現済みの局面ならtrue、新規局面ならfalseを返す
    @check_dup = (hash) -&amp;gt;
        check = (v for v in _duplication when v == hash)
        if check.length &amp;gt; 0
            return true
        else
            return false

    # Boardオブジェクトとその子局面を格納するための配列を用意
    constructor: (v) -&amp;gt;
        @value = v
        @child = []

    # 答えの局面を探して見つけたら手数と局面を表示
    search: (target) -&amp;gt;
        return null unless target?
        return @ if Node.make_hash(@value) == Node.make_hash(target)
        ret = false
        for v in @child
            # 答えの局面を見つけた
            if Node.make_hash(v.value) == Node.make_hash(target)
                ret = true
                _counter += 1
                console.log(&quot;#{_counter}:&quot;)
                v.value.display()
            else
                ret = v.search(target)
                # 答えを見つけた後は、その過程の局面と手数を遡って表示
                if ret
                    _counter += 1
                    console.log(&quot;#{_counter}:&quot;)
                    v.value.display()
            break if ret
        return ret

    # 子局面を辿りながら多分木データを追加していく
    add: (target, obj) -&amp;gt;
        ret = null
        for v, i in @child
            # 親となる局面を見つけたらその子局面としてNodeオブジェクトを追加
            if Node.make_hash(v.value) == Node.make_hash(target)
                ret = v.child.push(obj)
            # 見つからなければさらに子局面を辿る
            else
                ret = v.add(target, obj)
            break if ret?
        return ret

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;実行ファイル&quot;&gt;実行ファイル&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-CoffeeScript&quot;&gt;# game.coffee
startTime = new Date().getTime()

bfs = (board) -&amp;gt;
    queue = []
    queue.push(board)
    seq = 0
    layer = 0
    while queue.length &amp;gt; 0
        bd = queue.shift()
        layer += 1
        for koma in bd.pieces
            for v in eval(&quot;Piece.&quot; + koma.kind()).getD(koma.turn, koma.status)
                buf = [].concat(koma.posi)
                loop
                    break unless ((buf[0] + v.xd in [1..bd.cols]) &amp;amp;&amp;amp; (buf[1] + v.yd in [1..bd.rows]))
                    buf[0] += v.xd; buf[1] += v.yd
                    dest = (o for o in bd.pieces when o.posi? &amp;amp;&amp;amp; o.posi[0] == buf[0] &amp;amp;&amp;amp; o.posi[1] == buf[1])
                    break if dest.length != 0 &amp;amp;&amp;amp; dest[0].turn == koma.turn
                    if bd.check_move(koma, buf)
                        # 着手可能な手ならBoardオブジェクトをディープコピー（新たな局面を生成）
                        temp = bd.clone()
                        move_piece = (o for o in temp.pieces when o.posi? &amp;amp;&amp;amp; o.posi[0] == koma.posi[0] &amp;amp;&amp;amp; o.posi[1] == koma.posi[1])
                        temp.move_capture(move_piece[0], buf)
                        md5hash = Node.make_hash(temp)
                        # temp.display()
                        # 重複局面は多分木データに追加しない
                        if Node.check_dup(md5hash)
                            continue
                        else
                            Node.set_dup(md5hash)
                        seq += 1
                        if layer == 1
                            node.child.push(new Node(temp))
                        else
                            node.add(bd, new Node(temp))
                        queue.push(temp)
                        # console.log(&quot;seq = #{seq}&quot;)
                    break unless (dest.length == 0 &amp;amp;&amp;amp; v.series)

# スタート局面
b = new Board()
b.pieces = []
b.pieces.push(new Piece.Ka(Const.FIRST, Const.Status.OMOTE, [3,1]))
b.pieces.push(new Piece.Gi(Const.FIRST, Const.Status.OMOTE, [2,2]))
b.pieces.push(new Piece.Fu(Const.FIRST, Const.Status.OMOTE, [3,3]))
b.pieces.push(new Piece.Fu(Const.FIRST, Const.Status.OMOTE, [2,1]))
b.pieces.push(new Piece.Fu(Const.FIRST, Const.Status.OMOTE, [1,3]))

# ゴール（答え）の局面
answer = new Board()
answer.pieces.push(new Piece.Ka(Const.FIRST, Const.Status.OMOTE, [1,3]))
answer.pieces.push(new Piece.Gi(Const.FIRST, Const.Status.OMOTE, [2,2]))
answer.pieces.push(new Piece.Fu(Const.FIRST, Const.Status.OMOTE, [3,3]))
answer.pieces.push(new Piece.Fu(Const.FIRST, Const.Status.OMOTE, [2,1]))
answer.pieces.push(new Piece.Fu(Const.FIRST, Const.Status.OMOTE, [1,1]))

node = new Node(b)
bfs(b)
node.search(answer)
# 一応最後にスタート時の画面も表示
b.display()

elapsed = new Date().getTime() - startTime
console.log &quot;経過時間: #{elapsed}ミリ秒&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　&lt;strong&gt;重複局面を除くことで答えの局面を探し出す際に最短手順であることが保証されます。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;例題&quot;&gt;例題&lt;/h3&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/puzzle_example.png&quot;&gt;&lt;img src=&quot;/images/puzzle_example.png&quot; alt=&quot;例題局面&quot; title=&quot;例題局面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;span&gt;最短手数＝５手&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;実行結果&quot;&gt;実行結果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;coffee game.coffee
1:

 3 2 1
| |F|F|1
| |G| |2
|F| |M|3

2:

 3 2 1
| |F| |1
| |G|F|2
|F| |M|3

3:

 3 2 1
| |F|G|1
| | |F|2
|F| |M|3

4:

 3 2 1
|M|F|G|1
| | |F|2
|F| | |3

5:

 3 2 1
|M|F|G|1
| | | |2
|F| |F|3


 3 2 1
|M|F| |1
| |G| |2
|F| |F|3

経過時間: 223ミリ秒
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　ゴールの局面からスタートの局面まで遡って表示されます。&lt;/p&gt;

&lt;h3 id=&quot;最短手数になる原理&quot;&gt;最短手数になる原理&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/project/2015-10-10/tictactoe_bfs&quot;&gt;以前の記事&lt;/a&gt;にも書きましたが、BFS（幅優先探索）では局面を辿る順番が、一手目で現れ得る局面を全て辿った後に二手目の局面、二手目で現れ得る全ての局面を辿った後に三手目の局面と進んでいきますので、たとえ答えの局面に辿り着く経路が複数あったとしても答えに辿り着いた手順が最短経路であることが保証されます。答えに辿り着く手順が１０手で完成する手順と１５手で完成する手順があったとしても、BFSを使っている限り最短手数のものから見つかるからです。答えが見つかった時点で探索をやめればわざわざ多分木データを生成しなくてもいいのですが、せっかく全局面を探索してくれるので、このプログラムでは一旦全局面を保存してます。今回のNodeオブジェクトのような二つのメンバー変数を持つオブジェクトに全データを格納しておけば、いろいろな条件に当てはまる局面を探し出すのに便利で、最長手数を求めたりその手数で実現出来る局面を全てリストアップしたり出来ますので問題を作る時も便利です。&lt;/p&gt;

&lt;h3 id=&quot;問題を作る&quot;&gt;問題を作る&lt;/h3&gt;
&lt;p&gt;　例えば以下のようなメソッドを追加して&lt;code&gt;node.recurCount(0)&lt;/code&gt;と呼び出せば、スタート局面から最短手順を選択した上で手数が最も長くなるのは何手かを求めることが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CoffeeScript&quot;&gt;
    recurCount: (cnt) -&amp;gt;
        if _counter &amp;lt; cnt
            _counter = cnt
        cnt += 1
        for v, i in @child
            v.recurCount(cnt)
        return _counter

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　先の例題のスタート局面から最も長い手数が必要となる局面は以下の局面で、必要な手数は９手です。&lt;/p&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/puzzle_deepest.png&quot;&gt;&lt;img src=&quot;/images/puzzle_deepest.png&quot; alt=&quot;最長手数局面&quot; title=&quot;最長手数局面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;span&gt;最短手数＝９手&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　
　スタート局面から無駄に手数を伸ばすことなく最も手数がかかる局面をゴール局面とすれば難問が完成します。&lt;/p&gt;

&lt;h3 id=&quot;もっと難問を作れるか&quot;&gt;もっと難問を作れるか&lt;/h3&gt;
&lt;p&gt;　Twitterでゴール局面まで６０手掛かるという難問を見かけたので、問題を作る側の立場で考えてみました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/puzzle_example2.png&quot;&gt;&lt;img src=&quot;/images/puzzle_example2.png&quot; alt=&quot;例題局面&quot; title=&quot;例題局面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　まず全ての駒を適当に配置した問題を作って調べてみました。下の３パターンが上図をスタート局面とした場合の最長手数となる解答です。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/puzzle_example2-all.png&quot;&gt;&lt;img src=&quot;/images/puzzle_example2-all.png&quot; alt=&quot;解答局面&quot; title=&quot;解答局面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;span&gt;最短手数＝２５手&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　手順は省略しますが上の局面から下の３つの局面に駒を移動させるには最短手数でも２５手必要で、上のスタート局面から出現し得る全ての局面のうち２５手かかるのは下の局面３つだけのようです。もちろん無理やり手数を伸ばして実現することは可能ですが、最短手順を選んでも２５手かかってしまうというところがミソです。&lt;br /&gt;
　ちなみにスタート画面の「歩」を「と金」に変えると最長手順は３１手に伸びるようですが、長手順の難問を作るには適当に駒を配置するだけではダメなのかも知れません。&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;３三将棋アプリ&lt;/a&gt;を作った時に感じたのですが、「３三将棋（＝９マス将棋）」だと適当に駒を配置するだけだと一目で正解が分かるような簡単な配置になってしまうことも多くて、熱戦が期待出来るような初期配置パターンを探すのに苦労しました。「将棋パズル」の場合も正解手順を見つけることより、長手順になる問題を見つける方が、問題を解くより難しいのかもしれません。最近はソフトで詰将棋を解くのは当たり前になってしまって、芸術的な詰将棋をソフトで作る研究が行われていると聞いたことがありますが、その状況と似ていますね&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;余談&quot;&gt;余談&lt;/h3&gt;
&lt;p&gt;　自分のブログは「BFS DFS 違い」とか「BFS 用途」とかの検索ワードで来訪される人が偶にいるのですが、対戦ゲームに使用するとすればBFS（幅優先探索）の使い途は定跡データや学習データの格納・検索、DFS（深さ優先探索）の使い途は局面の先読み（MIN-MAX法を使った有利不利判定）ってことになるんじゃないでしょうか。&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;進化する三目並べ&lt;/a&gt;でも学習データの保存・検索にBFSを使用しています。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;３三将棋アプリ&lt;/a&gt;では簡単な初期配置は除いて、面白い対局になる初期配置を厳選しているつもりです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>CUIで９マス将棋を解く</title>
   <link href="https://happyclam.github.io/project/2018-06-30/9masushogi_solver"/>
   <updated>2018-06-30T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2018-06-30/9masushogi_solver</id>
   <content type="html">&lt;h3 id=&quot;３三将棋アプリのソース公開しました&quot;&gt;３三将棋アプリのソース公開しました&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;３三将棋アプリ&lt;/a&gt;もそろそろ安定してきたと思うのでソースを&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;githubに公開&lt;/a&gt;しました。Bonanzaを始めとする優秀な将棋ソフトをカスタマイズしようとは思わないけど、CoffeeScript(JavaScript)で将棋ソフトが作れるならやってみようと思う人はいるかも知れないと思ってます。また、プログラミングには興味ないけど９マス将棋の正解を知りたいと思う人は結構いるかもしれないと思ったので記事を書いてみました。ただ、詰みがある場合は別ですが、ここで示す方法で得られた解答が必ず最善手だとは言い切れないことには留意してください&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
　ちなみに最近&lt;a href=&quot;https://play.google.com/store/apps/details?id=jp.co.roue.shogi&quot;&gt;９マス将棋オンライン&lt;/a&gt;というアプリで遊んでいるのですが、単純な配置でも未だに最善手が何か悩まされることがあります（特に入玉形の場合が難しい）。そういう時スクショを取ってこの記事の方法で何が最善手だったか検討したりしています&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;。&lt;/p&gt;

&lt;h3 id=&quot;テスト環境&quot;&gt;テスト環境&lt;/h3&gt;
&lt;p&gt;　９マス将棋の解答を得るために必要なものは&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;githubリポジトリ&lt;/a&gt;内のファイルとCoffeeScriptのインストールだけです。編集する必要があるのはCUIテスト用スクリプトファイル（game.coffee）だけです。CoffeeScriptのインストールに関しては環境に依りますので省略します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/happyclam/shogi33simple.git
cd shogi33simple
coffee game.coffee
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;将棋盤面初期配置の編集&quot;&gt;将棋盤面（初期配置）の編集&lt;/h3&gt;
&lt;p&gt;　将棋盤に駒を配置するにはBoardクラスのpiecesメンバに駒をpushしていくのですが、コピペして書き換えれば簡単だと思います。&lt;br /&gt;
　例えば先手の玉を３三に配置したい場合は&lt;code&gt;new Piece.Ou(Const.FIRST, Const.Status.OMOTE, [3,3])&lt;/code&gt;としてPieceクラスのインスタンスを生成してBoardオブジェクトのpiecesメンバにpushします。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/arrange13.png&quot; alt=&quot;初期配置　例１&quot; title=&quot;初期配置　例１&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　上記の初期配置をセットするコードは以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CoffeeScript&quot;&gt;b = new Board()
b.pieces = []
b.pieces.push(new Piece.Ou(Const.FIRST, Const.Status.OMOTE, [3,2]))
b.pieces.push(new Piece.Ou(Const.SECOND, Const.Status.OMOTE, [1,1]))
b.pieces.push(new Piece.Ky(Const.FIRST, Const.Status.MOTIGOMA))
b.pieces.push(new Piece.Ki(Const.SECOND, Const.Status.MOTIGOMA))
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;駒の種類&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　クラス名　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;玉（王）&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ou&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;飛　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Hi&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;角　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ka&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;金　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ki&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;銀　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gi&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;桂　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ke&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;香　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ky&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;歩　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Fu&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　先手・後手、駒の状態（不成、成、持ち駒）の区別は以下の定数を使用します。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;定数&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;　意味　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Const.FIRST&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;先手&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Const.SECOND&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;後手&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Const.Status.OMOTE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;駒の状態、表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Const.Status.URA&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;駒の状態、成り&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Const.Status.MOTIGOMA&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;駒の状態、持ち駒&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;読む深さの指定&quot;&gt;読む深さの指定&lt;/h3&gt;
&lt;p&gt;　Playerクラスのdepthプロパティに読む深さを指定します。０になるまで局面を先読みしますので６を指定すると７手読みになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;first = new Player(Const.FIRST, false)
second = new Player(Const.SECOND, false)
first.depth = 6
second.depth = 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　５手詰めの詰将棋を解くには７手読みする必要がある&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;のでdepth = 6を指定しないと解けないかというとそういうわけでもなくて、それ以下でも詰み手順を正確に辿っていくこともあります。上記の初期配置の例だと、詰み手数で言えば７手詰め（１三香、１二金、同香、同玉、２二金、１三玉、２三金）ですが、depth=3（４手読み）の設定でも正確に詰み手順を辿ることができます。読み切れていなくても最善手を指せるかどうかは評価関数の巧拙にかかっています&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
　ちなみに&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;３三将棋アプリ&lt;/a&gt;の評価関数は&lt;code&gt;（先手の駒の重みの合計 ー 後手の駒の重みの合計）&lt;/code&gt;という非常に単純なものですが、９マス将棋ならこの程度の評価関数で十分だと言えるでしょう。&lt;/p&gt;

&lt;h3 id=&quot;将棋盤面初期配置の表示&quot;&gt;将棋盤面（初期配置）の表示&lt;/h3&gt;
&lt;p&gt;　以下の表のように先手が大文字、後手が小文字のアルファベットで将棋の駒を表現します。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;駒の種類 \ 表記&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　先手（後手）　　&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;成り駒&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　先手（後手）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;玉（王）&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O(o)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;飛　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;H(h)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;竜&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;R(r)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;角　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;M(m)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;馬&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;U(u)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;金　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X(x)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;銀　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;G(g)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;成銀&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;N(n)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;桂　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;K(k)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;成桂&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;E(e)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;香　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Y(y)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;成香&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;S(s)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;歩　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F(f)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;と金&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;T(t)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/arrange21.png&quot; alt=&quot;初期配置　例２&quot; title=&quot;初期配置　例２&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　上記の配置は&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;github&lt;/a&gt;に置いてあるgame.coffeeの初期配置です。githubからソースを取得した後、コンソール画面で&lt;code&gt;coffee game.coffee&lt;/code&gt;と打てば以下のように対局が進行するはずです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;coffee game.coffee
x
 3 2 1
| | |o|1
| |f| |2
|O| | |3
H
x
 3 2 1
|H| |o|1
| |f| |2
|O| | |3

x
 3 2 1
|H| | |1
| |f|o|2
|O| | |3

x
 3 2 1
|H| | |1
|O|f|o|2
| | | |3


 3 2 1
|H| | |1
|O|f|o|2
|x| | |3


 3 2 1
|H| | |1
| |f|o|2
|O| | |3
X

 3 2 1
|H| | |1
| | |o|2
|O|t| |3
X

 3 2 1
|H| | |1
|O| |o|2
| |t| |3
X

 3 2 1
|H| | |1
|O|t|o|2
| | | |3
X
Second Win
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　これじゃぁ分かりにくいという方も多いと思いますがすぐ慣れます&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;。それか、ある程度結論が得られたら初期配置のコードをgameGui.coffeeに移してトランスパイル（&lt;code&gt;webpack&lt;/code&gt;とコマンドを打つだけです）してブラウザで確認するのもいいかもしれません。但し、ブラウザであまり深読みさせると応答しなくなる可能性があります。&lt;/p&gt;

&lt;h3 id=&quot;詰みが見つからなければ最善手は当てにならない&quot;&gt;詰みが見つからなければ、最善手は当てにならない&lt;/h3&gt;
&lt;p&gt;　局面の先読みメソッド（Player.think）の戻り値は&lt;code&gt;[駒オブジェクト, 座標（筋、段）, 評価値, 成（不成）, 次善手情報]&lt;/code&gt;となっているので&lt;code&gt;temp = first.think(b, second, i, Const.MAX_VALUE)&lt;/code&gt;と呼び出した場合&lt;code&gt;temp[2]&lt;/code&gt;に評価値が入っています。temp[2]に最大値（50000）か最小値（-50000）が入っていれば勝ち（あるいは負け）を読み切った（詰みを発見した）ということです。前述の単純な静的評価関数によって指し手を選んだだけなのか、詰みを読み切った上でその手を選んだのかはここで判断出来ます。&lt;br /&gt;
　例えば上記の例題の場合、「３一飛、１二玉、３二玉、３三金、同玉、２三歩成、３二玉、２二と」と進行していますが、&lt;code&gt;depth = 7&lt;/code&gt;で実行すると３一飛と打たれた後の後手番での先読みメソッドの戻り値を見ると、１二玉が最善だと返してきますが、評価値は-18（後手やや有利）になっています。１二玉と指せばやや有利になりますよと言っているだけで、ＡＩは後手の勝ちだとはわかっていません。しかし、&lt;code&gt;depth = 8&lt;/code&gt;にすると１二玉が最善手で評価値も-50000（後手勝ち）と返してきます。初手３一飛と打たれた時に後手の立場で考えて自分の指し手から数えると「１二玉、３二玉、３三金、同玉、２三歩成、３二玉、２二と」までの７手詰めですので、９手先まで読まないと詰みが分からないはず（&lt;code&gt;depth = 8&lt;/code&gt;は９手読み）ですので辻褄が合います。このように詰みを発見した上での最善手と、単なる評価関数による最善手は意味合いが全然違うので注意が必要です。詰みがない場合の最善手というのは読みの深さを変えたら変わる可能性があるのに対して、詰み発見後の最善手は絶対不変&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;の正解手です。この辺の事情は有名な将棋ソフトでも同じことで、読む深さを決めてその手数で詰みが見つからなかった場合は、そのソフトの評価関数を使った最善手というだけの話で客観的に絶対正しい最善手というわけではありません。それでも近年は人間の判断より正確なようですが。&lt;br /&gt;
　また、&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;github&lt;/a&gt;に置いてあるソースは候補手を絞るという作業をしていません（全件探索）ので、&lt;code&gt;depth = 8&lt;/code&gt;をセットしてＡＩの評価値が最大値（50000）または最小値（−50000）が返ってこない場合は７手以内の詰みは存在しないという言い方も出来ます。でも、全件探索ということは読む深さを深くする（depthの値を大きくする）と読む局面の数は指数関数的に増加しますので、いくらハイスペックなPCを使っても十数手しか読めないと思います。どうしても長手数の詰みも確認したいという方は、このソースコードを他のコンパイル言語に移植したりするより、まず将棋盤をビットパターンで表現する手法を取っている他のやり方を探る方がいいと思います。自分はそこまでやろうとは思ってませんけど、&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;このアプリ&lt;/a&gt;をReactNativeに移植したらどれぐらい速度アップ出来るのか興味を持ってます。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;有名な将棋ソフトを９マス将棋に対応させるのはそれなりに大変だと思いますが、どうしても９マス将棋の正解を得たいという人は、あの「どうぶつしょうぎ」を完全解析した人のソースコードを改変する方法があるようです。でも、それもまた簡単ではないと思いますが…。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/software/2018-06-10/droppawncheck&quot;&gt;前回の記事&lt;/a&gt;にも書きましたが玉を取るところまで読まないといけないので、１手詰めの問題を解くには３手読み、３手詰めの問題を解くには５手読みが必要となります。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;これは９×９の本将棋のプログラムでも同じことですが、完全読み切りが出来るのであれば静的評価関数は先手勝ち（＋１）か後手勝ち（−１）かそれ以外（０）の３値を返すだけの単純なものでいいのですが、完全読み切りが出来ないので世のプログラマが苦心して評価関数の出来を競っているわけです。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;詰み手順が複数ある可能性はあります。 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>打ち歩詰め判定は必要なのか</title>
   <link href="https://happyclam.github.io/software/2018-06-10/droppawncheck"/>
   <updated>2018-06-10T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2018-06-10/droppawncheck</id>
   <content type="html">&lt;h3 id=&quot;打ち歩詰め判定メソッド&quot;&gt;打ち歩詰め判定メソッド&lt;/h3&gt;
&lt;p&gt;　以前&lt;a href=&quot;/software/2018-01-27/utifudume&quot;&gt;「打ち歩詰めについて」&lt;/a&gt;という記事で打ち歩詰め判定メソッドのことを書いて、結局それだけではうまくいかず、ＡＩが打ち歩詰めの手を返してきた時は次善手に置き換えて打ち歩詰めを回避したことを書きました。&lt;a href=&quot;/software/2018-01-27/utifudume&quot;&gt;あの記事&lt;/a&gt;を読んだ人はそれでいいのか？と疑問を感じた人がいるかもしれません。中途半端な打ち歩詰め判定メソッドを使っているということは、先読みの最中に打ち歩詰めの手も読んでいるわけです。それには目を瞑るとしても、局面の先読みメソッド（ＡＩ）が打ち歩の王手を返してきた場合に、それが打ち歩詰めの反則手かどうかを確認するために呼び出し元のGUIプログラム側でもう一度先読みメソッドで二手読みをして、打ち歩詰めになっていたら次善手に置き換えるという手法はなんとも泥臭い。幸いなことに打ち歩詰めに関しては一局面に一手しか存在しないためＡＩが返してきた次善手もまた打ち歩詰めだったなんてことはあり得ないので、次善手に置き換えるという方法でも実害はないのですが、コードが煩雑になるのと二手読み分の処理が重複しているのが気になっていました。&lt;br /&gt;
　ということで頑張ってＡＩが打ち歩詰めの指し手を返してこないように修正したので、どうやって打ち歩詰めの手を返してこないようにしているか現状を書いておきます。&lt;/p&gt;

&lt;h3 id=&quot;そもそもａｉに打ち歩詰めさせてはいけないのか&quot;&gt;そもそもＡＩに「打ち歩詰め」させてはいけないのか？&lt;/h3&gt;
&lt;p&gt;　前段の「それには目を瞑るとしても」という文に「瞑っちゃダメだろ」とツッコミ入れた方いると思います。そういう人に聞いていただきたいのですが、私も&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;３三将棋アプリ&lt;/a&gt;を作り始めた頃は、事前に反則となる手は指さないようにしなければいけないと思って作り始めました。「二歩」という反則手と同じく「打ち歩詰め」も事前にチェックして、その手を指させないようにしなければいけないと思って作っていたのです&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;が、ある時デバッグの最中にＡＩが自玉に掛けられている王手を無視して相手玉に王手をかけている局面があることに気づいて、「そう言えば王手放置の対策は何もしてなかったなぁ、これはまずいんじゃないか？」と思ってすぐに王手放置チェックを組み入れたのですが、王手放置をさせないようにしたＡＩは単に遅くなっただけで強さは変わりませんでした（自前のテストケースでの確認）。局面の先読みをする過程で王手放置を許したとしても、その次の一手で王が取られるので静的評価は負けの評価（先手は最小値、後手は最大値）になります。だから、特に何もしなくてもＡＩ側が王手放置の指し手を選択して返してくることはありません。つまり局面を読み進める際にわざわざ駒の利きをチェックして王手放置させないようにしても、コスト（一手毎に駒の利き情報を更新するコスト）に見合った効果はないということだと思います&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。ということで&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;３三将棋アプリ&lt;/a&gt;のＡＩでは、二歩は事前に指させないようにチェックしています（コストが軽微なので）が、王手放置対策は特にしていません。もちろんユーザー側の指し手に関しては二歩も王手放置もチェックしています。&lt;br /&gt;
　では「打ち歩詰め」に関してはどうでしょうか、「王手放置」は一手分読めば負けとわかりますが「打ち歩詰め」は二手分読まないと反則だと判定出来ない&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;のでちょっと事情が違ってきます。でも「二歩」も「王手放置」も「打ち歩詰め」も事前に反則手を指させないようにする方法（事前チェック）と反則手を指した場合に負けの評価を与える方法（事後チェック）の二つのやり方があるということです。どちらのチェック方法を採っても同じ結果が得られるわけですから、大事なのは実行速度を上げるためにどこにコストをかけるかということです。&lt;br /&gt;
　この好きに指させて事後に評価するという考え方は、アプリを機械学習型のＡＩに変えるときにも大事なことだと思います。&lt;/p&gt;

&lt;h3 id=&quot;打ち歩詰め判定メソッドは使わないようにしてみた&quot;&gt;打ち歩詰め判定メソッドは使わないようにしてみた&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2018-01-27/utifudume&quot;&gt;前回の記事&lt;/a&gt;で打ち歩詰め判定をするために必要な条件を３つ程列挙しましたが、一番簡単な定義は「打ち歩による王手で詰んだらそれが打ち歩詰め」ってことです。この「詰んだら」の「だら」が曲者で、詰んでるかどうかをソフトで判定するのが面倒なわけですが、とりあえず&lt;a href=&quot;/software/2018-01-27/utifudume&quot;&gt;前回の記事&lt;/a&gt;で書いたような、こう言う条件を満たしたら打ち歩詰めになるという条件を細かく列挙するのは止めて、「打ち歩による王手で詰んだらそれが打ち歩詰め」という判定方法でまずは実現してみました。&lt;br /&gt;
　先手用のPlayerオブジェクトと後手用のPlayerオブジェクトを生成して、同じPlayer.thinkメソッドを再帰呼び出し（相互再帰）してゲーム木を辿っていくのですが、その本流ともいうべき局面のツリー構造（木構造）を辿っていく過程で「打ち歩による王手」が現れたら別経路の支流に寄り道してまた本流に戻るというやり方です。図にすると以下のような感じです（クリックで拡大）。&lt;/p&gt;

&lt;div style=&quot;width:600px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/utifudume.png&quot;&gt;&lt;img src=&quot;/images/utifudume.png&quot; alt=&quot;ゲーム木 - 打ち歩詰め判定&quot; title=&quot;ゲーム木 - 打ち歩詰め判定&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　上の図は四角（□）の箱が一局面分、実線が先読みの本流、破線が打ち歩詰めチェックのためだけの支流で、四手目まで先読みをする場合を表しています。打ち歩による王手の場合だけ、その手が打ち歩詰めにならないか二手読みをして事前チェックするという方法です。このやり方で中途半端な打ち歩詰め判定メソッドを使う必要はなくなり、GUI側で指し手を置き換える必要もなくなり、コードもスッキリしたのですが、図を見ても明らかなように読む局面の数が増えてしまいます。打ち歩詰め判定のためだけに打ち歩の王手の時は毎回二手読みをするというのはかなりのコストです。手元で&lt;code&gt;time mocha test/&lt;/code&gt;と打ってテストスクリプトを走らせてみたところ案の定今までより遅くなっていました。今までは最終的にＡＩが返して来た指し手に対して、打ち歩の王手の場合には打ち歩詰めになっていないかどうか一回だけ問い合わせていたのに対して、このやり方だと毎回二手読みして打ち歩詰めの確認をしているわけですから遅くなって当然です。それに３三将棋だからいいものの、これが本将棋や５五将棋ならさらに遅くなるでしょう。&lt;br /&gt;
　打ち歩詰めチェックのためだけに支流に分岐して先読みをするのではなく、打ち歩による王手が指されたことを次のノードに引数で渡すなりして、本流の流れの中でチェックすべきですが、すべての打ち歩詰めのケースに対応するのは大変そうです&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。打ち歩詰めチェックを組み込んだために効果的な打ち歩による王手を指せなくなっては元も子もありませんし。&lt;/p&gt;

&lt;h3 id=&quot;事前チェックと事後チェックの折衷案&quot;&gt;事前チェックと事後チェックの折衷案&lt;/h3&gt;
&lt;p&gt;　ということで最終的には、中途半端な打ち歩詰め判定メソッドで事前チェックを行い、さらに不足しているチェックを先読みの本流で事後チェックするという方法を採りました。&lt;br /&gt;
　まず、&lt;a href=&quot;/software/2018-01-27/utifudume&quot;&gt;以前の記事&lt;/a&gt;で紹介した打ち歩詰め判定メソッドでやっていることは以下の内容でした。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;打ち歩（持ち駒の歩）による王手かどうか、そうでなければfalseを返す。&lt;/li&gt;
  &lt;li&gt;打たれた歩を玉以外の味方の駒で取ることが出来るかどうか、出来ればfalseを返す。&lt;/li&gt;
  &lt;li&gt;打たれた歩に相手の駒の利きがあるかどうか（玉で取ることができない）を見て、取ることが出来るか、または他の場所に玉が逃げることが出来ればfalseを返す。&lt;/li&gt;
  &lt;li&gt;上記の条件を満たさなければtrueを返す（＝打ち歩詰め）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　これらのチェックはそのまま使用して、このチェックでは不十分なケース（ここでは「特殊な打ち歩詰め」と言っておきます）については先読みの過程で事後チェック（負けの評価値付与）するという方法です。具体的には1.の条件は先読みの過程で行うことにし、打ち歩による王手の場合はその駒の情報を先読みメソッドの引数に渡して、下層のノードに伝えます。そこで王手された打ち歩を玉以外の駒で取った場合に&lt;strong&gt;少なくとも、もう一手先まで読みを進めて&lt;/strong&gt;自玉が取られる状況なら打ち歩詰めだったということで自分が勝ち（打ち歩による王手を掛けた方が負け）という評価値をセットします。&lt;br /&gt;
　以下の局面は&lt;a href=&quot;/software/2018-01-27/utifudume&quot;&gt;以前の記事&lt;/a&gt;で紹介した判定に失敗する「特殊な打ち歩詰め」のケースですが、&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/utifu_sente.png&quot; alt=&quot;打ち歩詰め先手&quot; title=&quot;打ち歩詰め先手&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　この局面で先手が１二歩と打った場合に後手は玉以外の味方の駒（飛車）で同飛と取れるから打ち歩詰めではないと誤った判断をしてしまうのを防止するために、王手で打たれた歩を玉以外の駒（玉で取る場合はチェック済み）で取った場合には、その時点で呼び出す先読みメソッドの戻り値が最大値あるいは最小値だった場合（勝負がついた場合）には−１を掛けて値を反転させる（打ち歩の王手を掛けた方が負け）というやり方です。&lt;strong&gt;打ち歩による王手なら不完全な打ち歩詰め判定メソッドでチェックして、そこで打ち歩詰めと判定されればその手は指さない（事前チェック）、打ち歩詰めでないと判定されてもその手を指した直後（次の階層を読む時）に打ち歩詰めだとわかったら（先読みメソッドの戻り値が最大値か最小値なら）負けの評価値を与える（事後チェック）&lt;/strong&gt;ということです。&lt;br /&gt;
　図にすると以下のような感じです（クリックで拡大）。&lt;/p&gt;

&lt;div style=&quot;width:600px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/utifudume_new.png&quot;&gt;&lt;img src=&quot;/images/utifudume_new.png&quot; alt=&quot;ゲーム木 - 打ち歩詰め判定2&quot; title=&quot;ゲーム木 - 打ち歩詰め判定2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　先読みの支流に分岐して戻ってくるという無駄な読みが無いため、先ほどの図より読む局面の数が減ったのは明らかです。注意しないといけないのは、局面の先読みをする場合に何手先まで読むかの制限値を指定するのですが、図のように四手目まで読むと指定したとしても四手目で打ち歩による王手が指された場合には制限値を無視して少なくとも二手先（打ち歩を取った後にプラス一手）まで読むようにすることです。これでようやく従来のやり方より実行速度を速くすることが出来、GUI側で打ち歩詰めの再チェックをすることもなくなったので、僅かですがレスポンスも改善しました（Version1.0.0.8）。&lt;br /&gt;
　今回の修正のために歩の手筋だけのテストコードを&lt;a href=&quot;https://github.com/mochajs/mocha&quot;&gt;mocha&lt;/a&gt;でたくさん書きましたが、こういった混みいったリファクタリング作業はTDD（テスト駆動開発）じゃないとやってられないですね&lt;img class=&quot;emoji&quot; title=&quot;smile&quot; alt=&quot;smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;一手詰めを解くためには三手読みが必要&quot;&gt;一手詰めを解くためには三手読みが必要&lt;/h3&gt;
&lt;p&gt;　このブログの記事でよく◯◯手読みという表現を使いますが、読みの深さと詰み手数は違うので念のため書いておきます。自分のアプリだけでなく有名どころの将棋ソフトも多分事情は同じだと思います&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;が、こういう条件とこういう条件を満たせば詰みと判定するより、先手あるいは後手の一方に王将が二つある状態になればゲーム終了（＝詰み）と判定していることが多いと思います&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;。だから詰みの局面からさらに二手分先読みをしないとＡＩには詰んだかどうか判断できません。&lt;br /&gt;
　ということで一手詰めの詰将棋を解くには三手読みが必要で、三手詰の詰将棋を解くには五手読みが必要です。私のブログの記事やアプリの説明で「◯◯手読みしてます」と表現している場合、◯◯手詰めの詰将棋が解けるというわけではないので誤解のないようにお願いします。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/software/2018-01-27/utifudume&quot;&gt;以前の記事&lt;/a&gt;でも「打ち歩詰めチェックを省略するわけにはいきません」なんて自分で書いています。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;これは３三将棋の場合だけで本将棋だと結果が変わってくるかもしれません。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;ＡＩはどちらかの玉が取られるまでゲーム終了とわからないので、詰みの局面から二手進めてみないことには打ち歩詰めかどうか判断できない。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;「打ち歩詰め」に比べて「王手放置」なら一手読むだけでいいので先読みの本流の中で事後チェック（王手放置していたら負けの評価値を付加）するのは簡単です。 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;そもそも有名どころの将棋ソフトはビットパターンで将棋盤を表現しているらしいので、単なる配列データで将棋盤データを表現している自分のアプリと比べたら速度的には勝負になりませんが…。 &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;もしかして高速な詰み判定ルーチンを使ってるかもしれませんが、「玉が取られたら負け」とするより簡潔な評価関数はないでしょう。対戦型のボードゲームソフトでは静的評価関数をいかに軽くするかが速度アップの決め手なので、自分のアプリでは詰み判定ルーチンは用意せずに玉が取られたかどうか（先手・後手の一方に玉が二枚ある）で勝ち・負けを判定しています。 &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>「９マス将棋の本」買ってみました</title>
   <link href="https://happyclam.github.io/project/2018-04-22/9masushogi"/>
   <updated>2018-04-22T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2018-04-22/9masushogi</id>
   <content type="html">&lt;h3 id=&quot;３三将棋アプリで入門書の誤りを見つけた&quot;&gt;「３三将棋」アプリで入門書の誤りを見つけた&lt;/h3&gt;
&lt;p&gt;　自作の&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;「３三将棋」アプリ&lt;/a&gt;の開発も落ち着いてきたので放置していたのですが、小さなバグを見つけたのでどうせ新しいバージョンをリリースするなら、初期配置パターンを何種類か追加しようと思い、参考にするため&lt;a href=&quot;https://www.amazon.co.jp/９マス将棋の本-幻冬舎単行本-青野照市-ebook/dp/B072XCDPGZ/ref=tmm_kin_swatch_0?_encoding=UTF8&amp;amp;qid=1524311385&amp;amp;sr=1-1&quot;&gt;「９マス将棋の本 (幻冬舎単行本) Kindle版」&lt;/a&gt;を買いました&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;a href=&quot;https://www.amazon.co.jp/9マス将棋-バラエティ-青野照市/dp/4344978757/ref=sr_1_2?s=books&amp;amp;ie=UTF8&amp;amp;qid=1524311385&amp;amp;sr=1-2&amp;amp;keywords=９マス将棋&quot;&gt;「９マス将棋」のゲーム本体&lt;/a&gt;は既に持っていて、そこで紹介されている初期配置パターンは開発時のテストにも使用していました。&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;「３三将棋」アプリ&lt;/a&gt;に用意している初期配置パターンはこの本に載っているものやTwitterで見かけたもの、自分で考えたものなどいろいろです&lt;sup id=&quot;fnref:1:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。今回も面白い配置パターンを探すために購入したのですが、読み進めていくと思わぬ発見がありました&lt;img class=&quot;emoji&quot; title=&quot;smile&quot; alt=&quot;smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;先手が勝てないことはない&quot;&gt;「先手が勝てない」ことはない&lt;/h3&gt;
&lt;p&gt;　下の初期配置は&lt;a href=&quot;https://www.amazon.co.jp/９マス将棋の本-幻冬舎単行本-青野照市-ebook/dp/B072XCDPGZ/ref=tmm_kin_swatch_0?_encoding=UTF8&amp;amp;qid=1524311385&amp;amp;sr=1-1&quot;&gt;「９マス将棋の本 (幻冬舎単行本) Kindle版」&lt;/a&gt;の最初の方に、飛車と角を左右対称に置き換えた形で紹介されている配置です。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/9masu_case1.png&quot;&gt;&lt;img src=&quot;/images/9masu_case1.png&quot; alt=&quot;Arrange02&quot; title=&quot;Arrange02&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　本の説明を読んでいるといろんな変化を紹介した後に、この配置は&lt;strong&gt;「結論として、第３図の配置では先手が勝てないということになります。」&lt;/strong&gt;なんて断言されています。本を読んでいるときはふむふむと読んでいたのですが、この配置は既にアプリに用意していたんじゃないか？と思って、アプリを確認してみるとArrange02として左右対称の形で用意していました。ソフトを作り始めた極初期の段階で適当に配置したものだと思います。で、早速AI同士で対戦させてみました。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/9masu_case2.png&quot;&gt;&lt;img src=&quot;/images/9masu_case2.png&quot; alt=&quot;AIレベル＝弱い・普通&quot; title=&quot;AIレベル＝弱い・普通&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　AIレベルを「弱い」か「普通」にセットすると、初形から３二飛、２二歩、３三玉、１二玉、３一飛成、２三歩成で、本の解説通りに後手が勝ちます（上の画像）。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/9masu_case3.png&quot;&gt;&lt;img src=&quot;/images/9masu_case3.png&quot; alt=&quot;AIレベル＝長考・瞑想&quot; title=&quot;AIレベル＝長考・瞑想&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　でもAIレベルを「長考」か「瞑想」モードにすると、初形から３二飛、２二歩、３三玉、１二玉、２三歩、１三玉、２二歩、２二角、２二飛で、先手勝ちになります（上の画像）。&lt;br /&gt;
　本の解説の「先手が勝てない」という結論のどこに問題があるかというと、３二飛、２二歩、３三玉、１二玉と進んだ下の画像の局面で２三に歩を合わせる手が抜けていることです。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/9masu_case4.png&quot;&gt;&lt;img src=&quot;/images/9masu_case4.png&quot; alt=&quot;AIレベル＝長考・瞑想、途中図&quot; title=&quot;AIレベル＝長考・瞑想、途中図&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　上の図のように先手が飛車を成らずに２三に歩を合わせると後手としては２三歩成としたくても飛車の利きがあるので歩を成れません。歩を成った瞬間に玉を素抜かれてしまいます。仕方なく後手は飛車の筋を逃れるために１三玉とかわしますが２二の歩をただで取られて後はどう変化しても先手勝ちです。是非&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;「３三将棋」アプリ&lt;/a&gt;をダウンロードして試してみてください&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　殊更に本の間違いを責める気はありませんが、自作のAIはやはり良く出来ているなぁと嬉しくなりました&lt;img class=&quot;emoji&quot; title=&quot;smile&quot; alt=&quot;smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;。&lt;a href=&quot;https://www.amazon.co.jp/９マス将棋の本-幻冬舎単行本-青野照市-ebook/dp/B072XCDPGZ/ref=tmm_kin_swatch_0?_encoding=UTF8&amp;amp;qid=1524311385&amp;amp;sr=1-1&quot;&gt;「９マス将棋の本 (幻冬舎単行本) Kindle版」&lt;/a&gt;の内容は次の版で改訂されるのでしょうか&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;とりあえずブログネタを提供してくれた将棋連盟に感謝します&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;アタック９マス将棋&quot;&gt;アタック！９マス将棋&lt;/h3&gt;
&lt;p&gt;　上記の例以外にも本の解説が本当かどうか納得出来ないケースがあるのですが、説明するのが大変なのでとりあえず触れずにおきます。それより&lt;a href=&quot;https://www.amazon.co.jp/９マス将棋の本-幻冬舎単行本-青野照市-ebook/dp/B072XCDPGZ/ref=tmm_kin_swatch_0?_encoding=UTF8&amp;amp;qid=1524311385&amp;amp;sr=1-1&quot;&gt;「９マス将棋の本 (幻冬舎単行本) Kindle版」&lt;/a&gt;の最後の方に、解説文はないのですがオリジナルの上級編の問題（「アタック！９マス将棋」）として下記の初期配置が紹介されていたので&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;「３三将棋」アプリ&lt;/a&gt;に解かせてみました。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/9masu_case5.png&quot;&gt;&lt;img src=&quot;/images/9masu_case5.png&quot; alt=&quot;上級編の問題の初期配置&quot; title=&quot;上級編の問題の初期配置&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　問題の趣旨としては先手が勝つ順を見つけてくださいということだと思います。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/meisou_depth7.gif&quot;&gt;&lt;img src=&quot;/images/meisou_depth7.gif&quot; alt=&quot;AIレベル＝瞑想９手読み&quot; title=&quot;AIレベル＝瞑想９手読み&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　上のgifファイルの手順（１三角、同歩成、２二角、１二玉、１三角、同玉、３一歩成、１二角、３二玉、２三角成、２一玉、２二馬までで後手勝ち）のように標準のアプリの設定では「瞑想」モードにしていても読みが足りないようで、正解に辿り着けない（＝先手が勝てない）ようです。&lt;br /&gt;
　そこで、アプリの設定を弄くって特別に深く読むように修正したバージョンで解かせてみたのが以下の手順です。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/meisou_depth9.gif&quot;&gt;&lt;img src=&quot;/images/meisou_depth9.gif&quot; alt=&quot;AIレベル＝瞑想１１手読み&quot; title=&quot;瞑想１１手読み&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　gitファイルの手順は２三玉、２一玉、１三角、同歩成、同玉、３三角、２三歩、３二玉、２二角、同角、同歩、３一玉、２三玉、１二歩、１一角、１三歩成、同玉、３二玉、３三歩、同玉、２一歩成、３二玉、２二角成まで２３手で先手勝ちとなります&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。問題文のヒントに「決着は２０数手後になります。」と書かれていることと合致しますので、おそらくこの手順が正解で&lt;del&gt;間違いない&lt;/del&gt;でしょう。&lt;br /&gt;
　読みを深くすれば正解に辿り着くというのは先読みルーチンにバグがないということでもあるのでとりあえず安心しました。３三将棋（９マス将棋）の場合、盤面が狭いので本将棋のように玉の囲いの固さとか駒の働きとかの局面の静的評価関数の出来はあまり関係なく、いかに深く読むかが大事です。その点詰将棋に似ていますが、必ず王手を続けなければいけないわけでもないので、気づきにくい手を含めて有り得る全ての手を読む力を鍛えるという点では非常にいい教材になると思います。&lt;/p&gt;

&lt;h3 id=&quot;アプリの今後&quot;&gt;アプリの今後&lt;/h3&gt;
&lt;p&gt;　他にも本の解説が正しいとして、解説通りではないけど遠回りしながら本と同じ結果になる変わった手をAIが指すケースとかがあって、いろんな変化を確認する意味で本に紹介されている局面をソフトで試すのも面白いものです。自分は知らなかったのですが、&lt;a href=&quot;https://www.amazon.co.jp/9マス将棋カード-バラエティ-青野照市/dp/4344978943/ref=sr_1_3?s=books&amp;amp;ie=UTF8&amp;amp;qid=1524311385&amp;amp;sr=1-3&amp;amp;keywords=９マス将棋&quot;&gt;9マス将棋カード&lt;/a&gt;という９マス将棋用の初期配置だけを紹介した商品もあるようです。解説の内容は知りませんが、ソフトに指させてみるとどうなるか興味がある人もいるんじゃないでしょうか？本に紹介されている初期配置をそのままアプリに組み込むのも問題ありそうだし&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;、&lt;a href=&quot;https://www.amazon.co.jp/9マス将棋カード-バラエティ-青野照市/dp/4344978943/ref=sr_1_3?s=books&amp;amp;ie=UTF8&amp;amp;qid=1524311385&amp;amp;sr=1-3&amp;amp;keywords=９マス将棋&quot;&gt;こういう商品&lt;/a&gt;が出るのであれば、開発当初予定していたように初期配置を自由に編集出来るような機能もあった方がいいよなぁとは思っています。ユーザーが自由に初期配置を設定出来るのなら何の問題もありません。&lt;br /&gt;
　で、結局どうするか、ソースはいずれ公開するつもりですが、編集機能を追加してからにするか、もうちょっと様子見します。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;自分で考えた配置では、アプリの読みの深さによって結論が変わるものを一つの基準として採用してます。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:1:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;最新版（Version1.0.1.0）でやってみると、「２三玉、２一玉、１三角、同歩成、同玉、３三角、２三歩、１一角成、３一歩成、同玉、２二角、同馬、同歩、１一歩、２三玉、１二角、３三玉、２一角、同歩成、同玉、３二角、１二玉、３一角、２一歩、２三角」までの２５手でした。小さなバグ修正があったので、こちらが正解だと思われます。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;著作権というのは偽物を排除して本当の作者を保護するためのものなので、本の内容を引用する分には問題ないと思ってますが、いろいろ言ってくる人が出てくる可能性はあると思います。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>「５五将棋」アプリリリースしました</title>
   <link href="https://happyclam.github.io/project/2018-03-11/55shogiapp"/>
   <updated>2018-03-11T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2018-03-11/55shogiapp</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi55.io.github.happyclam&quot;&gt;&lt;img src=&quot;/images/ja_badge_web_generic.png&quot; alt=&quot;５五将棋&quot; title=&quot;５五将棋&quot; width=&quot;155&quot; height=&quot;60&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;５五将棋アプリについて&quot;&gt;「５五将棋」アプリについて&lt;/h3&gt;
&lt;p&gt;　現在リリースしている&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;「３三将棋」アプリ&lt;/a&gt;とUI部分以外はほとんど同じソースを使って作った５五将棋アプリです。幾つかの５五将棋アプリと対戦させてみたところ、結構勝ったり負けたりのいい勝負なので機種によっては動作が重いとはいえ、そこそこ楽しめるかもしれません。アプリの仕様は３三将棋アプリとほとんど同じなので&lt;a href=&quot;/project/2018-01-01/33shogiapp&quot;&gt;３三将棋アプリの記事&lt;/a&gt;を見ていただくとして、ここでは３三将棋アプリと違う点について書いておこうと思います。
　&lt;/p&gt;
&lt;h3 id=&quot;５五将棋ならではの仕様桂馬の扱い&quot;&gt;５五将棋ならではの仕様（桂馬の扱い）&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://ja.wikipedia.org/wiki/5五将棋&quot;&gt;本来の５五将棋？&lt;/a&gt;では敵陣一段目（後手は５段目）に駒が進むと駒が成れますが、&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi55.io.github.happyclam&quot;&gt;５五将棋アプリ&lt;/a&gt;では初期配置によって駒が成れる段が変わる仕様にしています。使用する駒に桂馬が含まれている場合に一段目（後手は五段目）でしか駒を成れないとすると不都合が生じるからです。&lt;br /&gt;
　例えば以下の局面は持ち駒の桂馬を２四に打ったところですが、&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/55shogi_ex1.png&quot;&gt;&lt;img src=&quot;/images/55shogi_ex1.png&quot; alt=&quot;桂馬を打った局面&quot; title=&quot;桂馬を打った局面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;打った桂馬が３二に跳ねた場合に、その時点で駒が成れないと次に駒の行き場がなくなってしまいます。通常の将棋で先手の歩が一段目に進んだ場合強制的に「と金」になりますが、それと同じで使用する駒に桂馬がある場合は二段目でも成れるようにする必要があります。そのため&lt;strong&gt;「初期配置に桂馬が含まれている場合は、桂馬だけでなくすべての駒が二段目（後手は四段目）で成れるルールにしています」。&lt;/strong&gt;&lt;br /&gt;
　詳しくないですが、一段目で駒が成れるルールの&lt;a href=&quot;https://ja.wikipedia.org/wiki/5五将棋&quot;&gt;本来の５五将棋&lt;/a&gt;に桂馬が使われていない理由は、もしかしたらこのことが理由かもしれません。たしかに全部で五段しかないのに敵陣が２段を占めるというのもバランスが悪い気がしますので、５五将棋では桂馬は使うべきではないのかもしれません。でも７七将棋ならちょうど良いバランスになるような気がしているので、次は先手が二段目、後手は六段目で成れるルールで７七将棋を作ってみようかと思っています。&lt;/p&gt;

&lt;h3 id=&quot;読みの深さ&quot;&gt;読みの深さ&lt;/h3&gt;
&lt;p&gt;　Version0.9.9.5で読む範囲を変更しました。「弱い」モードは３手読みで全ての手を読みます。「普通」「長考」モードでは、まず３手読みで候補手を１３手に絞った後、その候補手に対して「普通」モードで４手読み、「長考」モードで５手読みをしています。&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;「３三将棋」アプリ&lt;/a&gt;の「長考」モードが９手読み&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;であることを考えると性能が落ちてますが、３三将棋に比べると５五将棋の局面数が飛躍的に増えるためこうなってしまっています&lt;img class=&quot;emoji&quot; title=&quot;sweat&quot; alt=&quot;sweat&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;以前のバージョンは深読みする候補手を６手に絞っていたのですが、持ち駒が豊富な時には一局面で大体３０〜４０手の候補手があるので、たった６手に絞るのはあまりにも無理があると思い直して変更しました&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。「普通」「長考」モードでは候補手を絞って他の手は捨てているのに対して、「弱い」モードではすべての手を読んでいるので、&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi55.io.github.happyclam&quot;&gt;５五将棋アプリ&lt;/a&gt;に関しては「弱い」モードの方がいい手を指す可能性が高いかもしれません。&lt;/p&gt;

&lt;h3 id=&quot;千日手回避&quot;&gt;千日手回避&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;「３三将棋」アプリ&lt;/a&gt;では千日手回避のために特別な処理はしていません。あくまでも私の主観ですが、千日手になるのが当然の成り行きと思えるケースが多いためです&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。しかし&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi55.io.github.happyclam&quot;&gt;５五将棋アプリ&lt;/a&gt;の場合は駒の損得が発生しない序盤の段階で千日手になってしまうケースがあまりにも多いので千日手回避のロジックを組み込んでいます。同じ局面が３回発生した場合にはＡＩの手を次善手（あくまでもアプリのＡＩが次善手と判断しているだけです）を指すようにして、なるべく千日手を回避するようにしています。但し次善手を指していても千日手になることもあるので、絶対千日手を避けるというわけではありません。&lt;/p&gt;

&lt;h3 id=&quot;瞑想モード追加&quot;&gt;瞑想モード追加&lt;/h3&gt;
&lt;p&gt;　Version1.0.0.2で瞑想モードを追加しました。「読みの深さ」のところで説明していますが、「長考」モードでは３手読みで候補手を１３手に絞ってその候補手に対して５手読みを行いますが、「瞑想」モードでは候補手を絞らずに３手読みしたすべての手を評価値でソートした後に５手読みしています。読みの深さは変わっていませんので、詰みを見つけた場合等、枝刈りが効果的に働いて「長考」モードより応答が速くなることもあります。但し、ゲーム終盤に詰みを逃しにくくなったのは確かですが、自分がテストしている限りにおいては「長考」モードより強いかどうかは微妙なところです。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;９手先を読んでいるから９手詰めの詰将棋が解けるかというと、そうではなく７手詰めしか解けません。詰み局面までの手数ではなく、相手の玉を取るところまでの手数を読まないといけないためです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;読みの範囲を広げたことで強くなっているのですが、その分少し遅くなってます&lt;img class=&quot;emoji&quot; title=&quot;sweat&quot; alt=&quot;sweat&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;千日手になって当然に見えると言ってもその局面を迎える前にもっといい手（最善手）を逃していると思われるケースが多いのですが、同一局面の繰り返しが始まってからでは時すでに遅しとなっていて千日手を避けられなくなっているという意味です。この辺りの事情はＡＩの出来の悪さなので仕方がありません。３三将棋の場合は無理に千日手を避けると致命的な悪手になるので敢えてそのままにしています。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>王手放置について</title>
   <link href="https://happyclam.github.io/software/2018-02-17/nocareincheck"/>
   <updated>2018-02-17T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2018-02-17/nocareincheck</id>
   <content type="html">&lt;h3 id=&quot;王手放置が反則だとは知らなかった&quot;&gt;王手放置が反則だとは知らなかった&lt;/h3&gt;
&lt;p&gt;　趣味で長年将棋を指してますが、&lt;a href=&quot;https://www.shogi.or.jp/knowledge/shogi/05.html&quot;&gt;将棋連盟のサイト&lt;/a&gt;で王手放置が反則と規定されているとは知りませんでした、というか深く考えたことがありませんでした。相手が王手を放置したら相手玉を取ればいいだけの話と思っていたし、確か将棋連盟が運営している「将棋倶楽部24」でも、王手放置した段階では反則負けとはならず、投了するか玉が取られたらゲーム終了となっていたと思います。ただ、市販の将棋ソフトやスマホアプリでは王手を放置しようとするとなんらかのメッセージを表示して王手放置をさせないようにしているものが多いと思います。&lt;a href=&quot;https://happyclam.github.io/software/2018-01-27/utifudume&quot;&gt;前回の記事&lt;/a&gt;でも少し触れましたが、将棋が「相手の玉を取ったら終了」ではなく「相手玉を詰ましたら終了」となっているため、王手放置をさせないようにする方がソフト開発時にも整合性を保ちやすいという事情があるようです。&lt;/p&gt;

&lt;h3 id=&quot;規制はできるだけ無い方がいいけどいろいろ問題が&quot;&gt;規制はできるだけ無い方がいいけど、いろいろ問題が…&lt;/h3&gt;
&lt;p&gt;　下のような局面で先手が「勝った」と思い２一歩成りと指して相手に玉を取られて負けてしまうなんてことが将棋覚えたての人にはよくあることだと思います（後手も自分が勝ったと気づかなかったり&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;）。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/hochi1.png&quot; alt=&quot;王手放置１&quot; title=&quot;王手放置１&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　自分の玉に王手がかかることに気づかずにうっかり自分の駒を動かして王手放置をしてしまうことは初心者によくあることだし、自分も将棋覚えた頃はそういうことを相手と一緒に楽しんでました。「王手に気づくなよ、気づくなよ」と念じながら空き王手したりして楽しんでいたものです。だからわざわざ王手放置を禁止する（指せないようにする）必要もないと思ってアプリを作っていたのですが、ルール上「王手放置は反則」というのであれば他のソフトに倣って対応した方がいいのかもと思えてきました。&lt;br /&gt;
　また、王手放置には上記のような大駒の利きをうっかりする場合と、敵駒の利きにわざと玉を移動するようなあからさまな自爆行為もあります。ネット対戦とかで見かけますが、悔し紛れとか嫌がらせのつもりでそういう手を指す人もいるでしょう。でも故意に王手放置をした場合は反則でうっかりミスの場合は許されるなんていうルールはあり得ません。悪意があろうがなかろうが王手放置に違いはなく、特にソフト開発の視点からはどちらも同じ王手放置です。玉を動かして自爆した場合と大駒の利きに入った場合を区別することは出来ますが、玉をぶつけてきたとしても悪意があると断定出来るわけでもないので結局同じように扱うしかないでしょう。&lt;br /&gt;
　もう一点、ソフト側で王手放置出来ないようにすると、本来なら王手放置で反則負けになるはずだったのにソフトに教えてもらって負けずに済んだ（放置せずに済んだ、助言を貰ったのと同じ）という弊害もあります。これは良くないと考えるなら、王手放置は出来るけど王手放置をした時点で反則負けと判定すればいいはずですが、なぜかそういう仕様のソフトは見たことがありません。ソフト相手にそんなに厳格なルールを適用する必要はないという考え方でしょうか？でも、人対人の将棋倶楽部24でも王手放置は出来るけど、その時点で反則負けになるわけではなかったと思います。&lt;br /&gt;
　「余計な規制は必要ない」、「マナー違反出来ないようにして欲しい」、「ソフトが指し手に助言を与えるのはおかしい」、人それぞれの経験値や考え方が違うので、どういう仕様にするか迷いましたがとりあえずよくあるソフトの仕様に倣うことにしました（version0.9.4.0）。この辺りはまだ流動的で今後仕様変更するかもしれません。&lt;/p&gt;

&lt;h3 id=&quot;どうなればゲーム終了かをソフトに教える必要がある&quot;&gt;どうなればゲーム終了かをソフトに教える必要がある&lt;/h3&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/hochi2.png&quot; alt=&quot;王手放置２&quot; title=&quot;王手放置２&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上の局面は３三将棋の初形から２二銀、２一玉（王手放置）と進んだ局面ですが、ここで先手が後手玉を取ればゲーム終了になりますが、取らずに１三歩と打っても下の図のように後手玉が詰み（王手は掛かっていませんが玉が自爆する手しかない状態、次に王手放置せざるを得ない）となります（version0.9.3.0以前）。&lt;/span&gt;&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/hochi3.png&quot; alt=&quot;王手放置３&quot; title=&quot;王手放置３&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;次の例は先手が１三歩ではなく１二歩と打ったケースですが、この場合後手玉は１二に移動出来る余地があるので後手玉は詰みとならずにゲームが継続します（version0.9.3.0以前）。&lt;/span&gt;&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/hochi4.png&quot; alt=&quot;王手放置４&quot; title=&quot;王手放置４&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上の局面は先手の１二歩に対して後手が３二銀と打って先手玉を詰ました局面ですが、手番は先手ですので先手が後手玉を取ればゲーム終了になります（version0.9.3.0以前）。これでいい、玉を取るまで指させればいいじゃないか、と言う人もいると思いますが、某９マス将棋アプリのレビューを読んでいると、「将棋は玉を取るまで指させるもんじゃない」「詰み局面で終了すべき」と言う意見も多く、私も相手玉を取るまでゲームが終わらないことに違和感を感じた一人です。&lt;/span&gt;&lt;br /&gt;
　
ある時は詰み局面（王手は掛かってないけど、王手放置せざるを得ない局面含む）でゲームが終了して、ある時は玉を取るまで終わらないというのはおかしな仕様だと思ったので、とりあえず他の多くのソフトに倣って王手放置は出来ないように対応しました（version0.9.4.0）。&lt;br /&gt;
　普通の将棋盤で遊ぶような感覚で自由に指せる仕様にしようと開発していたのですが、&lt;strong&gt;ソフト側で終了判定をしようとするなら、結局玉を取るまで終わらないようにするしかなさそうです。&lt;/strong&gt;でも、それでは長年将棋を指している人からすると、玉を取るまで終わらないのは将棋じゃないと感じる気持ちもわかります。また、詰み判定（終了判定）はソフトがするのに、打ち歩詰めと王手放置の時だけソフトが助言してくれるというのも一貫性がないような気がするので、いっそのこと二歩も合わせて打ち歩詰め、王手放置はその瞬間に反則負けとする仕様もありかなと思ったりもします。&lt;/p&gt;

&lt;h3 id=&quot;ルールを厳格に適用すると&quot;&gt;ルールを厳格に適用すると…&lt;/h3&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/foulplay1.png&quot; alt=&quot;反則１&quot; title=&quot;反則１&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上の局面は後手が２一桂と王手を掛けたところです。先手がここで持ち駒の歩を３二に打った場合「二歩」であり「王手放置」であり「打ち歩詰め」でもあります。&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/foulplay2.png&quot; alt=&quot;反則２&quot; title=&quot;反則２&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上の局面は後手が２二角と王手を掛けたところです。先手がここで持ち駒の歩を３一に打った場合「二歩」であり「王手放置」であり「行き場の無い駒を打つ」という反則でもあります。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　おそらく反則の優先順位は聞いた事ないし規定されていないでしょう。反則手を指した段階で反則負けとする場合、ソフトのメッセージにはいったいどのように出力すればいいのでしょうか？それに行き場のない駒を打った時も反則になるわけですから、それを突き詰めていくと、持ち駒を選択した後に盤面の外をタップした時も反則になるのではないのか？という意見も出てくるかもしれません（さすがにそれはないか&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;）。&lt;br /&gt;
　また、反則を厳格に適用すると勝負を続けたかったのにうっかりクリックミス（タップミス）しただけで中断されるのは嫌だという意見があるかもしれませんが、どうせマイナーなアプリだし、オリジナリティを出すためにもルールに厳格な「初心者に厳しい将棋アプリ」を目指すかもしれません。&lt;/p&gt;

&lt;h3 id=&quot;開発者視点での王手放置&quot;&gt;開発者視点での王手放置&lt;/h3&gt;
&lt;p&gt;　反則手のチェックをするのは一見業務システムの入力データのチェックをする場合と似ているように思えます。反則手は事前にチェックしてその手を指させないようにしようと考えがちですが、&lt;a href=&quot;https://happyclam.github.io/software/2018-01-27/utifudume&quot;&gt;前回の記事&lt;/a&gt;で書いたように、打ち歩詰めを事前にチェックしようとして苦労しました。でも、打ち歩詰めも王手放置も一旦指させてから反則の場合には元に戻すと言うやり方の方が、無駄なコードを書かなくていいことがわかってきました。&lt;br /&gt;
　「一旦指させてから元に戻す」という作業は局面の先読みをする過程でやっていることで、局面の先読みの過程でも反則手を指させないようにチェックするのではなく、&lt;del&gt;敢えて反則手を指させてその局面の評価を「負け」と評価する方がコードもすっきりして、&lt;/del&gt;局面の枝刈りが効率的になり実行速度も速くなるようなので、その辺りのことを書こうと思っていたのですが記事が長くなってきたので次回にまわすことにします。&lt;/p&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>打ち歩詰めについて</title>
   <link href="https://happyclam.github.io/software/2018-01-27/utifudume"/>
   <updated>2018-01-27T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2018-01-27/utifudume</id>
   <content type="html">&lt;h3 id=&quot;話題の９マス将棋&quot;&gt;話題の９マス将棋&lt;/h3&gt;
&lt;p&gt;　テレビで９マス将棋が取り上げられたことでTwitterで将棋初心者の呟きをよく見かけます。その中でも打ち歩詰めというルールを知らない人のツイートを何回か見かけたので、&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;３三将棋アプリ&lt;/a&gt;を開発した側の視点で「打ち歩詰め」について書いてみようと思います。&lt;/p&gt;

&lt;h3 id=&quot;打ち歩詰め判定&quot;&gt;打ち歩詰め判定&lt;/h3&gt;
&lt;p&gt;　手を指す前に打ち歩詰めになるかどうかを判定する（打ち歩詰めならtrue、そうじゃなければfalseを返す）のですが、そのメソッド内でやっていることは以下のようなチェックです。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;打ち歩（持ち駒の歩）による王手かどうか、そうでなければfalseを返す。&lt;/li&gt;
  &lt;li&gt;打たれた歩を玉以外の味方の駒で取ることが出来るかどうか、出来ればfalseを返す。&lt;/li&gt;
  &lt;li&gt;打たれた歩に相手の駒の利きがあるかどうか（玉で取ることができない）を見て、取ることが出来るか、または他の場所に玉が逃げることが出来ればfalseを返す。&lt;/li&gt;
  &lt;li&gt;上記の条件を満たさなければtrueを返す（＝打ち歩詰め）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　局面を読み進めていく毎に歩を打つ場合は常に一手毎にこのチェックをしなければならないので結構重たい処理です。&lt;/p&gt;

&lt;h3 id=&quot;上記の判定では不十分なケース&quot;&gt;上記の判定では不十分なケース&lt;/h3&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/utifu_gote.png&quot; alt=&quot;打ち歩詰め後手&quot; title=&quot;打ち歩詰め後手&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上の局面で後手が３二に歩を打つと打ち歩詰めですが、上記の打ち歩詰め判定では相手の駒（２三の角）で打ち歩を取ることが出来るので打ち歩詰めではないと判定してしまいます。後手の飛車の利きが相手玉を睨んでいるにも関わらずです。&lt;/span&gt;&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/utifu_sente.png&quot; alt=&quot;打ち歩詰め先手&quot; title=&quot;打ち歩詰め先手&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;次の例では先手が１二に歩を打つと角が利いているので後手は２二の飛車でその歩を取ることが出来ません。ゆえにこの「１二歩打ち」も打ち歩詰めですが、上記の打ち歩詰め判定ロジックでは飛車で歩が取れるから打ち歩詰めではないと判定してしまいます。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　味方の飛車や角の筋に相手玉がいるときは上記の打ち歩詰め判定ではうまくいかないことがわかります（同じ飛び道具でも香車の場合は歩と同じ方向にしか動けないので問題なし）。だからと言って、「飛車や角の利き筋に相手玉がいるときは〜」なんていう条件を追加していては、どんどん打ち歩詰め判定が複雑で重たい処理になるので避けたいところです。&lt;br /&gt;
　いっそのこと１手ごとに打ち歩詰めかどうか判定せずに、「持ち駒の歩を打って詰んだとき」が打ち歩詰めなので、局面の先読みをする過程では打ち歩詰め判定を省略して先読みし、直近の一手が打ち歩の時だけ打ち歩詰めチェックするという方法も考えられますが、３三将棋の場合は盤面が狭いため先読みする過程で打ち歩詰めの局面が頻発するので打ち歩詰めチェックを省略するわけにはいきません&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
　また「打ち歩詰め判定」ではなく「詰み判定」のメソッドを用意して、一手毎に「打ち歩による詰みであればその手を避ける」とすればいいかもしれませんが、詰み局面かどうかを判定するのは打ち歩詰めかどうかを判定するより面倒そう？なので&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;自分のアプリ&lt;/a&gt;では詰み判定ルーチンは使っていません&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。局面の静的評価値を計算する時に先手側に玉が２枚あれば最大値（50000）後手側に玉が２枚あれば最小値（−50000）を返してゲームが終了したかどうかを判定しています。人間の感覚だと、詰みの局面でゲーム終了するのが当たり前とされている将棋ですが、ソフトで判定する場合は「相手の玉を取った時にゲーム終了」とするのが一番簡単で軽い処理で済むという事情があります&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
　結局&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;自分のアプリ&lt;/a&gt;では、最善手を検索する際に常に次善手を保存する（最善手を繰り下げる）ようにしておいて、ＡＩが最終的に打ち歩詰めを選んでしまった場合は、次善手を実際の指し手に変えて打ち歩詰めを回避するようにしました&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&quot;まだ問題があった&quot;&gt;まだ問題があった&lt;/h3&gt;
&lt;p&gt;　ＡＩの思考ルーチンを最善手と次善手の二つの候補手を返すようにしたのでとりあえず打ち歩詰めをしてしまうというバグは直ったと安心してアプリをリリースしていたのですが、人間側が指す場合は上記の打ち歩詰め判定のロジックを使っていたため、飛車や角の筋に相手玉がいる場合に人間側の打ち歩詰めを許してしまうケースが発生していたと思われます（ver0.9.1以前）。&lt;br /&gt;
　リリースしてから２週間以上経ってそのことに気がついて、人間が歩を打つ手を選んだ場合は、そこから二手読みをして勝負が着いたら打ち歩詰めと判定して局面を元に戻して指し手をキャンセルさせるという、やや強引なやり方ではありますが打ち歩詰めをさせないようにしました。古いバージョンをお使いの方は、バージョン0.9.1.1以降のものにアプリを更新していただきたいと思います。それにしても自分が動作確認する時は打ち歩詰めなんてしないし、ＡＩの出来ばかり気にして人間側が打ち歩詰めをしてしまうことなんてすっかり頭の中から抜け落ちてました&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　最新の将棋ソフトではおそらくBonanza由来のソース（データ構造含む）とかライブラリを使ってるのでしょうけど、自前で打ち歩詰め対策を実装するのは結構面倒だったというお話でした。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;昔、本将棋のプログラムを作ったことがあって短時間で深く読むようにするために打ち歩詰めチェックを省いてテストしたことがありますが、本将棋の場合だと打ち歩詰めチェックを省いたからといってそれほど違和感のある指し手を選ぶことはありませんでした。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;本将棋ならほぼありえないのですが３三将棋の場合は「詰みではないが指す手が無い（玉が自殺する手しか無い）」時がよくあるので詰み判定ルーチンがあまり役に立たないと思います。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;アプリでは相手玉を取るまで指さなくても詰みの局面になればゲーム終了とさせていますが、詰み判定ルーチンを使わずにどうやって詰み局面かどうか判断させているかというと、ＡＩに二手読みをさせて最善手を選んでも負けになる（自玉が取られる）ならゲーム終了にするという方法で実現しています。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;これは暫定的な解決方法で、最新版のアプリでは上記の打ち歩詰め判定メソッドは使用しない方法で解決しています。 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>「３三将棋」アプリリリースしました</title>
   <link href="https://happyclam.github.io/project/2018-01-01/33shogiapp"/>
   <updated>2018-01-01T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2018-01-01/33shogiapp</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=shogi33.io.github.happyclam&quot;&gt;&lt;img src=&quot;/images/ja_badge_web_generic.png&quot; alt=&quot;３三将棋&quot; title=&quot;３三将棋&quot; width=&quot;155&quot; height=&quot;60&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;３三将棋について&quot;&gt;「３三将棋」について&lt;/h3&gt;
&lt;p&gt;　以前にも&lt;a href=&quot;/programming/2016-07-23/33shogi&quot;&gt;「３三将棋」に関する記事&lt;/a&gt;を書きましたが、実際に作ってみました。最初はゲーム開始時の初期盤面をユーザーが自由に編集出来るようなものにしようと考えていたのですが、そこまで開発コストをかけても実際に自分で初期盤面を試行錯誤しながら作って遊んでみようと思うユーザーがそれほどいるとは思えなかったので、とりあえず１５パターンの初期盤面を用意しました。今後パターンを増やしていくつもりです。&lt;/p&gt;

&lt;h3 id=&quot;ルール&quot;&gt;ルール&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;駒の動きは将棋と同じです。&lt;/li&gt;
  &lt;li&gt;打ち歩詰め、二歩は禁止です。&lt;/li&gt;
  &lt;li&gt;先手は一段目、後手は三段目に駒を移動すると成ることができます。&lt;/li&gt;
  &lt;li&gt;同一局面（手番も同じ）が４回現れると千日手でゲーム終了としています。&lt;/li&gt;
  &lt;li&gt;行き場の無い駒は打てません（桂馬を二段目に打ったり、先手が歩を一段目に打ったり）&lt;/li&gt;
  &lt;li&gt;王手放置は出来ません（王の自殺手も不可）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;駒の動き&quot;&gt;駒の動き&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;駒の種類&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;表　&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　裏（成り駒） Promoted&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;玉（王） King&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_ou.png&quot; alt=&quot;玉&quot; title=&quot;玉&quot; /&gt; gyoku(ou)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;飛　     Rook&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_hi.png&quot; alt=&quot;飛&quot; title=&quot;飛&quot; /&gt; hi&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_ry.png&quot; alt=&quot;竜&quot; title=&quot;竜&quot; /&gt;  ryu&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;角　     Bishop&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_ka.png&quot; alt=&quot;角&quot; title=&quot;角&quot; /&gt; kaku&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_um.png&quot; alt=&quot;馬&quot; title=&quot;馬&quot; /&gt; uma&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;金　     Gold&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_ki.png&quot; alt=&quot;金&quot; title=&quot;金&quot; /&gt; kin&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;銀　     Silver&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_gi.png&quot; alt=&quot;銀&quot; title=&quot;銀&quot; /&gt; gin&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_ng.png&quot; alt=&quot;飛&quot; title=&quot;成銀&quot; /&gt; nari-gin&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;桂　     Knight&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_ke.png&quot; alt=&quot;桂&quot; title=&quot;桂&quot; /&gt; kei&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_nk.png&quot; alt=&quot;飛&quot; title=&quot;成桂&quot; /&gt; nari-kei&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;香　     Lance&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_ky.png&quot; alt=&quot;香&quot; title=&quot;香&quot; /&gt; kyo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_ny.png&quot; alt=&quot;飛&quot; title=&quot;成香&quot; /&gt; nari-kyo&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;歩　     Pawn&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_fu.png&quot; alt=&quot;歩&quot; title=&quot;歩&quot; /&gt; fu&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/move_to.png&quot; alt=&quot;飛&quot; title=&quot;と&quot; /&gt; tokin&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;対局画面&quot;&gt;対局画面&lt;/h3&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/33shogi_battle.png&quot; alt=&quot;対戦画面&quot; title=&quot;対戦画面&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ＡＩ同士の対戦の時だけ局面の評価値を表示するようにしています。左上の数値は手数です。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;閲覧画面&quot;&gt;閲覧画面&lt;/h3&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/33shogi_view.png&quot; alt=&quot;閲覧画面&quot; title=&quot;閲覧画面&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;対局が終了するか、対局を中断すると閲覧画面に切り替わって、初手からの手順を確認することが出来ます。&lt;/span&gt;
&lt;span&gt;Version0.9.9.0から中断後レベルや対局者を変更して再開することが出来ます&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;メニュー&quot;&gt;メニュー&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;先手・後手&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span&gt;Version1.0.1.8からＡＩ同士の対戦時も詰みまで指すように変更しました。&lt;/span&gt;&lt;br /&gt;
&lt;span&gt;Version0.9.9.0から、中断後にゲームを再開する機能をつけました。&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/33shogi_player.png&quot; alt=&quot;Menu - 先手・後手&quot; title=&quot;Menu - 先手・後手&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;ＡＩレベル&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span&gt;駒に重みを設定してその合計値で局面を評価する評価関数を使い先読みを行う、よくある思考ルーチン（MIN-MAX法＋αβ法による全件探索）です。JavaScript製ということもあり、&lt;del&gt;非常に遅いのであまり深く読めません。&lt;/del&gt;今後、候補手を事前に絞るなどして速度アップをしていく予定です。&lt;/span&gt;&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/33shogi_ailevel.png&quot; alt=&quot;Menu - ＡＩレベル&quot; title=&quot;Menu - ＡＩレベル&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;長考モード：&lt;br /&gt;
　Version0.9.3.0から長考モードが使えます。長考モードは４手読みで候補手を上位５手までに絞って、その５手に関して９手読みをするという仕様になっています。思考時間はリリース当初から改善していますが、古い機種では遅くて使用に堪えないかもしれません。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Version&lt;/th&gt;
      &lt;th&gt;ＡＩレベル（普通）&lt;/th&gt;
      &lt;th&gt;ＡＩレベル（長考）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0.9.1.2&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;/images/v0912-ordinal.gif&quot; alt=&quot;Version0.9.1.2レベル普通&quot; title=&quot;Version0.9.1.2 ＡＩレベル（普通）&quot; /&gt; 経過時間：30532ミリ秒&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;/images/v0912-tyokoh.gif&quot; alt=&quot;Version0.9.1.2レベル長考&quot; title=&quot;Version0.9.1.2 ＡＩレベル（長考）&quot; /&gt; 経過時間：153052ミリ秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.9.4.6&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;/images/v0946-ordinal.gif&quot; alt=&quot;Version0.9.4.6レベル普通&quot; title=&quot;Version0.9.4.6 ＡＩレベル（普通）&quot; /&gt; 経過時間：29258ミリ秒&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;/images/v0946-tyokoh.gif&quot; alt=&quot;Version0.9.4.6レベル長考&quot; title=&quot;Version0.9.4.6 ＡＩレベル（長考）&quot; /&gt; 経過時間：87109ミリ秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.9.8.0&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;/images/v0980-ordinal.gif&quot; alt=&quot;Version0.9.8.0レベル普通&quot; title=&quot;Version0.9.8.0 ＡＩレベル（普通）&quot; /&gt; 経過時間：25838ミリ秒&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;/images/v0980-tyokoh.gif&quot; alt=&quot;Version0.9.8.0レベル長考&quot; title=&quot;Version0.9.8.0 ＡＩレベル（長考）&quot; /&gt; 経過時間：51774ミリ秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.0.0.8&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;/images/v1008ordinal.gif&quot; alt=&quot;Version1.0.0.8レベル普通&quot; title=&quot;Version1.0.0.8 ＡＩレベル（普通）&quot; /&gt; 経過時間：25732ミリ秒&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;/images/v1008tyokoh.gif&quot; alt=&quot;Version1.0.0.8レベル長考&quot; title=&quot;Version1.0.0.8 ＡＩレベル（長考）&quot; /&gt; 経過時間：49646ミリ秒&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;・長考モードにランダム選択を導入（Version0.9.7.0）:&lt;br /&gt;
　長考モードは最初に４手読みをした結果から候補手を５手に絞っているので、その候補手を絞る段階で最善手が候補手から漏れてしまうこともあります。特に４手読みの結果上位５位、６位、７位の３手の評価値が全く同じであっても常に６位、７位の手は捨てられるのがもったいないので、評価値が同じだった場合はランダムに指し手を選ぶようにしました。あくまでも４手読み時の評価値が同じだった場合だけなので、指し手に大きな変化はありませんが長考モードに関しては常に同じ手を指すとは限らなくなりました。&lt;/p&gt;

&lt;p&gt;・パフォーマンス大幅改善（Version0.9.8.0）:&lt;br /&gt;
　前回のチューニング（Version0.9.4.6）はプログラムコードを速度重視のものに置き換える方法、今回のチューニング（Version0.9.8.0）は局面の枝刈りの無駄を省くアルゴリズムの修正によるものです&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;・三手以内の詰み&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;は逃さないように変更（Version1.0.0.0）:&lt;br /&gt;
　「弱い」モードの時も含めて全てのモードで三手以内の詰みは逃さないようにしました。勝ちを読みきった後でも無駄に手数を伸ばすことがあったので、全てのモードで三手以内の詰みがあるときは常にその手順を選択するように変更しました。&lt;br /&gt;
　今までから「瞑想」モードでは五手以内の詰みを逃さないようになっていますが、最初に候補手を絞る段階で好手を逃す可能性があるため、五手詰め以上に関しては絶対逃さないとは言い切れません。&lt;/p&gt;

&lt;p&gt;瞑想モード:&lt;br /&gt;
　Version0.9.9.0から瞑想モード追加しました。長考モードより一手深く読みます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;駒の重み：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;駒の種類 \ 重み&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　表（不成）　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　裏（成り駒）　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;持ち駒&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;玉（王）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9999&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;(9999)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;(9999)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;飛　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;85&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;110&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;75&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;角　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;75&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;65&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;金　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;(50)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;45&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;銀　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;45&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;40&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;桂　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;30&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;香　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;25&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;歩　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;span&gt;※対局中に大駒が成れるのに成らないケースがしばしば見られると思いますが、上記表の重みを考慮して、どうせ相手に取られるから成らない（低い重みのまま）でおこうとＡＩが判断するためです。&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初期配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span&gt;作ってみて感じたのですが、３三将棋の場合適当に駒を配置すると将棋の上級者が見るとすぐに勝敗が明白な局面になっていたりして、面白い勝負になりそうな初期配置を探すのが一番難しいかもしれません。とりあえず勝負が楽しめそうな配置で尚且ついろんな種類の駒を使うことを考えて「９マス将棋」なども参考にしながら１５種類の局面を用意しました。今後、追加していく予定です。&lt;/span&gt;&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/33shogi_placement.png&quot; alt=&quot;Menu - 初期配置&quot; title=&quot;Menu - 初期配置&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;初期配置検索機能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　初期配置パターンが１００を超えてきたので、Version1.0.2.6から初期配置検索機能を付けました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/menu_search1.png&quot; alt=&quot;Menu - 初期配置検索&quot; title=&quot;Menu - 初期配置検索&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　駒を選択して検索ボタンを押下すると、持ち駒あるいは盤上にその駒を使用している初期配置がリストアップされます&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。駒の選択条件はアンド（＆）検索になっているので、例えば「角」と「香」を選んで検索すると「角」も「香」も使用されている初期配置だけが検索結果に表示されます。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/menu_search2.png&quot; alt=&quot;Menu - 初期配置検索結果&quot; title=&quot;Menu - 初期配置検索結果&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ソースファイル&quot;&gt;ソースファイル&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://github.com/happyclam/shogi33simple&quot;&gt;github&lt;/a&gt;でCoffeeScriptのソースファイルを公開しました。GUI部分にはまだバグが潜んでいるかもしれませんが、思考ルーチン部分はほぼ落ち着いていると思っています。実際のアプリの先読みメソッド（思考ルーチン）は、浅い先読みを行い候補手のリストを作成しその候補手リストからさらに深読みするという方法を取っているのですが、混みいったコードになるのでその部分は省いています。リリースしてからバグを発生させていたのはほとんどこの候補手を絞り込む部分に関するもので、基本的なところはリリース当初からほとんど変わっていません。対戦型将棋ソフトを作る上で必要最低限なコードになっていると思います。このコードを元に３三将棋だけでなく９×９の本将棋に移行するのも容易だと思います、というか元々Rubyで作った自作の将棋ソフトのコードを元にしてこのアプリを作りました。&lt;br /&gt;
　今度はMINI-MAX法＋αβ法ではなく学習型のＡＩに挑戦したいと思っています。&lt;/p&gt;

&lt;h3 id=&quot;開発資料&quot;&gt;開発資料&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;クラス図&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/shogi33class.png&quot;&gt;&lt;img src=&quot;/images/shogi33class.png&quot; alt=&quot;クラス図&quot; title=&quot;クラス図&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;テストツール&lt;br /&gt;
　mocha + chai でテストケースを書きました。CoffeeScript+mocha+chai=CaffeineJSと誰かが言ってましたが、まさに依存性のあるカフェインのように癖になりそうなぐらい作りやすかったです。いずれgithubでソースもテストスクリプトも公開する予定です。その時はこの記事を更新します。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;コンソール版&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/shogi33cui.png&quot;&gt;&lt;img src=&quot;/images/shogi33cui.png&quot; alt=&quot;CUI版&quot; title=&quot;CUI版&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　最初は作り易さもあってコンソール画面でも遊べるCUI版（Gameクラス、Boardクラス）から作っていたのですが、将棋の指し手は複数の駒が動ける可能性がある時に「１一銀右」とか「３二銀引成」とか「３一金直」とかいろんなケースが発生するので、それをコンソール画面でコマンドラインのパラメータとして入力させる処理が非常に面倒になります。だから一通りコンソールでも遊べるようになったところで細かいところは未対応のまま放置してGUI版の開発に移行しました。GUIなら駒をタッチ（クリック）するだけなのでUI（ユーザーインターフェース）が作り易くなるからです。それでもコンソールで作っていたBoardクラスは変更を加える必要がなくそのまま継承してBoardGUIクラスを作るだけで済むのはオブジェクト指向プログラミングの面目躍如と言ったところです。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;具体的にはtoString()関数を徹底的に排除して数値のまま処理したことと、末端ノードに達する前に局面の静的評価をして先読み再帰関数の終了条件を増やしたことです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;三手詰めと書くと誤解を与えるので「三手以内の詰み」としています。詰将棋のように王手の連続で詰ますわけではなく、相手が指す手がなくなるような状態も含めて三手以内で勝つという意味です。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;今後初期配置パターンが増えてきたら、持ち駒は含めずに盤上の駒だけを検索するように変更するかもしれません。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>ハイブリッドアプリのセキュリティ</title>
   <link href="https://happyclam.github.io/programming/2017-08-12/hybrid_csp"/>
   <updated>2017-08-12T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2017-08-12/hybrid_csp</id>
   <content type="html">&lt;h3 id=&quot;アプリ更新を強要されるよりかはマシだな&quot;&gt;アプリ更新を強要されるよりかはマシだな&lt;/h3&gt;
&lt;p&gt;　以前&lt;a href=&quot;/programming/2016-02-14/cordova_update&quot;&gt;Google様からのお達し&lt;/a&gt;によりアプリのアップデートを強要されたことを書きましたが、今回は自分の都合で&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;自作のアプリ&lt;/a&gt;のアップデートをしようとした際にCordovaの仕様変更に対応する必要に迫られたので、誰かの役に立てばと思い記事を書きます。ハイブリッドアプリの脆弱性という意味では前回の件と似たようなものだと思うのですが、前回のように既にリリースされているアプリにまで対応を迫るということはなかったようです。CordovaにCSP（ContentSecurityPolicy）が導入されたのがいつかは知りませんが、とりあえず最近まで&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;このアプリ&lt;/a&gt;に関してはCSPを設定しないままでリリース出来ていました、ほとんどアクティブユーザーはいませんが&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;外部サーバーからのデータ取得jsonp&quot;&gt;外部サーバーからのデータ取得（JSONP）&lt;/h3&gt;
&lt;p&gt;　アプリの中でJSONPを使ってherokuで運用している外部サーバーからデータ（ユーザーのランキングデータ）を取得する処理があるのですが、適切にCSPを書かなければ&lt;code&gt;Refused to connect to 'http://XXX.herokuapp.com/XXX'&lt;/code&gt;というエラーでデータが取得出来なくなったようです。Whitelistプラグインを使ってconfig.xmlに記載するだけではダメみたいです、通常のHTTPリクエストよりAjaxリクエストはさらに規制を強くするということでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- config.xml --&amp;gt;
&amp;lt;access origin=&quot;https://tictactoe-cf.herokuapp.com&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　以下のようにindex.htmlにmetaタグを書くことでデータ取得に成功しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HTML&quot;&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src *; style-src 'self' 'unsafe-inline'; script-src 'self' http://localhost:3000 https://stictactoe-cf.herokuapp.com 'unsafe-inline' 'unsafe-eval'&quot;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　script-srcの部分にテスト時のローカルのURLと本番で使う外部サーバーのURLをスペースで区切って記述します。default-srcに記述すれば代替出来ると書かれたサイトもありましたが、私が試した限りではscript-srcに書かないと動きませんでした。&lt;/p&gt;

&lt;h3 id=&quot;他にもあった開発時の制約xmlhttprequest&quot;&gt;他にもあった開発時の制約（XMLHttpRequest）&lt;/h3&gt;
&lt;p&gt;　つい最近もう一つの&lt;a href=&quot;https://play.google.com/store/apps/details?id=tictactoe_van.io.github.happyclam&quot;&gt;別のアプリ&lt;/a&gt;を弄っててわかったことですが、初期化データをローカルディスクから読み込む際に以下のような感じでXMLHttpRequestを使えていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CoffeeScript&quot;&gt;#CoffeeScriptファイル
        xhr = new XMLHttpRequest
        fileReader = new FileReader
        xhr.open 'GET', './XXXX.json', true
        xhr.responseType = 'json'
        xhr.addEventListener 'load', (=&amp;gt;
            if (xhr.status == 200)
            # if xhr.readyState == 4 and xhr.status == 0
                buf = xhr.response
                compressed = LZString.compressToUTF16(JSON.stringify(buf))
                try
                    localStorage.setItem 'SerializedData', compressed
                catch e
                    console.log 'Storage failed: ' + e
            return
        ), false
        xhr.send()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　今現在リリースしているアプリ（確かビルドに使用したCordovaのバージョンは6.5でした）はこの方法を使って動いているのですが、手元にある今使っているCordova（version7.0.1）では使えなくなっているようです。だから次にアプリをバージョンアップするときは他のやり方に変更する必要があります。&lt;br /&gt;
　なんか自分がアプリをリリースする度に次のリリース時には改変を強いられるということが続くので、「またこんなことする奴が出て来たよ〜」と言われている気がするんですが考えすぎでしょうか&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　対策としてはデータを外部サーバーに置くかファイル操作を行うプラグインを使う必要が出て来そうですが、ファイル入出力操作はandroidアプリとiPhoneアプリの仕様の違い（ファイルの設置場所等）を考慮しないといけないので面倒です。となると外部サーバーに置くかということになりそうですが、もっと簡単な回避策があります。以下のように必要なデータをHTMLファイルに埋め込んで、それを読み込むようにすることで上のコードと同じことを実現出来ました&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CoffeeScript&quot;&gt;#CoffeeScriptファイル
        data = document.getElementById(&quot;initialdata&quot;);
        buf = JSON.parse(data.textContent);
        compressed = LZString.compressToUTF16(JSON.stringify(buf))
        try
            localStorage.setItem 'SerializedData', compressed
        catch e
            console.log 'Storage failed: ' + e
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- htmlファイルの例 --&amp;gt;
    &amp;lt;script type=&quot;application/json&quot; id=&quot;initialdata&quot;&amp;gt;
      {&quot;value&quot;:0,&quot;child&quot;:[],&quot;score&quot;:[50.872293099057885, 63.13216317016328, 62.51541431117913, 60.18288478188489, 67.52947485847494, 57.466225441225525, 64.30766966366978, 48.17378088578095, 57.74998440774921]}
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　セキュリティの観点から言っても外部サーバーからデータを取得するより安全でしょう。&lt;br /&gt;
　ネイティブアプリと違ってWebViewというブラウザーコンポーネント上で動くハイブリッドアプリは、開発時にいろいろ制約が付き纏います。でもそれ以上にUI部分をHTMLとCSSで簡単に書けるというメリットは大きいと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;自分がテストで使っていた端末はAndroid4.4（Kitkat）で、XMLHttpRequest(ajax)で読み込めていたローカルファイルが開発環境を変えたことで読み込めなくなったのですが、古い端末だと搭載されているブラウザの制限で元々出来ないようで、やるべきじゃなかったようです。HTMLに埋め込むやり方なら古い端末でも動作しました。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>「消える三目並べ」リリースしました</title>
   <link href="https://happyclam.github.io/project/2017-07-11/tictactoe-van"/>
   <updated>2017-07-11T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2017-07-11/tictactoe-van</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=tictactoe_van.io.github.happyclam&quot;&gt;&lt;img src=&quot;/images/ja_badge_web_generic.png&quot; alt=&quot;消える三目並べ&quot; title=&quot;消える三目並べ&quot; width=&quot;155&quot; height=&quot;60&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;消える三目並べtic-tac-toe-vanについて&quot;&gt;「消える三目並べ（Tic-tac-toe Van）」について&lt;/h3&gt;
&lt;p&gt;　「消える三目並べ（Tic-tac-toe Van）」は、機械学習型三目並べアプリの第二弾です。前作（&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;）は通常の三目並べでしたが、今回は３手前に打った自分の駒が消えるルールの三目並べです。前作は初期データとして全く学習していないデータを使用していましたが、今回の「消える三目並べ」は出現し得る局面の数が通常の三目並べより多いため、初期データとしてある程度学習済みのデータを使用しています。対戦を重ねる度に強くなる点は同じです。&lt;/p&gt;

&lt;h3 id=&quot;ルール&quot;&gt;ルール&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;×が先手、○が後手で変更できません。&lt;/li&gt;
  &lt;li&gt;通常の三目並べ同様にラインを揃えれば勝ちですが、３手前に打った自分の駒が消えるのでそれを見越した上で指し手を選択する必要があります。&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:640px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/van_serial.png&quot; alt=&quot;メイン画面&quot; title=&quot;メイン画面&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上記のようにゲームが進行した場合、ｘのラインを揃えようとして下段真ん中をタッチしても
三手前の×が消えるので×のラインは揃わず、逆に◯を揃えられて負けてしまいます。&lt;/span&gt;&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/tictactoe-van-win.png&quot; alt=&quot;メイン画面&quot; title=&quot;メイン画面&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;引き分けはありません。厳密に言うとゲームの特性上はある限定した局面から先手・後手双方が最善手を続けることで同じ局面の繰り返しに陥る可能性があるのですが、もしそうなってもAI側が手を変えます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;メニュー&quot;&gt;メニュー&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;学習機能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span&gt;学習機能 On/Off を選択します。Onにするとゲームを終了する度に学習データを書き込むための時間が必要になります&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/menu_learning.png&quot; alt=&quot;Menu - 学習機能&quot; title=&quot;Menu - 学習機能&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/saving_message.png&quot; alt=&quot;学習データ保存中ダイアログ&quot; title=&quot;学習データ保存中ダイアログ&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;「Saving Learning Data…」のダイアログ表示中に次のゲームを開始する等の操作をすることはタイミング次第で出来なくはないですが、アプリがファイルを書きこんでいる最中はすべての操作が出来なくなります。&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;難易度
    &lt;ul&gt;
      &lt;li&gt;Easyモード:&lt;br /&gt;
  ３手前に打った駒（×、◯）が徐々に薄くなって消えていく（Fade Away）ので、次にどの駒が消えるか分かるので勝ちやすいです。&lt;/li&gt;
      &lt;li&gt;Normalモード:&lt;br /&gt;
３手前に打った駒（×、◯）がいきなり消える（Vanish）ので、次にどの駒が消えるか覚えておく必要があるため勝つのが難しくなります。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/menu_difficulty.png&quot; alt=&quot;Menu - 難易度&quot; title=&quot;Menu - 難易度&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;width:640px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/van-easy.png&quot; alt=&quot;メイン画面 - Easyモード&quot; title=&quot;メイン画面 - Easyモード&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Easyモードに設定した場合、上記のよう古い駒（×、◯）が徐々に薄く描画されます。次にどの駒が消えるか覚えなくてもいいので戦い易くなります。AIの指し手の選択自体はNormalモードもEasyモードも違いはありません。&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;対戦成績&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span&gt;Easyモード、Normalモードそれぞれの対戦成績を表示します。&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/menu_records.png&quot; alt=&quot;Menu - 対戦成績&quot; title=&quot;Menu - 対戦成績&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;学習データ&quot;&gt;学習データ&lt;/h3&gt;
&lt;p&gt;　AI用の初期データとしてある程度学習済みのデータ（MIN-MAX法を使った最強プログラムと10,000回対戦させたデータ）を使用しています。以下のグラフはまったく学習させていないところから乱数プログラムと最強プログラムの２種類のプログラムと対戦テストを行って、アプリの勝率の推移をグラフにしたものです。グラフの黄色のラインの経過を経たデータを初期データとしてアプリに同梱しています。最強のプログラムに対して勝率５割には達していませんので、初心者の方でも全く勝てないなんてことはないと思います。&lt;/p&gt;

&lt;div id=&quot;vanishing-tictactoe&quot; style=&quot;width:600px;height:400px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;button id=&quot;unzoom&quot;&gt;元に戻す&lt;/button&gt;&lt;span&gt;　※範囲をドラッグすれば、グラフを zoom up 出来ます&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　手数の推移は参考程度に見て下さい。グラフではわかりにくいほどの微妙な違いですが、最強プログラムと対戦テストを行った場合（水色のグラフ）、最初は最強プログラムに対して短手数で簡単に負けていたアプリが学習が進むに連れてなかなか負けないようになり手数が徐々に伸びていっていることがわかります。また、乱数プログラムと対戦テストを行った場合（緑色のグラフ）はお互いに弱い者同士なのでなかなか決着が付かずにゲーム終了までに無意味に長い手数が必要だったものが、学習を積み重ねることによってアプリ側が勝ち方を覚えていき、ゲーム終了までの手数が徐々に短くなっていくことが見て取れます。&lt;br /&gt;
　プロットするのが大変なのでグラフにはしていませんが、対乱数プログラムとの対戦グラフ（赤色のグラフ）は100,000回までテスト回数を伸ばすと９割以上の勝率にまで伸びることを確認しています。このグラフの１０倍の回数対戦させて９割ですので、かなり緩やかな右肩上がりのグラフです。対最強プログラムのグラフも（黄色のグラフ）も同様に緩やかな右肩上がりに推移すると思われます。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
jQuery(function ($){

linegraph = function() {
    var equation1 = [[1 ,0],[2 ,0],[3 ,0],[4 ,2],[5 ,0],[6 ,0],[7 ,0],[8 ,3],[9 ,2],[10 ,1],[11 ,0],[12 ,1],[13 ,0],[14 ,0],[15 ,1],[16 ,0],[17 ,1],[18 ,1],[19 ,2],[20 ,0],[21 ,1],[22 ,2],[23 ,2],[24, 0],[25 ,2],[26 ,4],[27 ,3],[28 ,3],[29 ,4],[30 ,4],[31 ,4],[32 ,5],[33 ,2],[34 ,9],[35 ,6],[36, 6],[37, 14],[38, 7],[39, 13],[40, 20],[41, 19],[42, 20],[43, 11],[44, 14],[45, 16],[46, 34],[47, 20],[48, 33],[49, 33],[50, 27],[51, 24],[52, 21],[53, 30],[54, 28],[55, 36],[56, 31],[57, 21],[58, 36],[59, 29],[60, 27],[61, 39],[62, 30],[63, 37],[64, 27],[65, 32],[66, 39],[67, 25],[68, 33],[69, 31],[70, 23],[71, 36],[72, 18],[73, 25],[74, 32],[75, 36],[76, 30],[77, 30],[78, 27],[79, 21],[80, 31],[81, 33],[82, 30],[83, 30],[84, 40],[85, 25],[86, 19],[87, 36],[88, 31],[89, 36],[90, 30],[91, 28],[92, 39],[93, 31],[94, 30],[95, 29],[96, 30],[97, 23],[98, 27],[99, 28],[100, 30]];
    var equation2 = [[1, 6.56],[2, 6.7],[3, 6.89],[4, 7.0],[5, 6.9],[6, 6.95],[7, 6.75],[8, 7.05],[9, 6.71],[10, 7.25],[11, 6.88],[12, 7.05],[13, 7.28],[14, 7.22],[15, 6.81],[16, 6.80],[17, 7.16],[18, 7.24],[19, 7.2],[20, 6.85],[21, 7.05],[22, 7.20],[23, 7.16],[24, 7.07],[25, 6.65],[26, 7.90],[27, 7.09],[28, 7.23],[29, 6.96],[30, 7.77],[31, 7.04],[32, 7.51],[33, 7.18],[34, 7.40],[35, 7.45],[36, 7.30],[37, 7.04],[38, 7.30],[39, 7.79],[40, 7.42],[41, 7.77],[42, 7.89],[43, 7.41],[44, 7.49],[45, 7.64],[46, 7.80],[47, 7.46],[48, 7.82],[49, 7.82],[50, 7.95],[51, 7.92],[52, 7.53],[53, 8.0],[54, 7.43],[55, 8.36],[56, 7.95],[57, 7.48],[58, 8.53],[59, 7.86],[60, 7.55],[61, 7.7],[62, 7.84],[63, 7.97],[64, 7.79],[65, 7.73],[66, 7.92],[67, 7.85],[68, 7.88],[69, 7.6],[70, 7.89],[71, 7.88],[72, 7.21],[73, 7.68],[74, 7.93],[75, 8.12],[76, 7.89],[77, 7.52],[78, 7.82],[79, 7.50],[80, 8.43],[81, 7.81],[82, 7.76],[83, 7.91],[84, 7.85],[85, 7.31],[86, 7.60],[87, 7.82],[88, 7.79],[89, 7.72],[90, 7.66],[91, 7.66],[92, 8.27],[93, 7.90],[94, 7.42],[95, 7.56],[96, 7.68],[97, 7.94],[98, 7.44],[99, 7.77],[100, 7.58]];
    var equation3 = [[1, 46],[2, 54],[3, 52],[4, 53],[5, 49],[6, 50],[7, 44],[8, 47],[9, 49],[10, 50],[11, 57],[12, 56],[13 ,59],[14, 48],[15, 54],[16, 49],[17, 52],[18, 45],[19, 56],[20, 41],[21, 57],[22, 53],[23, 56],[24, 53],[25, 59],[26, 54],[27, 56],[28, 63],[29, 60],[30, 51],[31, 56],[32, 59],[33, 67],[34, 59],[35, 61],[36, 57],[37, 62],[38, 61],[39, 55],[40, 57],[41, 52],[42, 62],[43, 55],[44, 61],[45, 52],[46, 65],[47, 64],[48, 63],[49, 54],[50, 65],[51, 61],[52, 70],[53, 49],[54, 58],[55, 74],[56, 51],[57, 63],[58, 56],[59, 65],[60, 61],[61, 60],[62, 60],[63, 66],[64, 63],[65, 62],[66, 59],[67, 54],[68, 67],[69, 65],[70, 71],[71, 58],[72, 56],[73, 69],[74, 54],[75, 65],[76, 66],[77, 70],[78, 51],[79, 64],[80, 59],[81, 64],[82, 65],[83, 72],[84, 62],[85, 62],[86, 58],[87, 65],[88, 72],[89, 79],[90, 66],[91, 53],[92, 67],[93, 69],[94, 65],[95, 65],[96, 64],[97, 66],[98, 56],[99, 63],[100, 56]];
    var equation4 = [[1, 13.94],[2, 13.33],[3, 12.43],[4, 14.14],[5, 12.39],[6, 12.42],[7, 13.18],[8, 12.60],[9, 13.42],[10, 12.55],[11, 12.94],[12, 14.42],[13, 12.65],[14, 12.98],[15, 12.23],[16, 10.84],[17, 13.43],[18, 11.94],[19, 12.83],[20, 12.65],[21, 13.19],[22, 12.50],[23, 12.83],[24, 11.57],[25, 11.57],[26, 12.69],[27, 12.52],[28, 13.43],[29, 12.10],[30, 13.97],[31, 12.41],[32, 11.81],[33, 12.72],[34, 10.62],[35, 12.97],[36, 12.27],[37, 11.99],[38, 12.47],[39, 9.19],[40, 13.07],[41, 12.55],[42, 11.37],[43, 12.49],[44, 12.96],[45, 11.47],[46, 11.82],[47, 11.89],[48, 11.97],[49, 12.72],[50, 11.87],[51, 12.43],[52, 12.62],[53, 12.08],[54, 12.08],[55, 10.54],[56, 11.26],[57, 11.22],[58, 10.87],[59, 11.59],[60, 11.62],[61, 11.73],[62, 11.25],[63, 10.56],[64, 12.0],[65, 12.28],[66, 12.24],[67, 11.32],[68, 11.74],[69, 11.02],[70, 11.59],[71, 11.90],[72, 10.46],[73, 11.91],[74, 11.30],[75, 10.79],[76, 11.78],[77, 10.46],[78, 10.73],[79, 12.55],[80, 12.06],[81, 11.31],[82, 10.15],[83, 12.43],[84, 10.74],[85, 10.96],[86, 13.80],[87, 11.90],[88, 11.74],[89, 10.0],[90, 10.64],[91, 12.30],[92, 11.17],[93, 11.45],[94, 10.08],[95, 10.62],[96, 10.13],[97, 11.58],[98, 11.43],[99, 12.26],[100, 12.28]];

    var $el = $(&quot;#vanishing-tictactoe&quot;),
        data = [
            {data: equation1, label: &quot;対最強プログラム勝数&quot;},
            {data: equation2, label: &quot;対最強プログラム平均手数&quot;},
            {data: equation3, label: &quot;対乱数プログラム勝数&quot;},
            {data: equation4, label: &quot;対乱数プログラム平均手数&quot;}
            ],
        options = {
            legend: {position: &quot;nw&quot;},
            selection: {mode: &quot;xy&quot;, color: &quot;#eeeeee&quot;},
            title: &quot;勝敗の推移&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            lines:{show: true, horizontal:false},
            xaxis:{
                max: 100,
                ticks: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, [100, &quot;×100回&quot;]],
                title: &quot;対戦回数（×１００）&quot;
            },
            yaxis:{
                ticks: 20,
                min: 0,
                max: 100,
                title: &quot;対戦結果（勝ち数／手数）&quot;
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }, plotObj;

    $el.on(&quot;plotselected&quot;, function(ev, ranges) {
        plotObj = $.plot($el, data,
                         $.extend(true, {}, options, {
                             xaxis: {min: ranges.xaxis.from, max: ranges.xaxis.to},
                             yaxis: {min: ranges.yaxis.from, max: ranges.yaxis.to}
                         })
                        );
    });
    plotObj = $.plot($el, data, options);
    $(&quot;#unzoom&quot;).click(function() {
        plotObj = $.plot($el, data, options);
    });
};

if (typeof contentLoaded != &quot;undefined&quot;) {
    contentLoaded.done(linegraph);
} else {
    window.addEventListener('load', linegraph);
}

});

&lt;/script&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>三目並べでニューラルネットワーク（正）</title>
   <link href="https://happyclam.github.io/project/2017-07-07/neuralnw2"/>
   <updated>2017-07-07T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2017-07-07/neuralnw2</id>
   <content type="html">&lt;p&gt;Project: 「&lt;strong&gt;三目並べ&lt;/strong&gt;」: &lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby/tree/neural&quot;&gt;neural&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;aiの学習は信賞必罰が必要&quot;&gt;AIの学習は信賞必罰が必要？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/project/2017-07-01/neuralnw&quot;&gt;前回記事&lt;/a&gt;の訂正のための記事です。前回の内容がすべて間違っているわけじゃないので、比較のために前回の記事も残してます。合わせて読んでいただければと思います。前回の記事で「勝っても負けても勝った方の指し手を教師データとして、勝った方の手番の局面データの重みを勾配法を使って誤差修正する」というやり方を試したことを書きました。そして、それっぽいテスト結果が得られたので、現在作成中の「消える三目並べ」（３手前に打った自分の駒が消えるルールの三目並べ）に適応して遊んでみたところ、何度も同じパターンの負け方をして学習が進んでいる気配を感じられなかったのです。ゲームの特性上負けを避けられないケースもありますし、AIは最善手を選ぶ確率を上げるように学習するだけで必ず最善手を選ぶわけではないのでAI側が負けたからと言って必ずしもバグではないのですが、初手から数手で単純に負ける酷い負け方が何回も続くのです。テストのためにかなりの回数「消える三目並べ」の対戦をしてきて自分も強くなっている&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;ので、これは「弱すぎる」「おかしい」と分かります。何が悪かったのでしょうか？&lt;br /&gt;
　どうやら「どちらが勝っても勝った方の指し手を教師データとした」ところが良くなかったようです。勝った方の手を教師データとしてばかりいると、相手がリーチを掛けた局面（あと一手で相手のラインが揃う局面）で相手のラインが揃うのを防がなかった場合に、それが原因でAIが負けたとしてもそれが悪いことだと学習する機会がありません（勝った側の手だけを学習するため）。相手がリーチを掛けた局面がAIの手番であればラインを揃える手（勝つ手）を逃すことはなくなりますが、自分が（AIが）負けた時に相手が揃うことを防がなかった手が悪い手だということを教える必要があります。つまり負けたら罰を与えないといけなかったようです。&lt;br /&gt;
　ということで、結局、勝てば＋３、負ければ−１、引分は＋１というマジックナンバーを復活させることにしました。&lt;/p&gt;

&lt;h3 id=&quot;修正内容&quot;&gt;修正内容&lt;/h3&gt;
&lt;p&gt;　興味がある方はソースを確認していただけばいいと思いますが、前回は教師データとして９要素の配列（重みデータ）に正解手だけ1.0をセットして、それを教師データとして誤差修正していました。&lt;/p&gt;
&lt;pre style=&quot;overflow:auto; white-space:nowrap&quot;&gt;
 教師データ
 [0, 0, 1.0, 0, 0, 0, 0, 0, 0]
&lt;/pre&gt;
&lt;p&gt;　今回は勝てば3.0、負けは-1.0、引分は1.0をセットして誤差修正しています。&lt;/p&gt;
&lt;pre style=&quot;overflow:auto; white-space:nowrap&quot;&gt;
 負けの場合の教師データ
 [0, 0, -1.0, 0, 0, 0, 0, 0, 0]&lt;br /&gt;
 勝ちの場合の教師データ
 [0, 0, 3.0, 0, 0, 0, 0, 0, 0]&lt;br /&gt;
 引分の場合の教師データ
 [0, 0, 1.0, 0, 0, 0, 0, 0, 0]
&lt;/pre&gt;
&lt;p&gt;　&lt;a href=&quot;https://www.amazon.co.jp/ゼロから作るDeep-Learning-Pythonで学ぶディープラーニングの理論と実装-斎藤-康毅/dp/4873117585/ref=sr_1_2?ie=UTF8&amp;amp;qid=1498438151&amp;amp;sr=8-2&amp;amp;keywords=ディープラーニング&quot;&gt;「ゼロから作るDeep Learning」&lt;/a&gt;に記載されているsoftmax関数が合計1.0になるように按分してくれるので修正はこれだけです。&lt;br /&gt;
　但し、勝ちが３で負けが−１と落差が激しいために発散するのか、良い結果が得られなかったので&lt;strong&gt;学習率&lt;/strong&gt;を前回の&lt;strong&gt;0.1&lt;/strong&gt;から&lt;strong&gt;0.03&lt;/strong&gt;に大幅に下げました。&lt;/p&gt;

&lt;h5 id=&quot;-最強プログラムとの対戦結果-&quot;&gt;– 最強プログラムとの対戦結果 –&lt;/h5&gt;

&lt;div id=&quot;neural_saikyo&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;new_saikyo&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　上の２つのグラフのうち下側のグラフは現在リリース中の&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;と同じものです。上側のニューラルネットワークのグラフは、前回間違ったプログラムを使って「学習速度が速い」なんて書いてしまいましたが、グラフを見る限りむしろ遅くなった感じです。それより特徴的なことは、学習がピークまで達すると間違った手を指さないようになっていることです。重みデータを加減算で操作している方法（下のグラフ）だと６０００回対戦後も５％ぐらいは間違った指し手を選んで負けているのに、勾配法を使ってる上のグラフだと６０００回対戦後は１００％引分に持ち込んでいます（間違った手を指していない）。指し手を選ぶ推論部分（重みデータの比率で指し手を選ぶ方法）は全く同じなのにこの差が出るのは、重みデータが圧倒的に偏った値になっているということです。&lt;br /&gt;
　例えばゲームスタート時の初期盤面の学習データ（報酬データ）は、従来の加減算によるものでは&lt;a href=&quot;/software/2015-10-25/machine_learning&quot;&gt;以前の記事&lt;/a&gt;にも書いたように、だいたい以下のような感じのデータになります。&lt;/p&gt;
&lt;pre style=&quot;overflow:auto; white-space:nowrap&quot;&gt;
 初期盤面の報酬データ（加減算）
 [94, 32, 137, 98, 160, 95, 98, 84, 97]
&lt;/pre&gt;
&lt;p&gt;　次にどんな手を選ぶか（推論部分）は、単に以下の確率で決まります。&lt;/p&gt;
&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\frac{（対象となる箇所の学習データの値）}{（９箇所の学習データの合計値）}&lt;/script&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;だからこのデータの場合は、全配列の合計は&lt;strong&gt;895&lt;/strong&gt;で盤面の真ん中のデータが&lt;strong&gt;160&lt;/strong&gt;になっていますので、AIが先手の場合に&lt;strong&gt;160／895&lt;/strong&gt;の確率で初手に真ん中を選ぶということを示しています。対して勾配法による学習後のデータは以下のようになりました。&lt;/p&gt;
&lt;pre style=&quot;overflow:auto;&quot;&gt;
 初期盤面の報酬データ（勾配法）
[-0.7601376352001628, -0.7502935835767303, -0.7520158193991342, -0.742749527313905, 6.938823028629541, -0.7552042606689815, -0.7336853491261596, -0.7136915491061318, -0.7310453055201457] 
&lt;/pre&gt;
&lt;p&gt;　合計は 0.9999999987181899（約 1.0 ）ですので、6.9 / 1.0 の確率（約７００％）、つまり初手は１００％真ん中を選ぶようになったということです。&lt;/p&gt;

&lt;h5 id=&quot;-乱数プログラムとの対戦結果-&quot;&gt;– 乱数プログラムとの対戦結果 –&lt;/h5&gt;
&lt;div id=&quot;neural_random&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;new_random&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　乱数で指し手を決める弱いプログラム相手では、多少勝率が高いようですがほぼ似たような結果になりました。&lt;/p&gt;

&lt;h3 id=&quot;学習速度に関しては一概に言え無さそう&quot;&gt;学習速度に関しては一概に言え無さそう&lt;/h3&gt;
&lt;p&gt;　勾配法を用いたことで学習速度が若干悪くなったテスト結果（グラフ）を紹介しましたが、学習率を変えるとまた違ってくるかもしれません。とりあえず「通常の三目並べ」で試すのはここまでにして、今後作るアプリでいろいろ試して見ようと思ってます。今回修正した内容は&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby/tree/neural&quot;&gt;github&lt;/a&gt;には適用していますので、興味のある方は見て下さい。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
function show_new_saikyo(){
    var new_lose = [];
    var new_win = [[1, 87],[2, 57],[3, 65],[4, 53],[5, 59],[6, 47],[7, 41],[8, 42],[9, 35],[10, 31],[11, 32],[12, 32],[13, 20],[14, 22],[15, 18],[16, 20],[17, 12],[18, 14],[19, 7],[20, 12],[21, 8],[22, 8],[23, 9],[24, 8],[25, 3],[26, 9],[27, 5],[28, 6],[29, 3],[30, 5],[31, 4],[32, 2],[33, 4],[34, 3],[35, 5],[36, 5],[37, 2],[38, 9],[39, 6],[40, 1],[41, 4],[42, 3],[43, 4],[44, 4],[45, 3],[46, 4],[47, 1],[48, 1],[49, 1],[50, 5],[51, 1],[52, 2],[53, 3],[54, 1],[55, 4],[56, 3],[57, 1],[58, 3],[59, 1],[60, 1],[61, 1],[62, 5],[63, 4],[64, 3],[65, 4],[66, 3],[67, 1],[68, 4],[69, 1],[70, 0],[71, 3],[72, 4],[73, 2],[74, 4],[75, 2],[76, 4],[77, 5],[78, 0],[79, 2],[80, 0],[81, 0],[82, 0],[83, 3],[84, 1],[85, 0],[86, 0],[87, 0],[88, 1],[89, 0],[90, 2],[91, 1],[92, 4],[93, 0],[94, 1],[95, 1],[96, 3],[97, 0],[98, 2],[99, 2],[100, 1]];
    var new_draw = [[1 ,13],[2 ,43],[3 ,35],[4 ,47],[5 ,41],[6 ,53],[7 ,59],[8 ,58],[9 ,65],[10 ,69],[11 ,68],[12 ,68],[13 ,80],[14 ,78],[15 ,82],[16 ,80],[17 ,88],[18 ,86],[19 ,93],[20 ,88],[21 ,92],[22 ,92],[23 ,91],[24 ,92],[25 ,97],[26 ,91],[27 ,95],[28 ,94],[29 ,97],[30 ,95],[31 ,96],[32 ,98],[33 ,96],[34 ,97],[35 ,95],[36 ,95],[37 ,98],[38 ,91],[39 ,94],[40 ,99],[41 ,96],[42 ,97],[43 ,96],[44 ,96],[45 ,97],[46 ,96],[47 ,99],[48 ,99],[49 ,99],[50 ,95],[51 ,99],[52 ,98],[53 ,97],[54 ,99],[55 ,96],[56 ,97],[57 ,99],[58 ,97],[59 ,99],[60 ,99],[61 ,99],[62 ,95],[63 ,96],[64 ,97],[65 ,96],[66 ,97],[67 ,99],[68 ,96],[69 ,99],[70 ,100],[71 ,97],[72 ,96],[73 ,98],[74 ,96],[75 ,98],[76 ,96],[77 ,95],[78 ,100],[79 ,98],[80 ,100],[81 ,100],[82 ,100],[83 ,97],[84 ,99],[85 ,100],[86 ,100],[87 ,99],[88 ,99],[89 ,100],[90 ,98],[91 ,99],[92 ,96],[93 ,100],[94 ,99],[95 ,99],[96 ,97],[97 ,100],[98 ,98],[99 ,98],[100 ,99]];

    Flotr.draw(
        document.getElementById(&quot;new_saikyo&quot;),
        [
            {data: new_lose, label: &quot;勝ち&quot;},
            {data: new_win, label: &quot;負け&quot;},
            {data: new_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の方法、重みを加減算&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_neural_saikyo(){
    var old_lose = [];
    var old_win = [[1, 81],[2, 79],[3, 81],[4, 70],[5, 48],[6, 53],[7, 48],[8, 49],[9, 40],[10, 46],[11, 45],[12, 50],[13, 54],[14, 35],[15, 48],[16, 53],[17, 53],[18, 51],[19, 51],[20, 41],[21, 35],[22, 37],[23, 45],[24, 42],[25, 39],[26, 42],[27, 32],[28, 39],[29, 32],[30, 30],[31, 31],[32, 26],[33, 25],[34, 25],[35, 15],[36, 13],[37, 9],[38, 10],[39, 9],[40, 8],[41, 15],[42, 4],[43, 10],[44, 3],[45, 3],[46, 9],[47, 5],[48, 4],[49, 3],[50, 7],[51, 3],[52, 6],[53, 1],[54, 2],[55, 4],[56, 5],[57, 3],[58, 5],[59, 2],[60, 4],[61, 0],[62, 1],[63, 1],[64, 0],[65, 1],[66, 0],[67, 0],[68, 0],[69, 0],[70, 0],[71, 0],[72, 0],[73, 0],[74, 0],[75, 0],[76, 0],[77, 0],[78, 0],[79, 0],[80, 0],[81, 0],[82, 0],[83, 0],[84, 0],[85, 0],[86, 0],[87, 0],[88, 0],[89, 0],[90, 0],[91, 0],[92, 0],[93, 0],[94, 0],[95, 0],[96, 0],[97, 0],[98, 0],[99, 0],[100, 0]];
    var old_draw = [[1 ,19],[2 ,21],[3 ,19],[4 ,30],[5 ,52],[6 ,47],[7 ,52],[8 ,51],[9 ,60],[10 ,54],[11 ,55],[12 ,50],[13 ,46],[14 ,65],[15 ,52],[16 ,47],[17 ,47],[18 ,49],[19 ,49],[20 ,59],[21 ,65],[22 ,63],[23 ,56],[24 ,58],[25 ,61],[26 ,58],[27 ,68],[28 ,61],[29 ,68],[30 ,70],[31 ,69],[32 ,74],[33 ,75],[34 ,75],[35 ,85],[36 ,87],[37 ,91],[38 ,90],[39 ,91],[40 ,92],[41 ,85],[42 ,96],[43 ,90],[44 ,97],[45 ,97],[46 ,91],[47 ,95],[48 ,96],[49 ,97],[50 ,93],[51 ,97],[52 ,94],[53 ,99],[54 ,98],[55 ,96],[56 ,95],[57 ,97],[58 ,95],[59 ,98],[60 ,96],[61 ,100],[62 ,99],[63 ,99],[64 ,100],[65 ,99],[66 ,100],[67 ,100],[68 ,100],[69 ,100],[70 ,100],[71 ,100],[72 ,100],[73 ,100],[74 ,100],[75 ,100],[76 ,100],[77 ,100],[78 ,100],[79 ,100],[80 ,100],[81 ,100],[82 ,100],[83 ,100],[84 ,100],[85 ,100],[86 ,100],[87 ,100],[88 ,100],[89 ,100],[90 ,100],[91 ,100],[92 ,100],[93 ,100],[94 ,100],[95 ,100],[96 ,100],[97 ,100],[98 ,100],[99 ,100],[100 ,100]];

    Flotr.draw(
        document.getElementById(&quot;neural_saikyo&quot;),
        [
            {data: old_lose, label: &quot;勝ち&quot;},
            {data: old_win, label: &quot;負け&quot;},
            {data: old_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;ニューラルネットワーク、勾配法（修正後）&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_new_random(){
    var new_lose = [[1, 36],[2, 43],[3, 49],[4, 39],[5, 51],[6, 55],[7, 62],[8, 51],[9, 51],[10, 66],[11, 56],[12, 61],[13, 60],[14, 60],[15, 69],[16, 62],[17, 78],[18, 58],[19, 67],[20, 67],[21, 72],[22, 66],[23, 71],[24, 65],[25, 62],[26, 69],[27, 74],[28, 69],[29, 72],[30, 67],[31, 64],[32, 65],[33, 79],[34, 68],[35, 73],[36, 76],[37, 81],[38, 72],[39, 80],[40, 76],[41, 65],[42, 67],[43, 70],[44, 69],[45, 74],[46, 75],[47, 68],[48, 78],[49, 73],[50, 76],[51, 74],[52, 74],[53, 66],[54, 70],[55, 79],[56, 80],[57, 79],[58, 74],[59, 73],[60, 62],[61, 81],[62, 69],[63, 81],[64, 77],[65, 75],[66, 75],[67, 83],[68, 70],[69, 72],[70, 76],[71, 77],[72, 78],[73, 77],[74, 73],[75, 74],[76, 81],[77, 79],[78, 80],[79, 82],[80, 81],[81, 81],[82, 76],[83, 78],[84, 80],[85, 66],[86, 81],[87, 76],[88, 75],[89, 78],[90, 83],[91, 82],[92, 77],[93, 79],[94, 76],[95, 72],[96, 79],[97, 73],[98, 86],[99, 77],[100, 79],];
    var new_win = [[1, 48],[2, 41],[3, 36],[4, 45],[5, 33],[6, 29],[7, 28],[8, 27],[9, 31],[10, 21],[11, 28],[12, 26],[13, 24],[14, 25],[15, 14],[16, 21],[17, 10],[18, 21],[19, 17],[20, 22],[21, 16],[22, 12],[23, 13],[24, 17],[25, 17],[26, 16],[27, 17],[28, 10],[29, 19],[30, 18],[31, 20],[32, 18],[33, 12],[34, 15],[35, 10],[36, 9],[37, 9],[38, 18],[39, 10],[40, 14],[41, 19],[42, 20],[43, 16],[44, 11],[45, 9],[46, 7],[47, 14],[48, 16],[49, 16],[50, 13],[51, 12],[52, 14],[53, 17],[54, 14],[55, 10],[56, 10],[57, 13],[58, 10],[59, 9],[60, 20],[61, 9],[62, 18],[63, 10],[64, 8],[65, 14],[66, 11],[67, 7],[68, 15],[69, 17],[70, 12],[71, 12],[72, 6],[73, 11],[74, 14],[75, 15],[76, 5],[77, 14],[78, 11],[79, 10],[80, 10],[81, 6],[82, 13],[83, 8],[84, 4],[85, 17],[86, 9],[87, 11],[88, 12],[89, 10],[90, 7],[91, 11],[92, 9],[93, 12],[94, 16],[95, 12],[96, 12],[97, 15],[98, 7],[99, 7],[100, 9],];
    var new_draw = [[1 ,16],[2 ,16],[3 ,15],[4 ,16],[5 ,16],[6 ,16],[7 ,10],[8 ,22],[9 ,18],[10 ,13],[11 ,16],[12 ,13],[13 ,16],[14 ,15],[15 ,17],[16 ,17],[17 ,12],[18 ,21],[19 ,16],[20 ,11],[21 ,12],[22 ,22],[23 ,16],[24 ,18],[25 ,21],[26 ,15],[27 ,9],[28 ,21],[29 ,9],[30 ,15],[31 ,16],[32 ,17],[33 ,9],[34 ,17],[35 ,17],[36 ,15],[37 ,10],[38 ,10],[39 ,10],[40 ,10],[41 ,16],[42 ,13],[43 ,14],[44 ,20],[45 ,17],[46 ,18],[47 ,18],[48 ,6],[49 ,11],[50 ,11],[51 ,14],[52 ,12],[53 ,17],[54 ,16],[55 ,11],[56 ,10],[57 ,8],[58 ,16],[59 ,18],[60 ,18],[61 ,10],[62 ,13],[63 ,9],[64 ,15],[65 ,11],[66 ,14],[67 ,10],[68 ,15],[69 ,11],[70 ,12],[71 ,11],[72 ,16],[73 ,12],[74 ,13],[75 ,11],[76 ,14],[77 ,7],[78 ,9],[79 ,8],[80 ,9],[81 ,13],[82 ,11],[83 ,14],[84 ,16],[85 ,17],[86 ,10],[87 ,13],[88 ,13],[89 ,12],[90 ,10],[91 ,7],[92 ,14],[93 ,9],[94 ,8],[95 ,16],[96 ,9],[97 ,12],[98 ,7],[99 ,16],[100 ,12]];

    Flotr.draw(
        document.getElementById(&quot;new_random&quot;),
        [
            {data: new_lose, label: &quot;勝ち&quot;},
            {data: new_win, label: &quot;負け&quot;},
            {data: new_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の方法、重みを加減算&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}
    
function show_neural_random(){
    var old_lose = [[1, 45],[2, 47],[3, 57],[4, 45],[5, 53],[6, 58],[7, 56],[8, 51],[9, 60],[10, 64],[11, 59],[12, 62],[13, 54],[14, 58],[15, 64],[16, 69],[17, 62],[18, 60],[19, 66],[20, 66],[21, 70],[22, 70],[23, 74],[24, 75],[25, 70],[26, 78],[27, 71],[28, 78],[29, 73],[30, 73],[31, 70],[32, 73],[33, 79],[34, 83],[35, 83],[36, 74],[37, 71],[38, 77],[39, 82],[40, 77],[41, 79],[42, 87],[43, 75],[44, 79],[45, 77],[46, 84],[47, 83],[48, 84],[49, 81],[50, 76],[51, 81],[52, 85],[53, 80],[54, 89],[55, 80],[56, 86],[57, 85],[58, 86],[59, 84],[60, 87],[61, 85],[62, 89],[63, 82],[64, 86],[65, 75],[66, 74],[67, 83],[68, 78],[69, 84],[70, 78],[71, 89],[72, 85],[73, 88],[74, 85],[75, 77],[76, 88],[77, 85],[78, 87],[79, 77],[80, 86],[81, 81],[82, 86],[83, 79],[84, 79],[85, 78],[86, 85],[87, 87],[88, 85],[89, 86],[90, 72],[91, 82],[92, 85],[93, 84],[94, 86],[95, 83],[96, 90],[97, 87],[98, 86],[99, 82],[100, 84]];
    var old_win = [[1, 46],[2, 38],[3, 35],[4, 39],[5, 38],[6, 29],[7, 30],[8, 40],[9, 27],[10, 23],[11, 32],[12, 25],[13, 30],[14, 19],[15, 26],[16, 19],[17, 26],[18, 26],[19, 23],[20, 18],[21, 20],[22, 19],[23, 19],[24, 15],[25, 20],[26, 13],[27, 18],[28, 15],[29, 16],[30, 18],[31, 20],[32, 17],[33, 10],[34, 6],[35, 12],[36, 15],[37, 17],[38, 15],[39, 10],[40, 11],[41, 13],[42, 6],[43, 13],[44, 11],[45, 15],[46, 4],[47, 9],[48, 13],[49, 10],[50, 9],[51, 7],[52, 9],[53, 12],[54, 7],[55, 8],[56, 9],[57, 7],[58, 9],[59, 8],[60, 9],[61, 4],[62, 4],[63, 12],[64, 7],[65, 14],[66, 16],[67, 8],[68, 7],[69, 10],[70, 10],[71, 7],[72, 8],[73, 3],[74, 9],[75, 13],[76, 6],[77, 7],[78, 9],[79, 11],[80, 5],[81, 5],[82, 8],[83, 5],[84, 12],[85, 11],[86, 4],[87, 8],[88, 9],[89, 9],[90, 11],[91, 11],[92, 8],[93, 7],[94, 7],[95, 13],[96, 4],[97, 8],[98, 8],[99, 6],[100, 9]];
    var old_draw = [[1 ,9],[2 ,15],[3 ,8],[4 ,16],[5 ,9],[6 ,13],[7 ,14],[8 ,9],[9 ,13],[10 ,13],[11 ,9],[12 ,13],[13 ,16],[14 ,23],[15 ,10],[16 ,12],[17 ,12],[18 ,14],[19 ,11],[20 ,16],[21 ,10],[22 ,11],[23 ,7],[24 ,10],[25 ,10],[26 ,9],[27 ,11],[28 ,7],[29 ,11],[30 ,9],[31 ,10],[32 ,10],[33 ,11],[34 ,11],[35 ,5],[36 ,11],[37 ,12],[38 ,8],[39 ,8],[40 ,12],[41 ,8],[42 ,7],[43 ,12],[44 ,10],[45 ,8],[46 ,12],[47 ,8],[48 ,3],[49 ,9],[50 ,15],[51 ,12],[52 ,6],[53 ,8],[54 ,4],[55 ,12],[56 ,5],[57 ,8],[58 ,5],[59 ,8],[60 ,4],[61 ,11],[62 ,7],[63 ,6],[64 ,7],[65 ,11],[66 ,10],[67 ,9],[68 ,15],[69 ,6],[70 ,12],[71 ,4],[72 ,7],[73 ,9],[74 ,6],[75 ,10],[76 ,6],[77 ,8],[78 ,4],[79 ,12],[80 ,9],[81 ,14],[82 ,6],[83 ,16],[84 ,9],[85 ,11],[86 ,11],[87 ,5],[88 ,6],[89 ,5],[90 ,17],[91 ,7],[92 ,7],[93 ,9],[94 ,7],[95 ,4],[96 ,6],[97 ,5],[98 ,6],[99 ,12],[100 ,7]];

    Flotr.draw(
        document.getElementById(&quot;neural_random&quot;),
        [
            {data: old_lose, label: &quot;勝ち&quot;},
            {data: old_win, label: &quot;負け&quot;},
            {data: old_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;ニューラルネットワーク、勾配法（修正後）&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

window.onload = function() {
    show_new_saikyo();
    show_neural_saikyo();
    show_new_random();
    show_neural_random();
};
&lt;/script&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>三目並べでニューラルネットワーク（誤）</title>
   <link href="https://happyclam.github.io/project/2017-07-01/neuralnw"/>
   <updated>2017-07-01T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2017-07-01/neuralnw</id>
   <content type="html">&lt;p&gt;Project: 「&lt;strong&gt;三目並べ&lt;/strong&gt;」: &lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby/tree/neural&quot;&gt;neural&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;消える三目並べの学習効率を上げるには&quot;&gt;消える三目並べの学習効率を上げるには&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/programming/2017-05-27/vanishing-tictactoe3&quot;&gt;前回の記事&lt;/a&gt;で現在作成中の「消える三目並べ」（３手前に打った自分の駒が消えるルールの三目並べ）の学習に時間が掛ることを書きましたが、&lt;a href=&quot;https://www.amazon.co.jp/ゼロから作るDeep-Learning-Pythonで学ぶディープラーニングの理論と実装-斎藤-康毅/dp/4873117585/ref=sr_1_2?ie=UTF8&amp;amp;qid=1498438151&amp;amp;sr=8-2&amp;amp;keywords=ディープラーニング&quot;&gt;「ゼロから作るDeep Learning」&lt;/a&gt;という本&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;に書いてあるニューラルネットワークのアルゴリズムを適用すれば学習効率が上がるのではないかと思い試すことにしました。ただ「消える三目並べ」のアプリに組み込む前に例のごとく「通常の三目並べ」でどうなるか試してみました。ディープラーニング（多層構造のニューラルネットワーク）を組み入れたわけではなく、指し手を決める「推論」部分は今まで通りで、対戦毎に学習データを更新する「学習」部分をニューラルネットワークに変更したということです。&lt;a href=&quot;https://www.amazon.co.jp/ゼロから作るDeep-Learning-Pythonで学ぶディープラーニングの理論と実装-斎藤-康毅/dp/4873117585/ref=sr_1_2?ie=UTF8&amp;amp;qid=1498438151&amp;amp;sr=8-2&amp;amp;keywords=ディープラーニング&quot;&gt;前述の本&lt;/a&gt;の中で”simpleNet”クラスとして紹介されているものに当たると思います。&lt;br /&gt;
　汎用的なAIライブラリもいろいろあるようですが、既存ライブラリの使い方を覚えるだけでは面白くないので自前（スクラッチ開発）でやってます&lt;img class=&quot;emoji&quot; title=&quot;smiley&quot; alt=&quot;smiley&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/smiley.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;と言っても&lt;a href=&quot;https://www.amazon.co.jp/ゼロから作るDeep-Learning-Pythonで学ぶディープラーニングの理論と実装-斎藤-康毅/dp/4873117585/ref=sr_1_2?ie=UTF8&amp;amp;qid=1498438151&amp;amp;sr=8-2&amp;amp;keywords=ディープラーニング&quot;&gt;前述の本&lt;/a&gt;に書いてある通りやっただけですが&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;修正内容&quot;&gt;修正内容&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;三目並べの局面データに保持している重みデータ（小石の数）を合計が1.0になるように按分する。&lt;/li&gt;
  &lt;li&gt;重みデータを更新する際に勾配法（確率的勾配降下法）を使う（学習率＝0.1）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　変更したのは主に上記２点だけです。１．に関しては本に紹介されていたsoftmax関数を使いました。ニューラルネットワークで学習するための準備です。２．に関しては、今までは勝ったら＋３、負けたら−１、引き分けなら＋１、という報酬＆罰を与えていた（重みデータの加減算）わけですが、その数値を使う必要がなくなります。根拠がはっきりしないマジックナンバーが無くなることはいいことでしょう。元々&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;という本にこの数値（勝ち＋３、負け−１、引分＋１）を使うのがいいと書いてあったからそうしただけなので&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;以前から気になってました。また今回の修正で、ゲーム序盤の指し手よりゲーム終盤の指し手を重視するというロジックはとりあえず取り外すことにしました。&lt;br /&gt;
　２.の修正を行う際には、MIN-MAX法を使った最強プログラムと対戦させて最強プログラムの指し手を教師データとして一手毎に重みを修正するようにすれば、とりあえず学習データを作成することが出来て、後述するグラフデータと同様の結果が得られました。普通はこの学習済みのデータを使えば強いプログラムが完成したということになります。でもこのままだと乱数で指し手を決める弱いプログラムと対戦させた時に勝率が上がりません。弱いプログラムの指し手を教師データとして学習してしまうので、勝率グラフはほぼ５割の横ばい状態になってしまいます（実際に試しました）。どんな対戦相手でも対戦する度に強くなるようにするために、勝った方の指し手を教師データとして重みを更新するように修正しました。簡単に言うと今までは「AI側の指し手を元に勝ったらAIの手番の局面データの重みを加算、負けたら減算」&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;としていたのを「勝っても負けても勝った方の指し手を教師データとして、勝った方の手番の局面データの重みを勾配法を使って誤差修正する」というやり方に変えたということです。実際に取り組んでみないと分かりづらいかもしれませんが、学習済みデータを作ることと、対戦しながら強くなるプログラムを作ることは少し違うってことです。興味のある方はソースのPlayer.learningメソッドを参照して下さい。&lt;br /&gt;
　あと、引き分けの時はどうするかという問題もあったのですが、相手のデータを教師データとして誤差修正するようにしました。学習中のAI側が最強プログラムに対して偶然引き分けに持ち込んだ時でも最強プログラムの指し手を教師データとして学習するようにするためです。&lt;/p&gt;

&lt;h5 id=&quot;-最強プログラムとの対戦結果-&quot;&gt;– 最強プログラムとの対戦結果 –&lt;/h5&gt;

&lt;div id=&quot;neural_saikyo&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;new_saikyo&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　上の２つのグラフのうち下側のグラフは&lt;a href=&quot;/project/2016-12-23/compressed_gametree&quot;&gt;以前掲載したグラフ&lt;/a&gt;と同じ（現在リリース中の&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;と同じ）ものです。上側のニューラルネットワークのグラフは下側のグラフに比べると、一気に学習が進んで引き分け率（対最強プログラムなので勝つことは出来ない）が９０％程度に上昇しますが、その後８０％〜９９％の間を行ったり来たりしています。何度か試しましたがこの傾向は変わらないようで、一様に強くなり続けるというわけにはいかないようです。これが&lt;strong&gt;過学習&lt;/strong&gt;というやつでしょうか？同じプログラム相手に10,000回も学習させる必要はないと言うことでしょう。このグラフを見る限り1,000回程度対戦させれば学習がピークに達するようです。対して従来の方法はニューラルネットワークに比べると学習速度は劣りますが、学習がピークに達した後も安定して指し手を間違えない（負けない手、最善手を選ぶ）ようです。&lt;/p&gt;

&lt;h5 id=&quot;-乱数プログラムとの対戦結果-&quot;&gt;– 乱数プログラムとの対戦結果 –&lt;/h5&gt;
&lt;div id=&quot;neural_random&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;new_random&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　乱数で指し手を決める弱いプログラム相手でも、今までより対戦回数が少ない段階で勝率が上がっていることがわかります。個人的には重みデータの総量が減ったことが学習速度がアップした大きな要因（&lt;a href=&quot;/software/2016-01-07/correlation&quot;&gt;過去記事参照&lt;/a&gt;）になった気がしてます。&lt;/p&gt;

&lt;h3 id=&quot;学習速度アップは歴然&quot;&gt;&lt;del&gt;学習速度アップは歴然&lt;/del&gt;&lt;/h3&gt;
&lt;p&gt;　&lt;del&gt;過学習という問題はあるものの、ニューラルネットワークを採用することでご褒美を上げたり取ったり（足したり引いたり）するより学習速度がアップすることは間違いないようです。&lt;/del&gt;でも現在リリース中の&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;は&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;に書かれている仕様に合わせて作っていることを謳っているので今のまま変更せずに、次アプリにする予定の「消える三目並べ」に採用してみようと思ってます。試してみたいと思うテーマが次々と出てきてなかなかリリース出来ないのですが、どこかでまず一度リリースしようと思ってます。本当は「５五将棋」アプリを作りたいのですが…&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
function show_new_saikyo(){
    var new_lose = [];
    var new_win = [[1, 87],[2, 57],[3, 65],[4, 53],[5, 59],[6, 47],[7, 41],[8, 42],[9, 35],[10, 31],[11, 32],[12, 32],[13, 20],[14, 22],[15, 18],[16, 20],[17, 12],[18, 14],[19, 7],[20, 12],[21, 8],[22, 8],[23, 9],[24, 8],[25, 3],[26, 9],[27, 5],[28, 6],[29, 3],[30, 5],[31, 4],[32, 2],[33, 4],[34, 3],[35, 5],[36, 5],[37, 2],[38, 9],[39, 6],[40, 1],[41, 4],[42, 3],[43, 4],[44, 4],[45, 3],[46, 4],[47, 1],[48, 1],[49, 1],[50, 5],[51, 1],[52, 2],[53, 3],[54, 1],[55, 4],[56, 3],[57, 1],[58, 3],[59, 1],[60, 1],[61, 1],[62, 5],[63, 4],[64, 3],[65, 4],[66, 3],[67, 1],[68, 4],[69, 1],[70, 0],[71, 3],[72, 4],[73, 2],[74, 4],[75, 2],[76, 4],[77, 5],[78, 0],[79, 2],[80, 0],[81, 0],[82, 0],[83, 3],[84, 1],[85, 0],[86, 0],[87, 0],[88, 1],[89, 0],[90, 2],[91, 1],[92, 4],[93, 0],[94, 1],[95, 1],[96, 3],[97, 0],[98, 2],[99, 2],[100, 1],];
    var new_draw = [[1 ,13],[2 ,43],[3 ,35],[4 ,47],[5 ,41],[6 ,53],[7 ,59],[8 ,58],[9 ,65],[10 ,69],[11 ,68],[12 ,68],[13 ,80],[14 ,78],[15 ,82],[16 ,80],[17 ,88],[18 ,86],[19 ,93],[20 ,88],[21 ,92],[22 ,92],[23 ,91],[24 ,92],[25 ,97],[26 ,91],[27 ,95],[28 ,94],[29 ,97],[30 ,95],[31 ,96],[32 ,98],[33 ,96],[34 ,97],[35 ,95],[36 ,95],[37 ,98],[38 ,91],[39 ,94],[40 ,99],[41 ,96],[42 ,97],[43 ,96],[44 ,96],[45 ,97],[46 ,96],[47 ,99],[48 ,99],[49 ,99],[50 ,95],[51 ,99],[52 ,98],[53 ,97],[54 ,99],[55 ,96],[56 ,97],[57 ,99],[58 ,97],[59 ,99],[60 ,99],[61 ,99],[62 ,95],[63 ,96],[64 ,97],[65 ,96],[66 ,97],[67 ,99],[68 ,96],[69 ,99],[70 ,100],[71 ,97],[72 ,96],[73 ,98],[74 ,96],[75 ,98],[76 ,96],[77 ,95],[78 ,100],[79 ,98],[80 ,100],[81 ,100],[82 ,100],[83 ,97],[84 ,99],[85 ,100],[86 ,100],[87 ,99],[88 ,99],[89 ,100],[90 ,98],[91 ,99],[92 ,96],[93 ,100],[94 ,99],[95 ,99],[96 ,97],[97 ,100],[98 ,98],[99 ,98],[100 ,99]];

    Flotr.draw(
        document.getElementById(&quot;new_saikyo&quot;),
        [
            {data: new_lose, label: &quot;勝ち&quot;},
            {data: new_win, label: &quot;負け&quot;},
            {data: new_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の方法、重みを加減算&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_neural_saikyo(){
    var old_lose = [];
    var old_win = [[1, 80],[2, 71],[3, 43],[4, 29],[5, 17],[6, 19],[7, 10],[8, 20],[9, 17],[10, 12],[11, 17],[12, 8],[13, 9],[14, 5],[15, 12],[16, 9],[17, 8],[18, 12],[19, 7],[20, 6],[21, 9],[22, 9],[23, 19],[24, 8],[25, 17],[26, 12],[27, 8],[28, 5],[29, 7],[30, 4],[31, 8],[32, 11],[33, 7],[34, 8],[35, 8],[36, 7],[37, 6],[38, 3],[39, 12],[40, 10],[41, 7],[42, 9],[43, 9],[44, 7],[45, 20],[46, 23],[47, 12],[48, 12],[49, 10],[50, 11],[51, 4],[52, 11],[53, 13],[54, 8],[55, 4],[56, 14],[57, 11],[58, 9],[59, 6],[60, 6],[61, 10],[62, 14],[63, 9],[64, 5],[65, 8],[66, 5],[67, 5],[68, 6],[69, 5],[70, 6],[71, 4],[72, 3],[73, 6],[74, 4],[75, 15],[76, 14],[77, 6],[78, 4],[79, 3],[80, 8],[81, 10],[82, 8],[83, 12],[84, 12],[85, 10],[86, 12],[87, 12],[88, 11],[89, 10],[90, 5],[91, 9],[92, 5],[93, 12],[94, 5],[95, 4],[96, 3],[97, 12],[98, 11],[99, 4],[100, 9]];
    var old_draw = [[1 ,20],[2 ,29],[3 ,57],[4 ,71],[5 ,83],[6 ,81],[7 ,90],[8 ,80],[9 ,83],[10 ,88],[11 ,83],[12 ,92],[13 ,91],[14 ,95],[15 ,88],[16 ,91],[17 ,92],[18 ,88],[19 ,93],[20 ,94],[21 ,91],[22 ,91],[23 ,81],[24 ,92],[25 ,83],[26 ,88],[27 ,92],[28 ,95],[29 ,93],[30 ,96],[31 ,92],[32 ,89],[33 ,93],[34 ,92],[35 ,92],[36 ,93],[37 ,94],[38 ,97],[39 ,88],[40 ,90],[41 ,93],[42 ,91],[43 ,91],[44 ,93],[45 ,80],[46 ,77],[47 ,88],[48 ,88],[49 ,90],[50 ,89],[51 ,96],[52 ,89],[53 ,87],[54 ,92],[55 ,96],[56 ,86],[57 ,89],[58 ,91],[59 ,94],[60 ,94],[61 ,90],[62 ,86],[63 ,91],[64 ,95],[65 ,92],[66 ,95],[67 ,95],[68 ,94],[69 ,95],[70 ,94],[71 ,96],[72 ,97],[73 ,94],[74 ,96],[75 ,85],[76 ,86],[77 ,94],[78 ,96],[79 ,97],[80 ,92],[81 ,90],[82 ,92],[83 ,88],[84 ,88],[85 ,90],[86 ,88],[87 ,88],[88 ,89],[89 ,90],[90 ,95],[91 ,91],[92 ,95],[93 ,88],[94 ,95],[95 ,96],[96 ,97],[97 ,88],[98 ,89],[99 ,96],[100 ,91]];

    Flotr.draw(
        document.getElementById(&quot;neural_saikyo&quot;),
        [
            {data: old_lose, label: &quot;勝ち&quot;},
            {data: old_win, label: &quot;負け&quot;},
            {data: old_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;ニューラルネットワーク、勾配法&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_new_random(){
    var new_lose = [[1, 36],[2, 43],[3, 49],[4, 39],[5, 51],[6, 55],[7, 62],[8, 51],[9, 51],[10, 66],[11, 56],[12, 61],[13, 60],[14, 60],[15, 69],[16, 62],[17, 78],[18, 58],[19, 67],[20, 67],[21, 72],[22, 66],[23, 71],[24, 65],[25, 62],[26, 69],[27, 74],[28, 69],[29, 72],[30, 67],[31, 64],[32, 65],[33, 79],[34, 68],[35, 73],[36, 76],[37, 81],[38, 72],[39, 80],[40, 76],[41, 65],[42, 67],[43, 70],[44, 69],[45, 74],[46, 75],[47, 68],[48, 78],[49, 73],[50, 76],[51, 74],[52, 74],[53, 66],[54, 70],[55, 79],[56, 80],[57, 79],[58, 74],[59, 73],[60, 62],[61, 81],[62, 69],[63, 81],[64, 77],[65, 75],[66, 75],[67, 83],[68, 70],[69, 72],[70, 76],[71, 77],[72, 78],[73, 77],[74, 73],[75, 74],[76, 81],[77, 79],[78, 80],[79, 82],[80, 81],[81, 81],[82, 76],[83, 78],[84, 80],[85, 66],[86, 81],[87, 76],[88, 75],[89, 78],[90, 83],[91, 82],[92, 77],[93, 79],[94, 76],[95, 72],[96, 79],[97, 73],[98, 86],[99, 77],[100, 79],];
    var new_win = [[1, 48],[2, 41],[3, 36],[4, 45],[5, 33],[6, 29],[7, 28],[8, 27],[9, 31],[10, 21],[11, 28],[12, 26],[13, 24],[14, 25],[15, 14],[16, 21],[17, 10],[18, 21],[19, 17],[20, 22],[21, 16],[22, 12],[23, 13],[24, 17],[25, 17],[26, 16],[27, 17],[28, 10],[29, 19],[30, 18],[31, 20],[32, 18],[33, 12],[34, 15],[35, 10],[36, 9],[37, 9],[38, 18],[39, 10],[40, 14],[41, 19],[42, 20],[43, 16],[44, 11],[45, 9],[46, 7],[47, 14],[48, 16],[49, 16],[50, 13],[51, 12],[52, 14],[53, 17],[54, 14],[55, 10],[56, 10],[57, 13],[58, 10],[59, 9],[60, 20],[61, 9],[62, 18],[63, 10],[64, 8],[65, 14],[66, 11],[67, 7],[68, 15],[69, 17],[70, 12],[71, 12],[72, 6],[73, 11],[74, 14],[75, 15],[76, 5],[77, 14],[78, 11],[79, 10],[80, 10],[81, 6],[82, 13],[83, 8],[84, 4],[85, 17],[86, 9],[87, 11],[88, 12],[89, 10],[90, 7],[91, 11],[92, 9],[93, 12],[94, 16],[95, 12],[96, 12],[97, 15],[98, 7],[99, 7],[100, 9],];
    var new_draw = [[1 ,16],[2 ,16],[3 ,15],[4 ,16],[5 ,16],[6 ,16],[7 ,10],[8 ,22],[9 ,18],[10 ,13],[11 ,16],[12 ,13],[13 ,16],[14 ,15],[15 ,17],[16 ,17],[17 ,12],[18 ,21],[19 ,16],[20 ,11],[21 ,12],[22 ,22],[23 ,16],[24 ,18],[25 ,21],[26 ,15],[27 ,9],[28 ,21],[29 ,9],[30 ,15],[31 ,16],[32 ,17],[33 ,9],[34 ,17],[35 ,17],[36 ,15],[37 ,10],[38 ,10],[39 ,10],[40 ,10],[41 ,16],[42 ,13],[43 ,14],[44 ,20],[45 ,17],[46 ,18],[47 ,18],[48 ,6],[49 ,11],[50 ,11],[51 ,14],[52 ,12],[53 ,17],[54 ,16],[55 ,11],[56 ,10],[57 ,8],[58 ,16],[59 ,18],[60 ,18],[61 ,10],[62 ,13],[63 ,9],[64 ,15],[65 ,11],[66 ,14],[67 ,10],[68 ,15],[69 ,11],[70 ,12],[71 ,11],[72 ,16],[73 ,12],[74 ,13],[75 ,11],[76 ,14],[77 ,7],[78 ,9],[79 ,8],[80 ,9],[81 ,13],[82 ,11],[83 ,14],[84 ,16],[85 ,17],[86 ,10],[87 ,13],[88 ,13],[89 ,12],[90 ,10],[91 ,7],[92 ,14],[93 ,9],[94 ,8],[95 ,16],[96 ,9],[97 ,12],[98 ,7],[99 ,16],[100 ,12]];

    Flotr.draw(
        document.getElementById(&quot;new_random&quot;),
        [
            {data: new_lose, label: &quot;勝ち&quot;},
            {data: new_win, label: &quot;負け&quot;},
            {data: new_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の方法、重みを加減算&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}
    
function show_neural_random(){
    var old_lose = [[1, 51],[2, 55],[3, 48],[4, 57],[5, 58],[6, 61],[7, 72],[8, 72],[9, 75],[10, 73],[11, 79],[12, 75],[13, 69],[14, 85],[15, 85],[16, 83],[17, 84],[18, 84],[19, 81],[20, 82],[21, 88],[22, 79],[23, 84],[24, 82],[25, 85],[26, 88],[27, 83],[28, 85],[29, 85],[30, 85],[31, 91],[32, 85],[33, 89],[34, 86],[35, 86],[36, 85],[37, 81],[38, 81],[39, 85],[40, 71],[41, 91],[42, 88],[43, 89],[44, 89],[45, 89],[46, 86],[47, 95],[48, 89],[49, 89],[50, 83],[51, 92],[52, 88],[53, 87],[54, 84],[55, 90],[56, 87],[57, 89],[58, 91],[59, 91],[60, 90],[61, 91],[62, 95],[63, 89],[64, 89],[65, 88],[66, 92],[67, 89],[68, 89],[69, 91],[70, 86],[71, 93],[72, 91],[73, 86],[74, 91],[75, 86],[76, 88],[77, 85],[78, 85],[79, 90],[80, 87],[81, 90],[82, 89],[83, 86],[84, 89],[85, 87],[86, 85],[87, 87],[88, 89],[89, 90],[90, 87],[91, 86],[92, 94],[93, 86],[94, 87],[95, 85],[96, 92],[97, 91],[98, 84],[99, 91],[100, 89]];
    var old_win = [[1, 43],[2, 30],[3, 41],[4, 32],[5, 28],[6, 31],[7, 14],[8, 18],[9, 18],[10, 20],[11, 12],[12, 11],[13, 24],[14, 11],[15, 4],[16, 8],[17, 9],[18, 7],[19, 15],[20, 14],[21, 6],[22, 13],[23, 11],[24, 12],[25, 10],[26, 10],[27, 11],[28, 8],[29, 8],[30, 7],[31, 4],[32, 7],[33, 6],[34, 7],[35, 18],[36, 8],[37, 9],[38, 7],[39, 9],[40, 14],[41, 6],[42, 6],[43, 4],[44, 4],[45, 6],[46, 6],[47, 3],[48, 7],[49, 7],[50, 10],[51, 3],[52, 6],[53, 6],[54, 10],[55, 6],[56, 5],[57, 5],[58, 3],[59, 1],[60, 5],[61, 7],[62, 1],[63, 5],[64, 5],[65, 2],[66, 4],[67, 6],[68, 5],[69, 2],[70, 3],[71, 2],[72, 5],[73, 6],[74, 2],[75, 9],[76, 7],[77, 5],[78, 7],[79, 8],[80, 2],[81, 4],[82, 6],[83, 9],[84, 3],[85, 8],[86, 8],[87, 6],[88, 7],[89, 1],[90, 5],[91, 4],[92, 6],[93, 5],[94, 6],[95, 6],[96, 4],[97, 2],[98, 9],[99, 4],[100, 4],];
    var old_draw = [[1 ,6],[2 ,15],[3 ,11],[4 ,11],[5 ,14],[6 ,8],[7 ,14],[8 ,10],[9 ,7],[10 ,7],[11 ,9],[12 ,14],[13 ,7],[14 ,4],[15 ,11],[16 ,9],[17 ,7],[18 ,9],[19 ,4],[20 ,4],[21 ,6],[22 ,8],[23 ,5],[24 ,6],[25 ,5],[26 ,2],[27 ,6],[28 ,7],[29 ,7],[30 ,8],[31 ,5],[32 ,8],[33 ,5],[34 ,7],[35 ,4],[36 ,7],[37 ,10],[38 ,12],[39 ,6],[40 ,15],[41 ,3],[42 ,6],[43 ,7],[44 ,7],[45 ,5],[46 ,8],[47 ,2],[48 ,4],[49 ,4],[50 ,7],[51 ,5],[52 ,6],[53 ,7],[54 ,6],[55 ,4],[56 ,8],[57 ,6],[58 ,6],[59 ,8],[60 ,5],[61 ,2],[62 ,4],[63 ,6],[64 ,6],[65 ,10],[66 ,4],[67 ,5],[68 ,6],[69 ,7],[70 ,11],[71 ,5],[72 ,4],[73 ,8],[74 ,7],[75 ,5],[76 ,5],[77 ,10],[78 ,8],[79 ,2],[80 ,11],[81 ,6],[82 ,5],[83 ,5],[84 ,8],[85 ,5],[86 ,7],[87 ,7],[88 ,4],[89 ,9],[90 ,8],[91 ,10],[92 ,0],[93 ,9],[94 ,7],[95 ,9],[96 ,4],[97 ,7],[98 ,7],[99 ,5],[100 ,7]];

    Flotr.draw(
        document.getElementById(&quot;neural_random&quot;),
        [
            {data: old_lose, label: &quot;勝ち&quot;},
            {data: old_win, label: &quot;負け&quot;},
            {data: old_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;ニューラルネットワーク、勾配法&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

window.onload = function() {
    show_new_saikyo();
    show_neural_saikyo();
    show_new_random();
    show_neural_random();
};
&lt;/script&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;ディープラーニングやニューラルネットワークに関する本をいろいろ読みましたが、個人的にはこの本が一番実践に役立つ気がします。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;なぜ勝ちは＋３，引き分けは＋１，負けは−１がいいのかという根拠は&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;にも明確には書かれていません。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;今までのやり方だと最強プログラムと対戦した場合には引き分けに持ち込んだ時にしか重みの加算が行われない状態でした（最強プログラムには絶対勝てないので＋３を得る機会はない）。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>「消える三目並べ」もう少しテスト</title>
   <link href="https://happyclam.github.io/programming/2017-05-27/vanishing-tictactoe3"/>
   <updated>2017-05-27T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2017-05-27/vanishing-tictactoe3</id>
   <content type="html">&lt;h3 id=&quot;全然強くない&quot;&gt;全然強くない&lt;/h3&gt;
&lt;p&gt;　前作（&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;）と同様の機能のまま「消える三目並べ」（３手前に打った自分の駒が消えるルールの三目並べ）のアプリをリリースしようと思っていたのですが、いざ作成した「消える三目並べ」のアプリをスマホにインストールしてテストしてみるとあまりにもAIが弱い。それに前作の通常の三目並べ版だと学習データが真っさらの状態から300回程度対戦すると先手の時はほぼ必ず真ん中に駒を打つようになり、成長する過程が実感できるのに対して、「消える三目並べ」版だと強くなっていく過程が全然実感できませんでした。自分が「消える三目並べ」というゲームに慣れてきて強くなった所為もあると思いますが…。&lt;br /&gt;
　と、いうことでAIの成長を実感できないので前作のように進化する過程を画像で表現する機能はやめて、とりあえずもう少し強くする方法を試行錯誤しました。AIが思ったほど強くならないのは、やはり通常の三目並べの全局面数が6,046ノード（回転・対照形を省くと627ノード）&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;であるのに対して、「消える三目並べ」では79,210ノード&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;と２桁以上増える違いは大きかったようです。&lt;/p&gt;

&lt;h3 id=&quot;なかなか強くならない原因&quot;&gt;なかなか強くならない原因&lt;/h3&gt;
&lt;p&gt;　以前&lt;a href=&quot;/programming/2016-11-23/vanishing-tictactoe&quot;&gt;「「消える三目並べ」は、学習が速い」&lt;/a&gt;という記事で、MIN-MAX法を使った最強プログラムと1,500回程度対戦させると、勝ち負けがほぼ互角になることを書きました。最強のプログラムと互角なので十分強いだろうと思っていたのですが、最強プログラムの方はいつも同じ手を指すようになっていたので私がテストに使った自作の最強プログラムに対してだけ強くなっているだけのことでした&lt;img class=&quot;emoji&quot; title=&quot;sob&quot; alt=&quot;sob&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sob.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　ちょっと考えれば分かりそうなものですが、通常の三目並べならそれで上手くいっていたので深く考えてませんでした&lt;img class=&quot;emoji&quot; title=&quot;cold_sweat&quot; alt=&quot;cold_sweat&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/cold_sweat.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;もちろん通常の三目並べのテストで使用した最強プログラムも、いつも同じ手で勝つプログラム（プログラム内で乱数を使用していない）でしたが、通常の三目並べの場合ノード（局面のパターン）の数がたった627ノードだったので、数千回の対戦でほぼすべてのノードに対して何度も学習データが蓄積されていきますが、「消える三目並べ」で数千回対戦してもほとんどのノードの学習データは初期状態のままです。同じノードに対して何度も何度も学習データを蓄積していく必要があるため、例え数千回対戦させたとしても十分ではなさそうです。&lt;br /&gt;
　前作（&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;）は、AIの成長過程を楽しんで貰うという意図もあったのですが、「消える三目並べ」では一回の対戦で得られる学習効果が非常に薄いため成長を楽しむのは無理そうだと思い、学習度合いを生物の進化に例えて表示する機能は取りやめることにしました。&lt;/p&gt;

&lt;h3 id=&quot;弱すぎるアプリの改善方法&quot;&gt;弱すぎるアプリの改善方法&lt;/h3&gt;
&lt;p&gt;　アプリが弱すぎることの解決策として予め学習済みのデータをアプリの初期データとして同梱してリリースすることにしたのですが、まずテストに使用しているMIN-MAX法を使った最強プログラムに修正を加え、いつも同じ手を指さないように局面の評価値が同じ場合はその都度２分の１の確率で指し手を分散させるようにして学習させることにしました。その状態で勝数の遷移をグラフにしたものが以下です。&lt;/p&gt;

&lt;div id=&quot;vanishing-tictactoe&quot; style=&quot;width:600px;height:400px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;button id=&quot;unzoom&quot;&gt;元に戻す&lt;/button&gt;&lt;span&gt;　※範囲をドラッグすれば、グラフを zoom up 出来ます&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　赤と黄色のグラフは&lt;a href=&quot;/programming/2016-11-23/vanishing-tictactoe&quot;&gt;以前の記事&lt;/a&gt;と同じものです。今回同じ評価値なら指し手をランダムに変更するように改良した最強プログラムとの対戦勝率（水色のグラフ）は5,000回対戦後でも３０％程度でまだまだ学習が足りないのがわかります。今まで同じ指し手しか選ばない最強プログラムでテストして、勝率５割になったから学習完了した（＝強くなった）と勘違いしていたわけです。本来なら最初からこのプログラムでテストするべきでした&lt;img class=&quot;emoji&quot; title=&quot;cold_sweat&quot; alt=&quot;cold_sweat&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/cold_sweat.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;。このプログラムを使って作った学習データをアプリの初期データとしてリリースしようかと思ってます。でも、以前にも書きましたが最強プログラムとの対戦テストは時間が掛るのが辛いところです。このわずか5,000回の対戦データを作成するためにCore i7-2600KのPCを約３日間稼働しっぱなしでした。&lt;br /&gt;
　ちなみにグラフにはしませんでしたが、対乱数プログラムとの対戦テストなら対最強プログラムのように時間はかからないので100,000回まで試してみました。すると勝率（赤のグラフ）は９割以上まで伸びました&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;が、その学習データを使ってアプリにして遊んでみても全然強さを感じさせるものにはなっていませんでした。以前から書いてますが、いくら乱数プログラムとの対戦学習（モンテカルロ法を使った強化学習）を続けても効果は薄そうです。&lt;/p&gt;

&lt;h3 id=&quot;その他の方法&quot;&gt;その他の方法&lt;/h3&gt;
&lt;p&gt;　学習させたい機械学習プログラム側の学習データ作成部分だけを使用して最強プログラム同士で対戦させれば、最強プログラムの指し手そのものを学習データに反映させることもできます。これはプログラムが自分で学習するのとは異なり、最強プログラムの手を真似るデータを定跡データとして学習データに反映させていることになります。こうした定跡データを使った方法や、何も学習していない状態から学習プログラム同士で対戦を重ねて学習データを作る方法なども試しましたが、詳しく確認したわけでないですが思ったほど強くなりませんでした。強くなったかどうかをどのように判断してるのかという話もいろいろあるのですが、それほどたいそうな事はしてないのですが話が長くなるのでまた別の機会に書こうと思います。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
jQuery(function ($){

linegraph = function() {
    var equation1 = [[1 ,0],[2 ,0],[3 ,0],[4 ,0],[5 ,0],[6 ,0],[7 ,2],[8 ,1],[9 ,4],[10 ,9],[11 ,30],[12 ,34],[13 ,24],[14 ,40],[15 ,41],[16 ,50],[17 ,50],[18 ,52],[19 ,46],[20 ,49],[21 ,45],[22 ,53],[23 ,46],[24, 56],[25, 45],[26, 53],[27, 39],[28, 51],[29, 47],[30, 52],[31, 40],[32 ,43],[33 ,47],[34 ,54],[35 ,53],[36 ,45],[37 ,56],[38 ,58],[39 ,52],[40 ,44],[41 ,55],[42 ,45],[43 ,53],[44 ,54],[45 ,47],[46 ,49],[47 ,51],[48 ,51],[49 ,55],[50 ,48]];
    var equation2 = [[1 ,0],[2 ,0],[3 ,0],[4 ,2],[5 ,0],[6 ,0],[7 ,0],[8 ,3],[9 ,2],[10 ,1],[11 ,0],[12 ,1],[13 ,0],[14 ,0],[15 ,1],[16 ,0],[17 ,1],[18 ,1],[19 ,2],[20 ,0],[21 ,1],[22 ,2],[23 ,2],[24, 0],[25 ,2],[26 ,4],[27 ,3],[28 ,3],[29 ,4],[30 ,4],[31 ,4],[32 ,5],[33 ,2],[34 ,9],[35 ,6],[36, 6],[37, 14],[38, 7],[39, 13],[40, 20],[41, 19],[42, 20],[43, 11],[44, 14],[45, 16],[46, 34],[47, 20],[48, 33],[49, 33],[50, 27]];
//    var equation2 = [[1, 7.02],[2, 7.02],[3, 6.88],[4, 6.71],[5, 7.27],[6, 6.92],[7, 7.26],[8, 7.04],[9, 7.44],[10, 7.14],[11, 7.84],[12, 8.11],[13, 7.77],[14, 8.15],[15, 7.96],[16, 8.45],[17, 8.16],[18, 8.25],[19, 8.20],[20, 7.93],[21, 7.87],[22, 8.45],[23, 8.16],[24, 8.63],[25, 7.88],[26, 8.33],[27, 7.93],[28, 7.85],[29, 8.13],[30, 8.12],[31, 7.52],[32, 8.02],[33, 8.52],[34, 8.49],[35, 8.31],[36, 8.08],[37, 8.05],[38, 8.61],[39, 8.16],[40, 8.11],[41, 8.65],[42, 8.09],[43, 8.34],[44, 8.40],[45, 7.89],[46, 8.20],[47, 8.32],[48, 8.50],[49, 8.43],[50, 8.32]];
    var equation3 = [[1, 54],[2, 46],[3, 48],[4, 46],[5, 53],[6, 44],[7, 47],[8, 55],[9, 50],[10, 61],[11, 41],[12, 48],[13 ,52],[14, 53],[15, 44],[16, 48],[17, 52],[18, 49],[19, 52],[20, 54],[21, 57],[22, 55],[23, 53],[24, 57],[25, 61],[26, 54],[27, 54],[28, 49],[29, 57],[30, 58],[31, 65],[32, 58],[33, 55],[34, 59],[35, 49],[36, 62],[37, 55],[38, 61],[39, 61],[40, 65],[41, 67],[42, 54],[43, 56],[44, 55],[45, 60],[46, 58],[47, 53],[48, 61],[49, 57],[50, 49],[51, 66],[52, 62],[53, 51],[54, 59],[55, 60],[56, 59],[57, 60],[58, 60],[59, 60],[60, 70],[61, 64],[62, 62],[63, 60],[64, 64],[65, 65],[66, 65],[67, 59],[68, 67],[69, 63],[70, 58],[71, 64],[72, 66],[73, 65],[74, 70],[75, 67],[76, 72],[77, 66],[78, 67],[79, 69],[80, 66],[81, 59],[82, 64],[83, 57],[84, 56],[85, 61],[86, 67],[87, 65],[88, 66],[89, 64],[90, 65],[91, 64],[92, 63],[93, 60],[94, 63],[95, 60],[96, 71],[97, 64],[98, 65],[99, 69],[100, 64]];

    var $el = $(&quot;#vanishing-tictactoe&quot;),
        data = [
            {data: equation1, label: &quot;対最強プログラム勝数（同じ指し手）&quot;},
            {data: equation2, label: &quot;対最強プログラム勝数（ランダム指し手）&quot;},
            {data: equation3, label: &quot;対乱数プログラム勝数&quot;}
            ],
        options = {
            legend: {position: &quot;nw&quot;},
            selection: {mode: &quot;xy&quot;, color: &quot;#eeeeee&quot;},
            title: &quot;勝敗の推移&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            lines:{show: true, horizontal:false},
            xaxis:{
                max: 100,
                ticks: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, [100, &quot;×100回&quot;]],
                title: &quot;対戦回数（×１００）&quot;
            },
            yaxis:{
                ticks: 20,
                min: 0,
                max: 100,
                title: &quot;対戦結果（勝ち数／手数）&quot;
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }, plotObj;

    $el.on(&quot;plotselected&quot;, function(ev, ranges) {
        plotObj = $.plot($el, data,
                         $.extend(true, {}, options, {
                             xaxis: {min: ranges.xaxis.from, max: ranges.xaxis.to},
                             yaxis: {min: ranges.yaxis.from, max: ranges.yaxis.to}
                         })
                        );
    });
    plotObj = $.plot($el, data, options);
    $(&quot;#unzoom&quot;).click(function() {
        plotObj = $.plot($el, data, options);
    });
};

if (typeof contentLoaded != &quot;undefined&quot;) {
    contentLoaded.done(linegraph);
} else {
    window.addEventListener('load', linegraph);
}

});

&lt;/script&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/project/2016-12-23/compressed_gametree&quot;&gt;「三目並べのゲーム木データを間引く」&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/programming/2016-11-03/ml_miscellaneous2&quot;&gt;「消える三目並べ」、思ったより大変」&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;「消える三目並べ」というゲームは先手必勝のゲームなので、先手・後手をランダムに決める条件で勝率９割以上になるというのは、かなりの実力差（乱数で指し手を決めても先手の時は偶然最善手を選び続けて勝つ場合があるため）があると言えると思います。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>「消える三目並べ」の話の続き</title>
   <link href="https://happyclam.github.io/programming/2017-03-19/vanishing-tictactoe2"/>
   <updated>2017-03-19T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2017-03-19/vanishing-tictactoe2</id>
   <content type="html">&lt;h3 id=&quot;消える三目並べの対戦結果&quot;&gt;「消える三目並べ」の対戦結果&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/programming/2016-11-23/vanishing-tictactoe&quot;&gt;以前の記事&lt;/a&gt;の最後に「消える三目並べ」（３手前に打った自分の駒が消えるルールの三目並べ）の機械学習を使ったAndroidアプリを作ってみたけど、データが大きすぎて実用に堪えなかった話を書きました。いろいろ解決策を模索した結果、とりあえずデータが大きくなり過ぎる問題は解決しそうですがその話は改めて書くとして、今回はその新しく作ってみた機械学習プログラムのテストを兼ねて実施した学習度合いの進捗テストについてまた書いてみます。&lt;br /&gt;
　前回は先手と後手をランダムに決めてソフト同士の対戦をしたのですが、「消える三目並べ」というゲームの特性上、先手の時は最善手を選び続けると必ず勝つはずなのでその違いがわかるように先手の時と後手の時を分けてデータを取りました。前回の時はデータを取った後で気づいて後悔していたのでちょうどいい機会が出来ました。&lt;br /&gt;
　前回同様１００回の対戦を１回戦として対最強プログラムは５０回戦（＝５，０００回）、対乱数プログラムは１００回戦（＝１０，０００回）の対戦結果です。&lt;/p&gt;

&lt;div id=&quot;vanishing-tictactoe&quot; style=&quot;width:600px;height:400px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;button id=&quot;unzoom&quot;&gt;元に戻す&lt;/button&gt;&lt;span&gt;　※範囲をドラッグすれば、グラフを zoom up 出来ます&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;対最強プログラム&quot;&gt;対最強プログラム&lt;/h3&gt;
&lt;p&gt;　機械学習プログラムが先手で最強プログラムと対戦した黄色のグラフを見ると、６００回程度の対戦までは一度も勝てなかったのにその後急激に勝数を伸ばして先手なら必ず勝てることを学習した様子がよくわかります。この結果は前回と同じですが、&lt;a href=&quot;/programming/2016-11-23/vanishing-tictactoe&quot;&gt;前回の記事&lt;/a&gt;では、先手・後手をランダムに決めていたので勝率が約５０％にまでしか伸びませんでしたが、今回は先手番限定のテストなので１００％にまで勝率を伸ばしています。勝率１００％まで行ってから９０数％に何度か勝率を落としていますが、これは確率による指し手の選択をしている以上仕方がありません。MIN-MAX法で１１手先までの全局面を完全に読み切って常に最善手を選ぶ最強プログラムに対して、機械学習プログラムの方は経験（モンテカルロ法による強化学習）から最善手を選ぶ確率を上げているだけなのでこうなります。将棋や囲碁のように今のコンピュータでは全局面探索出来ないゲームに関して、機械学習が重宝されているのも頷けます。&lt;br /&gt;
　今度は後手の時のグラフ（水色のグラフ）を見ると、最強プログラムに一度も勝てないままグラフでは見難いのですが０のまま横一直線のグラフになっています。先手必勝のゲームで後手番を持って最強プログラムと対戦しているわけですから一勝も出来ないのは当然の結果です。これはテストに使用している最強プログラムにバグがない（先手番では必ず勝つ）ということでもあるので安心しました&lt;img class=&quot;emoji&quot; title=&quot;smile&quot; alt=&quot;smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;あと、先手必勝のゲームをアプリにして楽しいのか？という問題もあるのですが、先手必勝と言っても１１手読みが必要なので人間ではなかなか難しいのではないかと思います。「どうぶつしょうぎ」も後手必勝のゲームだそうですが、人間が遊ぶ分にはそれなりに楽しめるのではないかと思ってます。自分が試している感じではとても先手番になったからと言って必ず勝てるとは思えない「消える三目並べ」ですが、それを極めるのも楽しみ方の一つかもしれません。&lt;br /&gt;
　ところで、後手必勝らしい「どうぶつしょうぎ」で、「自分が後手なら必ず勝てる」と言い切れる人ってどれ位いるのでしょうか？興味があります&lt;img class=&quot;emoji&quot; title=&quot;smile&quot; alt=&quot;smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;対乱数プログラム&quot;&gt;対乱数プログラム&lt;/h3&gt;
&lt;p&gt;　次に対乱数プログラムにおける勝率の推移を見てみると、先手番（赤色のグラフ）の方が明らかに後手番（緑色のグラフ）より速く学習が進んでいます（勝率の上がり方が速い）。これは機械学習プログラム自身が「消える三目並べ」というゲームの特徴を見出したと表現していいのでしょうか&lt;img class=&quot;emoji&quot; title=&quot;question&quot; alt=&quot;question&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/question.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;「どうやらこのゲームは先手の方が勝ち易いぞ」ということをAI自身が発見したと&lt;img class=&quot;emoji&quot; title=&quot;confused&quot; alt=&quot;confused&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/confused.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　機械学習プログラムが最強プログラムと対戦して、勝てるはずの先手の時に勝つことを学んでいくのはなんとなく分かるというか、最強プログラムという先生に教わっていくのだから強くなるのだろうと理解できます&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。でも先生でもない単にサイコロを振るように決めた手を選択する乱数プログラムと対戦させて、先手と後手で傾向の違いが出るというのがちょっと意外でした。「何を言ってるんだ、乱数を使うからモンテカルロ法による強化学習だろ」と言われるのかもしれませんが、先手と後手で学習度合いに違いが出るのであれば、もしかしてこれを将棋に応用したら将棋というゲームが先手必勝か、後手必勝か分かるのではないか&lt;img class=&quot;emoji&quot; title=&quot;flushed&quot; alt=&quot;flushed&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/flushed.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;と思ったわけです。将棋版の機械学習プログラムとランダムに指し手を決める将棋プログラムを用意して対戦させてみればいいだけです。そして先手の時の方が後手の時より勝率の上がり方が速ければ将棋は先手必勝のゲームと推測出来るように思えます。将棋で起こりうるすべてのパターンを確認しなくても、何万回か対戦させれば傾向がわかるのではないか？と。でもよく考えてみると将棋の場合はランダムに指し手を決めて対戦させてみてもゲームがなかなか終わってくれないので、囲碁やオセロのようにマス目が埋まれば必ず終わるゲームと違って難しいのでしょう&lt;img class=&quot;emoji&quot; title=&quot;disappointed&quot; alt=&quot;disappointed&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/disappointed.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;おそらく&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。「消える三目並べ」もマス目が埋まれば終了する類いのゲームと違う（長い対戦では２０手以上続きます）ので将棋と事情は同じなのですが、「消える三目並べ」程度の局面数ならなんとかなるということでしょう。最強プログラムで使用している先読みと評価関数を使ったやり方も機械学習を使ったやり方も、将棋というゲームの完全解析（先手or後手必勝定跡の発見等）は&lt;a href=&quot;https://ja.wikipedia.org/wiki/組合せ爆発&quot;&gt;指数爆発（組合せ爆発）&lt;/a&gt;の壁があるので難しいという事情は同じだということでしょう。&lt;br /&gt;
　ただ、今回のテスト結果を見てもわかる通り、ソフトを学習させる場合にはヘボ将棋の棋譜（対乱数プログラム）を使うより、プロ棋士の棋譜（最強プログラム）を使うほうが速く学習するのは間違い無さそうです。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
jQuery(function ($){

linegraph = function() {
    var equation1 = [[1 ,0],[2 ,0],[3 ,0],[4 ,0],[5 ,0],[6 ,0],[7 ,4],[8 ,5],[9 ,33],[10 ,62],[11 ,79],[12 ,92],[13 ,91],[14 ,91],[15 ,95],[16 ,98],[17 ,99],[18 ,99],[19 ,95],[20 ,98],[21 ,96],[22 ,99],[23 ,100],[24, 100],[25, 96],[26, 100],[27, 100],[28, 100],[29, 99],[30, 99],[31, 99],[32 ,100],[33 ,100],[34 ,100],[35 ,99],[36 ,100],[37 ,99],[38 ,100],[39 ,98],[40 ,100],[41 ,100],[42 ,98],[43 ,99],[44 ,100],[45 ,99],[46 ,100],[47 ,100],[48 ,100],[49 ,100],[50 ,99]];
    var equation2 = [[1, 0],[2, 0],[3, 0],[4, 0],[5, 0],[6, 0],[7, 0],[8, 0],[9, 0],[10, 0],[11, 0],[12, 0],[13, 0],[14, 0],[15, 0],[16, 0],[17, 0],[18, 0],[19, 0],[20, 0],[21, 0],[22, 0],[23, 0],[24, 0],[25, 0],[26, 0],[27, 0],[28, 0],[29, 0],[30, 0],[31, 0],[32, 0],[33, 0],[34, 0],[35, 0],[36, 0],[37, 0],[38, 0],[39, 0],[40, 0],[41, 0],[42, 0],[43, 0],[44, 0],[45, 0],[46, 0],[47, 0],[48, 0],[49, 0],[50, 0]];
    var equation3 = [[1, 55],[2, 50],[3, 45],[4, 46],[5, 48],[6, 50],[7, 48],[8, 65],[9, 59],[10, 60],[11, 54],[12, 56],[13, 67],[14, 59],[15, 59],[16, 64],[17, 54],[18, 58],[19, 61],[20, 57],[21, 64],[22, 57],[23, 59],[24, 60],[25, 64],[26, 68],[27, 57],[28, 53],[29, 74],[30, 62],[31, 67],[32, 57],[33, 70],[34, 61],[35, 66],[36, 70],[37, 62],[38, 67],[39, 63],[40, 70],[41, 69],[42, 70],[43, 67],[44, 73],[45, 67],[46, 68],[47, 57],[48, 73],[49, 76],[50, 72],[51, 71],[52, 75],[53, 72],[54, 72],[55, 73],[56, 78],[57, 72],[58, 79],[59, 77],[60, 73],[61, 75],[62, 77],[63, 83],[64, 76],[65, 78],[66, 75],[67, 75],[68, 71],[69, 75],[70, 74],[71, 77],[72, 80],[73, 76],[74, 76],[75, 77],[76, 79],[77, 82],[78, 85],[79, 85],[80, 79],[81, 74],[82, 73],[83, 89],[84, 83],[85, 76],[86, 81],[87, 83],[88, 76],[89, 80],[90, 79],[91, 78],[92, 75],[93, 83],[94, 85],[95, 81],[96, 81],[97, 83],[98, 86],[99, 75],[100, 77]];
    var equation4 = [[1, 55],[2, 50],[3, 46],[4, 43],[5, 42],[6, 44],[7, 46],[8, 45],[9, 45],[10, 44],[11, 51],[12, 45],[13, 48],[14, 49],[15, 44],[16, 44],[17, 40],[18, 48],[19, 45],[20, 45],[21, 50],[22, 50],[23, 49],[24, 50],[25, 62],[26, 52],[27, 43],[28, 48],[29, 50],[30, 51],[31, 51],[32, 43],[33, 53],[34, 49],[35, 51],[36, 44],[37, 51],[38, 57],[39, 41],[40, 47],[41, 63],[42, 46],[43, 53],[44, 62],[45, 55],[46, 50],[47, 45],[48, 49],[49, 57],[50, 51],[51, 48],[52, 59],[53, 49],[54, 50],[55, 53],[56, 51],[57, 46],[58, 48],[59, 54],[60, 42],[61, 56],[62, 56],[63, 52],[64, 55],[65, 47],[66, 62],[67, 54],[68, 58],[69, 54],[70, 50],[71, 55],[72, 56],[73, 54],[74, 58],[75, 56],[76, 54],[77, 55],[78, 52],[79, 42],[80, 53],[81, 52],[82, 49],[83, 59],[84, 53],[85, 46],[86, 61],[87, 61],[88, 53],[89, 60],[90, 56],[91, 59],[92, 55],[93, 54],[94, 69],[95, 55],[96, 63],[97, 56],[98, 52],[99, 59],[100, 57]];

    var $el = $(&quot;#vanishing-tictactoe&quot;),
        data = [
            {data: equation1, label: &quot;対最強プログラム先手勝数&quot;},
            {data: equation2, label: &quot;対最強プログラム後手勝数&quot;},
            {data: equation3, label: &quot;対乱数プログラム先手勝数&quot;},
            {data: equation4, label: &quot;対乱数プログラム後手勝数&quot;}
            ],
        options = {
            legend: {position: &quot;se&quot;},
            selection: {mode: &quot;xy&quot;, color: &quot;#eeeeee&quot;},
            title: &quot;勝数の推移&quot;,
            subtitle: &quot;機械学習プログラムの学習度合い&quot;,
            HtmlText: false,
            lines:{show: true, horizontal:false},
            xaxis:{
                max: 100,
                ticks: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, [100, &quot;×100回&quot;]],
                title: &quot;対戦回数（×１００）&quot;
            },
            yaxis:{
                ticks: 20,
                min: 0,
                max: 100,
                title: &quot;対戦結果（勝ち数）&quot;
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }, plotObj;

    $el.on(&quot;plotselected&quot;, function(ev, ranges) {
        plotObj = $.plot($el, data,
                         $.extend(true, {}, options, {
                             xaxis: {min: ranges.xaxis.from, max: ranges.xaxis.to},
                             yaxis: {min: ranges.yaxis.from, max: ranges.yaxis.to}
                         })
                        );
    });
    plotObj = $.plot($el, data, options);
    $(&quot;#unzoom&quot;).click(function() {
        plotObj = $.plot($el, data, options);
    });
};

if (typeof contentLoaded != &quot;undefined&quot;) {
    contentLoaded.done(linegraph);
} else {
    window.addEventListener('load', linegraph);
}

});

&lt;/script&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;たとえ理屈は分かって無くても結果が得られるところが機械学習プログラムの良いところです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;ゲームの終盤近くになった時に、ゲーム終了までをモンテカルロ法で読み切って指し手を選択するというプレイアウトと言う手法がありますが、マス目が全て埋まったら必ず終了する囲碁と違って将棋の場合は効果を上げることが難しいのだと思います。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>三目並べのゲーム木データを間引く</title>
   <link href="https://happyclam.github.io/project/2016-12-23/compressed_gametree"/>
   <updated>2016-12-23T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2016-12-23/compressed_gametree</id>
   <content type="html">&lt;p&gt;Project: 「&lt;strong&gt;三目並べ&lt;/strong&gt;」: &lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby/tree/machinelearning&quot;&gt;machinelearning&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ゲーム木から回転対照形を間引く&quot;&gt;ゲーム木から回転、対照形を間引く&lt;/h3&gt;
&lt;p&gt;　以前から懸案だったプログラム内に保持している局面データの省略をやってみました。この件については以前から何度か記事を書いています（&lt;a href=&quot;/software/2015-10-19/multi_branched_tree&quot;&gt;「対戦型ソフトでの幅優先探索（BFS）の使い途」&lt;/a&gt;、&lt;a href=&quot;/software/2015-11-27/reinforcement&quot;&gt;「強化学習の修正」&lt;/a&gt;）が面倒そうなので放置してたのですが、手を付け始めたら案外すぐに出来ました&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;と言うのも勝ったら報酬を与えて負けたら罰するという強化学習の部分がうまく機能するのか心配だったので放置していたのですが、とりあえず作ってテストしてみると報酬の与え方の部分は変更せずに局面データの変換だけでうまく機能しているようです。&lt;/p&gt;

&lt;pre style=&quot;overflow:auto; white-space:nowrap&quot;&gt;
 |X|2|3| |1|X|3| |1|2|X| |1|2|3| |1|2|3| |1|2|3| |1|2|3| |1|2|3| |1|2|3|&lt;br /&gt;
 |4|5|6| |4|5|6| |4|5|6| |X|5|6| |4|X|6| |4|5|X| |4|5|6| |4|5|6| |4|5|6|&lt;br /&gt;
 |7|8|9| |7|8|9| |7|8|9| |7|8|9| |7|8|9| |7|8|9| |X|8|9| |7|X|9| |7|8|X|&lt;br /&gt;
&lt;/pre&gt;
&lt;p&gt;　一手目の局面に関して言うと、今までゲーム木データ内に１手目の局面は上のように９種類保持していたのを、回転・対照形を省いて以下の３局面だけ保持するようになっています。&lt;/p&gt;

&lt;pre style=&quot;overflow:auto; white-space:nowrap&quot;&gt;
プログラム内に保持している１手目の全局面データ&lt;br /&gt;&lt;br /&gt;
&lt;span style=&quot;color:blue;&quot;&gt; |X|2|3|&lt;/span&gt; |1|X|3| |1|2|3|&lt;br /&gt;
&lt;span style=&quot;color:blue;&quot;&gt; |4|5|6|&lt;/span&gt; |4|5|6| |4|X|6|&lt;br /&gt;
&lt;span style=&quot;color:blue;&quot;&gt; |7|8|9|&lt;/span&gt; |7|8|9| |7|8|9|&lt;br /&gt;
 &lt;/pre&gt;

&lt;p&gt;　座標変換用のテーブル（９０度毎に４種類、左右対称、上下対照、斜め対照２種類）を用意して、ゲーム木データを検索する時にすべての座標変換を試しながら検索して対象の局面を見つけ出し、そこにある報酬データ（score配列）を使って指し手を決め、実際の盤面の座標に変換して駒（×、○）を打ちます。ゲーム終了後には実際の局面からゲーム木データが保持している局面に座標変換して報酬データを書き込むようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;class Board &amp;lt; Array
  @@restore_table = [0, 3, 2, 1, 4, 5, 6, 7]
  @@rotate_sym = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8],
    [2, 5, 8, 1, 4, 7, 0, 3, 6],
    [8, 7, 6, 5, 4, 3, 2, 1, 0],
    [6, 3, 0, 7, 4, 1, 8, 5, 2],
    [2, 1, 0, 5, 4, 3, 8, 7, 6],
    [6, 7, 8, 3, 4, 5, 0, 1, 2],
    [0, 3, 6, 1, 4, 7, 2, 5, 8],
    [8, 5, 2, 7, 4, 1, 6, 3, 0]
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　例えば２手目の局面は以下の１２種類しか保持していませんが&lt;/p&gt;

&lt;pre style=&quot;overflow:auto; white-space:nowrap&quot;&gt;
プログラム内に保持している２手目の全局面データ&lt;br /&gt;&lt;br /&gt;
 |X|O|3| &lt;span style=&quot;color:red;&quot;&gt;|X|2|O|&lt;/span&gt; |X|2|3| |X|2|3| |X|2|3| |O|X|3| |1|X|3| |1|X|3| |1|X|3| |1|X|3| |O|2|3| |1|O|3|&lt;br /&gt;
 |4|5|6| &lt;span style=&quot;color:red;&quot;&gt;|4|5|6|&lt;/span&gt; |4|O|6| |4|5|O| |4|5|6| |4|5|6| |O|5|6| |4|O|6| |4|5|6| |4|5|6| |4|X|6| |4|X|6|&lt;br /&gt;
 |7|8|9| &lt;span style=&quot;color:red;&quot;&gt;|7|8|9|&lt;/span&gt; |7|8|9| |7|8|9| |7|8|O| |7|8|9| |7|8|9| |7|8|9| |O|8|9| |7|O|9| |7|8|9| |7|8|9|&lt;br /&gt;
&lt;/pre&gt;

&lt;p&gt;　ゲームが以下のように進行した場合、&lt;/p&gt;
&lt;pre style=&quot;overflow:auto; white-space:nowrap&quot;&gt;
 １手目　　　２手目　　３手目 &lt;br /&gt;
 &lt;span style=&quot;color:blue;&quot;&gt;|1|2|3|&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:red;&quot;&gt;|1|2|3|&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;span&gt;|1|2|3|&lt;/span&gt;&lt;br /&gt;
 &lt;span style=&quot;color:blue;&quot;&gt;|4|5|6|&lt;/span&gt;=&amp;gt;&lt;span style=&quot;color:red;&quot;&gt;|4|5|6|&lt;/span&gt;=&amp;gt;&lt;span&gt;|4|X|6|&lt;/span&gt;&lt;br /&gt;
 &lt;span style=&quot;color:blue;&quot;&gt;|X|8|9|&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:red;&quot;&gt;|X|8|O|&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;span&gt;|X|8|O|&lt;/span&gt;&lt;br /&gt;
&lt;/pre&gt;

&lt;p&gt;１手目は実際の局面を右に９０度回転させた局面として見つけ出すことが出来、２手目は上下反転したもの、３手目はまた別の変換というように、一手毎に座標変換の仕方が異なるわけですが、一つの局面データに対して一つしか持ってない報酬データ（score配列）に対して加算（報酬）、減算（罰）していけば問題なく強化学習が進みます。&lt;/p&gt;

&lt;h3 id=&quot;局面の数&quot;&gt;局面の数&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;手数 \ 局面の数&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;重複チェック無し&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;重複チェック有り&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;回転・対照形とゲーム終了局面を省略&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;504&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;252&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3,024&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;756&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;108&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15,120&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;153&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;60,480&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,680&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;183&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;181,440&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;95&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;362,880&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;630&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;34&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;362,880&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;126&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;計　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;986,410&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;span style=&quot;color: red;&quot;&gt;6,046&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;span style=&quot;color: red;&quot;&gt;627&lt;/span&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　今回の改良で回転・対照形の局面は同一局面としてプログラム内に一つしか保持しないようにしたのと同時に、マス目が全て埋まっている局面や、既に勝ち負けが決まっている局面もゲーム木データから除いています。一番右の欄の９手目の局面が０になっているのはそのため（既に勝敗が決まっているから）です。&lt;br /&gt;
　ゲーム木データを格納したファイル（trees.dump）のサイズは50Kバイト程度で今までの１０分の１以下になりました。リリース中の&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;androidアプリ&lt;/a&gt;にも反映させようと思っているのですが、現行バージョンに採用しているゲーム木を動的に生成する方法&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;と今回の方法を併用するのは難しいのでデータの互換性は無くなりそうです。&lt;/p&gt;

&lt;h3 id=&quot;対戦結果学習効率比較&quot;&gt;対戦結果（学習効率）比較&lt;/h3&gt;
&lt;p&gt;　従来のプログラムと今回修正したもので改めてデータを取り直して、学習の進捗度をグラフにしてみました。回転・対照形をゲーム木から除いた点以外はまったく同じプログラムで比較しています。&lt;/p&gt;

&lt;h5 id=&quot;-最強プログラムとの対戦結果-&quot;&gt;– 最強プログラムとの対戦結果 –&lt;/h5&gt;

&lt;div id=&quot;new_saikyo&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;old_saikyo&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　三目並べの特性上、完全読み切りを行っている最強プログラムに勝つことは出来ませんが、変更前のプログラムより何割か増しで引分に持ち込む頻度が上がり、学習の速度が上がっていることがわかります。&lt;/p&gt;

&lt;h5 id=&quot;-乱数プログラムとの対戦結果-&quot;&gt;– 乱数プログラムとの対戦結果 –&lt;/h5&gt;
&lt;div id=&quot;new_random&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;old_random&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　乱数で指し手を決める弱いプログラム相手でも、今までより対戦回数が少ない段階で勝率が上がっていることがわかります。&lt;/p&gt;

&lt;h3 id=&quot;消える三目並べに応用出来るか&quot;&gt;「消える三目並べ」に応用出来るか？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/programming/2016-11-23/vanishing-tictactoe&quot;&gt;前回の記事&lt;/a&gt;で「消える三目並べ」（３手前に打った自分の駒が消えるルールの三目並べ）はデータ量が増えすぎて、強化学習型のスマホアプリにするのは難しいと書きました。そこで今回の方法で回転・対照形を省けば保持する局面データ量が減って問題解決に繋がるかといえば残念ながらそうはいきません。これも以前書きましたが「消える三目並べ」は局面（と手番）だけでは最善手が決まりません。将棋、オセロ、囲碁など多くのテーブルゲームは局面と手番が決まれば最善手を決めることが出来ますが、「消える三目並べ」はその局面に至った経過が大事（順列データ）なので単純に今回のように局面データを省略しても駄目そうです&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。通常の配列データではなくもっと物理的に小さなデータ（ビットパターン）で局面を保持するしかないかなと考えてますが、これについてはもう少し模索しようと思います。「どうぶつしょうぎ」を完全解析したプログラムは一つの局面を整数データとして（ビットパターンで）保持していたそうですが、有名な将棋ソフトなどもソースコードを追ったことは無いのですが、すべてそうやっているのでしょう。&lt;br /&gt;
　と、この記事を書いている最中にlibshogiというビットパターンで将棋盤を生成するライブラリがあることをTwitterで知りました。こういうライブラリの三目並べ用があればいいのですが、有るわけないですね&lt;img class=&quot;emoji&quot; title=&quot;smile&quot; alt=&quot;smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
function show_new_saikyo(){
    var new_lose = [];
    var new_win = [[1, 87],[2, 57],[3, 65],[4, 53],[5, 59],[6, 47],[7, 41],[8, 42],[9, 35],[10, 31],[11, 32],[12, 32],[13, 20],[14, 22],[15, 18],[16, 20],[17, 12],[18, 14],[19, 7],[20, 12],[21, 8],[22, 8],[23, 9],[24, 8],[25, 3],[26, 9],[27, 5],[28, 6],[29, 3],[30, 5],[31, 4],[32, 2],[33, 4],[34, 3],[35, 5],[36, 5],[37, 2],[38, 9],[39, 6],[40, 1],[41, 4],[42, 3],[43, 4],[44, 4],[45, 3],[46, 4],[47, 1],[48, 1],[49, 1],[50, 5],[51, 1],[52, 2],[53, 3],[54, 1],[55, 4],[56, 3],[57, 1],[58, 3],[59, 1],[60, 1],[61, 1],[62, 5],[63, 4],[64, 3],[65, 4],[66, 3],[67, 1],[68, 4],[69, 1],[70, 0],[71, 3],[72, 4],[73, 2],[74, 4],[75, 2],[76, 4],[77, 5],[78, 0],[79, 2],[80, 0],[81, 0],[82, 0],[83, 3],[84, 1],[85, 0],[86, 0],[87, 0],[88, 1],[89, 0],[90, 2],[91, 1],[92, 4],[93, 0],[94, 1],[95, 1],[96, 3],[97, 0],[98, 2],[99, 2],[100, 1],];
    var new_draw = [[1 ,13],[2 ,43],[3 ,35],[4 ,47],[5 ,41],[6 ,53],[7 ,59],[8 ,58],[9 ,65],[10 ,69],[11 ,68],[12 ,68],[13 ,80],[14 ,78],[15 ,82],[16 ,80],[17 ,88],[18 ,86],[19 ,93],[20 ,88],[21 ,92],[22 ,92],[23 ,91],[24 ,92],[25 ,97],[26 ,91],[27 ,95],[28 ,94],[29 ,97],[30 ,95],[31 ,96],[32 ,98],[33 ,96],[34 ,97],[35 ,95],[36 ,95],[37 ,98],[38 ,91],[39 ,94],[40 ,99],[41 ,96],[42 ,97],[43 ,96],[44 ,96],[45 ,97],[46 ,96],[47 ,99],[48 ,99],[49 ,99],[50 ,95],[51 ,99],[52 ,98],[53 ,97],[54 ,99],[55 ,96],[56 ,97],[57 ,99],[58 ,97],[59 ,99],[60 ,99],[61 ,99],[62 ,95],[63 ,96],[64 ,97],[65 ,96],[66 ,97],[67 ,99],[68 ,96],[69 ,99],[70 ,100],[71 ,97],[72 ,96],[73 ,98],[74 ,96],[75 ,98],[76 ,96],[77 ,95],[78 ,100],[79 ,98],[80 ,100],[81 ,100],[82 ,100],[83 ,97],[84 ,99],[85 ,100],[86 ,100],[87 ,99],[88 ,99],[89 ,100],[90 ,98],[91 ,99],[92 ,96],[93 ,100],[94 ,99],[95 ,99],[96 ,97],[97 ,100],[98 ,98],[99 ,98],[100 ,99]];

    Flotr.draw(
        document.getElementById(&quot;new_saikyo&quot;),
        [
            {data: new_lose, label: &quot;勝ち&quot;},
            {data: new_win, label: &quot;負け&quot;},
            {data: new_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;回転・対照形を省略&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_old_saikyo(){
    var old_lose = [];
    var old_win = [[1, 84],[2, 65],[3, 59],[4, 50],[5, 51],[6, 52],[7, 49],[8, 48],[9, 42],[10, 38],[11, 41],[12, 37],[13, 39],[14, 41],[15, 32],[16, 41],[17, 22],[18, 35],[19, 23],[20, 26],[21, 22],[22, 25],[23, 30],[24, 14],[25, 18],[26, 16],[27, 23],[28, 10],[29, 12],[30, 19],[31, 10],[32, 16],[33, 16],[34, 12],[35, 12],[36, 11],[37, 5],[38, 9],[39, 6],[40, 8],[41, 6],[42, 5],[43, 7],[44, 3],[45, 5],[46, 3],[47, 6],[48, 4],[49, 6],[50, 7],[51, 6],[52, 4],[53, 5],[54, 2],[55, 7],[56, 2],[57, 3],[58, 2],[59, 6],[60, 4],[61, 2],[62, 3],[63, 1],[64, 2],[65, 1],[66, 1],[67, 2],[68, 2],[69, 4],[70, 2],[71, 2],[72, 7],[73, 6],[74, 3],[75, 8],[76, 3],[77, 1],[78, 3],[79, 5],[80, 4],[81, 1],[82, 1],[83, 3],[84, 1],[85, 4],[86, 1],[87, 1],[88, 4],[89, 0],[90, 2],[91, 2],[92, 3],[93, 0],[94, 0],[95, 6],[96, 5],[97, 4],[98, 0],[99, 3],[100, 1],];
    var old_draw = [[1 ,16],[2 ,35],[3 ,41],[4 ,50],[5 ,49],[6 ,48],[7 ,51],[8 ,52],[9 ,58],[10 ,62],[11 ,59],[12 ,63],[13 ,61],[14 ,59],[15 ,68],[16 ,59],[17 ,78],[18 ,65],[19 ,77],[20 ,74],[21 ,78],[22 ,75],[23 ,70],[24 ,86],[25 ,82],[26 ,84],[27 ,77],[28 ,90],[29 ,88],[30 ,81],[31 ,90],[32 ,84],[33 ,84],[34 ,88],[35 ,88],[36 ,89],[37 ,95],[38 ,91],[39 ,94],[40 ,92],[41 ,94],[42 ,95],[43 ,93],[44 ,97],[45 ,95],[46 ,97],[47 ,94],[48 ,96],[49 ,94],[50 ,93],[51 ,94],[52 ,96],[53 ,95],[54 ,98],[55 ,93],[56 ,98],[57 ,97],[58 ,98],[59 ,94],[60 ,96],[61 ,98],[62 ,97],[63 ,99],[64 ,98],[65 ,99],[66 ,99],[67 ,98],[68 ,98],[69 ,96],[70 ,98],[71 ,98],[72 ,93],[73 ,94],[74 ,97],[75 ,92],[76 ,97],[77 ,99],[78 ,97],[79 ,95],[80 ,96],[81 ,99],[82 ,99],[83 ,97],[84 ,99],[85 ,96],[86 ,99],[87 ,99],[88 ,96],[89 ,100],[90 ,98],[91 ,98],[92 ,97],[93 ,100],[94 ,100],[95 ,94],[96 ,95],[97 ,96],[98 ,100],[99 ,97],[100 ,99]];

    Flotr.draw(
        document.getElementById(&quot;old_saikyo&quot;),
        [
            {data: old_lose, label: &quot;勝ち&quot;},
            {data: old_win, label: &quot;負け&quot;},
            {data: old_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の方法&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_new_random(){
    var new_lose = [[1, 36],[2, 43],[3, 49],[4, 39],[5, 51],[6, 55],[7, 62],[8, 51],[9, 51],[10, 66],[11, 56],[12, 61],[13, 60],[14, 60],[15, 69],[16, 62],[17, 78],[18, 58],[19, 67],[20, 67],[21, 72],[22, 66],[23, 71],[24, 65],[25, 62],[26, 69],[27, 74],[28, 69],[29, 72],[30, 67],[31, 64],[32, 65],[33, 79],[34, 68],[35, 73],[36, 76],[37, 81],[38, 72],[39, 80],[40, 76],[41, 65],[42, 67],[43, 70],[44, 69],[45, 74],[46, 75],[47, 68],[48, 78],[49, 73],[50, 76],[51, 74],[52, 74],[53, 66],[54, 70],[55, 79],[56, 80],[57, 79],[58, 74],[59, 73],[60, 62],[61, 81],[62, 69],[63, 81],[64, 77],[65, 75],[66, 75],[67, 83],[68, 70],[69, 72],[70, 76],[71, 77],[72, 78],[73, 77],[74, 73],[75, 74],[76, 81],[77, 79],[78, 80],[79, 82],[80, 81],[81, 81],[82, 76],[83, 78],[84, 80],[85, 66],[86, 81],[87, 76],[88, 75],[89, 78],[90, 83],[91, 82],[92, 77],[93, 79],[94, 76],[95, 72],[96, 79],[97, 73],[98, 86],[99, 77],[100, 79],];
    var new_win = [[1, 48],[2, 41],[3, 36],[4, 45],[5, 33],[6, 29],[7, 28],[8, 27],[9, 31],[10, 21],[11, 28],[12, 26],[13, 24],[14, 25],[15, 14],[16, 21],[17, 10],[18, 21],[19, 17],[20, 22],[21, 16],[22, 12],[23, 13],[24, 17],[25, 17],[26, 16],[27, 17],[28, 10],[29, 19],[30, 18],[31, 20],[32, 18],[33, 12],[34, 15],[35, 10],[36, 9],[37, 9],[38, 18],[39, 10],[40, 14],[41, 19],[42, 20],[43, 16],[44, 11],[45, 9],[46, 7],[47, 14],[48, 16],[49, 16],[50, 13],[51, 12],[52, 14],[53, 17],[54, 14],[55, 10],[56, 10],[57, 13],[58, 10],[59, 9],[60, 20],[61, 9],[62, 18],[63, 10],[64, 8],[65, 14],[66, 11],[67, 7],[68, 15],[69, 17],[70, 12],[71, 12],[72, 6],[73, 11],[74, 14],[75, 15],[76, 5],[77, 14],[78, 11],[79, 10],[80, 10],[81, 6],[82, 13],[83, 8],[84, 4],[85, 17],[86, 9],[87, 11],[88, 12],[89, 10],[90, 7],[91, 11],[92, 9],[93, 12],[94, 16],[95, 12],[96, 12],[97, 15],[98, 7],[99, 7],[100, 9],];
    var new_draw = [[1 ,16],[2 ,16],[3 ,15],[4 ,16],[5 ,16],[6 ,16],[7 ,10],[8 ,22],[9 ,18],[10 ,13],[11 ,16],[12 ,13],[13 ,16],[14 ,15],[15 ,17],[16 ,17],[17 ,12],[18 ,21],[19 ,16],[20 ,11],[21 ,12],[22 ,22],[23 ,16],[24 ,18],[25 ,21],[26 ,15],[27 ,9],[28 ,21],[29 ,9],[30 ,15],[31 ,16],[32 ,17],[33 ,9],[34 ,17],[35 ,17],[36 ,15],[37 ,10],[38 ,10],[39 ,10],[40 ,10],[41 ,16],[42 ,13],[43 ,14],[44 ,20],[45 ,17],[46 ,18],[47 ,18],[48 ,6],[49 ,11],[50 ,11],[51 ,14],[52 ,12],[53 ,17],[54 ,16],[55 ,11],[56 ,10],[57 ,8],[58 ,16],[59 ,18],[60 ,18],[61 ,10],[62 ,13],[63 ,9],[64 ,15],[65 ,11],[66 ,14],[67 ,10],[68 ,15],[69 ,11],[70 ,12],[71 ,11],[72 ,16],[73 ,12],[74 ,13],[75 ,11],[76 ,14],[77 ,7],[78 ,9],[79 ,8],[80 ,9],[81 ,13],[82 ,11],[83 ,14],[84 ,16],[85 ,17],[86 ,10],[87 ,13],[88 ,13],[89 ,12],[90 ,10],[91 ,7],[92 ,14],[93 ,9],[94 ,8],[95 ,16],[96 ,9],[97 ,12],[98 ,7],[99 ,16],[100 ,12]];

    Flotr.draw(
        document.getElementById(&quot;new_random&quot;),
        [
            {data: new_lose, label: &quot;勝ち&quot;},
            {data: new_win, label: &quot;負け&quot;},
            {data: new_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;回転・対照形を省略&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}
    
function show_old_random(){
    var old_lose = [[1, 47],[2, 43],[3, 43],[4, 42],[5, 45],[6, 50],[7, 68],[8, 58],[9, 48],[10, 49],[11, 52],[12, 43],[13, 49],[14, 54],[15, 46],[16, 54],[17, 53],[18, 57],[19, 56],[20, 51],[21, 51],[22, 56],[23, 55],[24, 52],[25, 50],[26, 57],[27, 57],[28, 57],[29, 56],[30, 63],[31, 59],[32, 50],[33, 60],[34, 46],[35, 58],[36, 50],[37, 54],[38, 55],[39, 66],[40, 47],[41, 56],[42, 58],[43, 55],[44, 50],[45, 49],[46, 64],[47, 57],[48, 65],[49, 53],[50, 54],[51, 61],[52, 67],[53, 65],[54, 68],[55, 51],[56, 56],[57, 59],[58, 65],[59, 58],[60, 58],[61, 56],[62, 57],[63, 65],[64, 63],[65, 66],[66, 68],[67, 67],[68, 58],[69, 69],[70, 60],[71, 68],[72, 66],[73, 66],[74, 67],[75, 67],[76, 61],[77, 71],[78, 59],[79, 61],[80, 56],[81, 64],[82, 62],[83, 66],[84, 64],[85, 72],[86, 61],[87, 72],[88, 71],[89, 73],[90, 63],[91, 63],[92, 63],[93, 73],[94, 63],[95, 73],[96, 75],[97, 71],[98, 76],[99, 64],[100, 68],];
    var old_win = [[1, 38],[2, 42],[3, 40],[4, 47],[5, 41],[6, 36],[7, 19],[8, 33],[9, 37],[10, 41],[11, 35],[12, 39],[13, 44],[14, 36],[15, 41],[16, 38],[17, 35],[18, 26],[19, 32],[20, 37],[21, 35],[22, 31],[23, 30],[24, 34],[25, 34],[26, 30],[27, 36],[28, 23],[29, 31],[30, 26],[31, 32],[32, 35],[33, 27],[34, 31],[35, 28],[36, 31],[37, 27],[38, 27],[39, 21],[40, 35],[41, 26],[42, 24],[43, 27],[44, 27],[45, 36],[46, 23],[47, 29],[48, 21],[49, 27],[50, 31],[51, 23],[52, 23],[53, 21],[54, 20],[55, 33],[56, 32],[57, 27],[58, 16],[59, 29],[60, 29],[61, 26],[62, 33],[63, 23],[64, 21],[65, 20],[66, 21],[67, 19],[68, 26],[69, 23],[70, 23],[71, 20],[72, 23],[73, 22],[74, 18],[75, 26],[76, 22],[77, 17],[78, 27],[79, 27],[80, 28],[81, 22],[82, 21],[83, 22],[84, 20],[85, 15],[86, 26],[87, 19],[88, 11],[89, 14],[90, 25],[91, 24],[92, 25],[93, 12],[94, 21],[95, 15],[96, 14],[97, 19],[98, 17],[99, 24],[100, 20],];
    var old_draw = [[1 ,15],[2 ,15],[3 ,17],[4 ,11],[5 ,14],[6 ,14],[7 ,13],[8 ,9],[9 ,15],[10 ,10],[11 ,13],[12 ,18],[13 ,7],[14 ,10],[15 ,13],[16 ,8],[17 ,12],[18 ,17],[19 ,12],[20 ,12],[21 ,14],[22 ,13],[23 ,15],[24 ,14],[25 ,16],[26 ,13],[27 ,7],[28 ,20],[29 ,13],[30 ,11],[31 ,9],[32 ,15],[33 ,13],[34 ,23],[35 ,14],[36 ,19],[37 ,19],[38 ,18],[39 ,13],[40 ,18],[41 ,18],[42 ,18],[43 ,18],[44 ,23],[45 ,15],[46 ,13],[47 ,14],[48 ,14],[49 ,20],[50 ,15],[51 ,16],[52 ,10],[53 ,14],[54 ,12],[55 ,16],[56 ,12],[57 ,14],[58 ,19],[59 ,13],[60 ,13],[61 ,18],[62 ,10],[63 ,12],[64 ,16],[65 ,14],[66 ,11],[67 ,14],[68 ,16],[69 ,8],[70 ,17],[71 ,12],[72 ,11],[73 ,12],[74 ,15],[75 ,7],[76 ,17],[77 ,12],[78 ,14],[79 ,12],[80 ,16],[81 ,14],[82 ,17],[83 ,12],[84 ,16],[85 ,13],[86 ,13],[87 ,9],[88 ,18],[89 ,13],[90 ,12],[91 ,13],[92 ,12],[93 ,15],[94 ,16],[95 ,12],[96 ,11],[97 ,10],[98 ,7],[99 ,12],[100 ,12]];

    Flotr.draw(
        document.getElementById(&quot;old_random&quot;),
        [
            {data: old_lose, label: &quot;勝ち&quot;},
            {data: old_win, label: &quot;負け&quot;},
            {data: old_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の方法&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 100,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

window.onload = function() {
    show_new_saikyo();
    show_old_saikyo();
    show_new_random();
    show_old_random();
};
&lt;/script&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;初回起動時にゲーム木データを生成するやり方だと２分ぐらい待たされるから動的に生成するやり方にしたのですが、データを小さくすることが出来たので初回起動時にデータを作るようにしようと思ってます。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;そもそも前回試しに作った「消える三目並べ」のプログラムは局面の検索に局面データは役に立たないので、指し手の手順を含めたデータを使っています。このプログラムもいずれgithubで公開するつもりです。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>「消える三目並べ」は、学習が速い</title>
   <link href="https://happyclam.github.io/programming/2016-11-23/vanishing-tictactoe"/>
   <updated>2016-11-23T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-11-23/vanishing-tictactoe</id>
   <content type="html">&lt;h3 id=&quot;消える三目並べの対戦結果&quot;&gt;「消える三目並べ」の対戦結果&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/programming/2016-11-03/ml_miscellaneous2&quot;&gt;前回の記事&lt;/a&gt;で「消える三目並べ」（３手前に打った自分の駒が消えるルールの三目並べ）の機械学習プログラムと最強プログラム（MIN-MAX法、αβ法を使った１１手読みのプログラム）と対戦させて、機械学習プログラムが一回も勝てなかった話をしましたが、どこが悪いかは分かっていたので今回機械学習部分の修正が完了したものと再度対戦させてみました。通常の三目並べより対戦に時間がかかるので最強プログラムの方は１００回の対戦を１回として５０回戦、乱数プログラムは１００回戦の対戦結果です。&lt;/p&gt;

&lt;div id=&quot;vanishing-tictactoe&quot; style=&quot;width:600px;height:400px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;button id=&quot;unzoom&quot;&gt;元に戻す&lt;/button&gt;&lt;span&gt;　※範囲をドラッグすれば、グラフを zoom up 出来ます&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　黄色の線のグラフを見てください、最初の６００回は最強プログラムに対して全く勝てなかったのが、その後１００回に数回の割合で機械学習プログラムが勝つようになり、１０００回戦目辺りから急速に勝ち星を伸ばして１５００回戦後ぐらいからはほぼ互角（勝率５割）の対戦成績が続いています。&lt;a href=&quot;/programming/2016-11-03/ml_miscellaneous2&quot;&gt;前回の記事&lt;/a&gt;でも言及したように「消える三目並べ」というゲームは先手必勝なのですが、わずか１５００回の対戦でそのことを学んだようです。先手・後手はランダムに決めて対戦テストをしていますので、約５０％の確率で最強プログラムに勝つことが出来るということは、学習深度がほぼ限界にまで達した（先手の時は勝てる）と言えると思います。ただ、毎回最後まで読み切って先手のときには必ず勝つ「最強プログラム」と違い、「機械学習プログラム」の場合はあくまで最善手を選択する確率が高くなるだけですので、MIN-MAX法を用いた最強プログラムのように「必ず勝つ」とは限りません。だから、グラフの推移も時々５割以上勝つ時はあるものの、５割弱の数値（１００回の内５０回弱）で推移しているところに特長が出ていると思います。限界に達したというのはあくまでも「勝てば小石の報酬を与えて、負ければ小石を取り上げる」というこのプログラムの作り方についての表現です（小石の報酬については&lt;a href=&quot;/software/2015-10-19/multi_branched_tree&quot;&gt;以前の記事&lt;/a&gt;を参照してください）。&lt;br /&gt;
　&lt;del&gt;&lt;a href=&quot;/software/2016-01-16/flotr2&quot;&gt;以前の記事&lt;/a&gt;で「通常の三目並べ」がほぼ限界まで学習が進むのに約一万回の対戦を必要としたのに、「消える三目並べ」の場合はわずか１５００回で済んだのは、ゲームの特性の違いが関係していると思います。機械学習プログラムは「通常の三目並べの最強プログラム」と対戦して、最善手を指し続けて引分に持ち込めば報酬を貰えるわけですが、あくまでも引分の分のみの報酬（小石）です。勝利の味を味わうことが無いまま学習を続けます。それに対して「消える三目並べ」は引分がないので、「消える三目並べの最強プログラム」に勝てばより多くの小石の報酬を貰うことが出来るので「通常の三目並べ」に較べてメリハリが効いて学習速度が上がったのではないでしょうか。&lt;/del&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h3 id=&quot;対戦テスト後の小石の報酬&quot;&gt;対戦テスト後の小石の報酬&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|8|9|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　５０００回の最強プログラムとの対戦テスト後に、機械学習プログラムの小石の数（score配列）の中身を確認すると、上記の初期盤面９箇所に対応する値は以下のようになっていました。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;　　１：0.49880952380952337&lt;/td&gt;
      &lt;td&gt;２： 0.30714285714285683&lt;/td&gt;
      &lt;td&gt;３：0.703571428571428&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;　　４：0.49523809523809537&lt;/td&gt;
      &lt;td&gt;５：0.249981962481963&lt;/td&gt;
      &lt;td&gt;６： 0.5761904761904751&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;　　７：0.1738095238095236&lt;/td&gt;
      &lt;td&gt;８：499.9101323384054&lt;/td&gt;
      &lt;td&gt;９： 0.2321428571428563&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　８の位置（辺の位置）がダントツで大きい数字になっています。つまり先手の時に初期盤面で８の位置を選べば勝てることを学習したというわけです&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。８と同じく他の辺の位置（２，４，６）にうまく分散して欲しいところですが、仕方がないというか、むしろ４箇所は同じものとして扱うようにプログラムを改変出来ればデータ量も減るのでメリットも大きい（回転、対称型の省略）のですが、実際の局面に展開する時の処理がややこしそうなので今後の課題です。&lt;/p&gt;

&lt;h3 id=&quot;乱数プログラムのテスト結果&quot;&gt;乱数プログラムのテスト結果&lt;/h3&gt;
&lt;p&gt;　上のグラフで乱数プログラムのテストだけ10,000回実施していますが、最強プログラムと同じ5,000回実施しただけでは、強くなっているのかどうか確認できなかったからです。5,000回対戦までのグラフを見てもわかる通り、対最強プログラムの対戦結果グラフのような一見して右肩上がりとわかるほどには勝ち星が増えていません。初期状態からほぼ５割の勝ち星を上げていて、その後も対戦を続けているのに勝ち星が増える気配がないので、こんなはずはないと思いながら10,000に回数を増やしてみたわけです。得られた結果はなんとか勝ち星が漸増していると言っていいグラフ形状になっているのではないでしょうか。グラフには10,000回戦までしか表示していませんが、その後、念のため20,000まで対戦させてみると最後の１００回の勝率は７割を超えていたので、学習が進んでいくのは間違いなさそうです。ただ、通常の三目並べでもそうでしたが、弱いプログラムと対戦してもなかなか強くならないということでしょう。&lt;br /&gt;
　そもそも一般的に機械学習プログラムを何かの予測やシミュレーションに使う場合、学習に使用するデータを選ばなければならないわけですが、三目並べの機械学習プログラムを学習させるためには、乱数プログラムは役に立たないということでしょう、但しプログラム自体のバグを見つけるためのテストとしては有効だと思います。対戦を重ねる度に勝数が減るようでは、プログラムの何処かにバグが有るということですから。&lt;br /&gt;
　ちなみに乱数プログラムとの20,000回対戦後の初期盤面のscore配列は以下の通りでした。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;　　１：78.74922305652922&lt;/td&gt;
      &lt;td&gt;２： 3.4935515653936715&lt;/td&gt;
      &lt;td&gt;３：57.53441829242526&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;　　４：13.591606247023199&lt;/td&gt;
      &lt;td&gt;５：151.80688472679168&lt;/td&gt;
      &lt;td&gt;６： 2315.8063733952617&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;　　７：98.0014452573806&lt;/td&gt;
      &lt;td&gt;８：81.55661501027998&lt;/td&gt;
      &lt;td&gt;９： 236.37938875004835&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　最強プログラムとの対戦後と同様に辺の位置である６の場所が最大値になっていて、先手の時の初手は辺の位置が良いことは学習できているようですが、まだまだ学習が足りないという感じですね。&lt;/p&gt;

&lt;h3 id=&quot;その他グラフからわかること&quot;&gt;その他グラフからわかること&lt;/h3&gt;
&lt;p&gt;　ゲーム終了までの手数を見てみると、対最強プログラムでは漸増していき、対乱数プログラムでは漸減していく傾向があります。最強プログラムには刃が立たずに短手数で負けてしまっていた機械学習プログラムが、学習が進むに連れて負けずに粘れるようになり徐々にゲーム終了までの手数が増えていくわけです。それに対して乱数プログラムの場合はお互い弱い者同士なので、無意味な手でいたずらに手数だけが増えていたものが、機械学習プログラムが強くなるに連れて手数をかけずに勝負をつけることが出来るようになっていったということが読み取れます。&lt;/p&gt;

&lt;h3 id=&quot;androidアプリにしてみると&quot;&gt;Androidアプリにしてみると&lt;/h3&gt;
&lt;p&gt;　PC上でRuby製プログラムでのテスト結果で強くなる（進化する）ことが確認できたので、&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;の別バージョンとしてandroidアプリとしてリリースしたかったのですが、局面の多分木データファイルが大きすぎて動きが重くなり過ぎる（起動に約１分、ゲーム終了毎に学習データ書き込みに約３０秒）ので、Cordovaで作るのはとりあえず止めることにしました。元々Rubyのコードを流用したいと思いCoffeeScript（CoffeeScriptはRubyと言語仕様が似ているので移植が簡単です）に書き換えてCordovaを使ってみたわけですが、今度は何か別の方法を模索しようと思ってます。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
jQuery(function ($){

linegraph = function() {
    var equation1 = [[1 ,0],[2 ,0],[3 ,0],[4 ,0],[5 ,0],[6 ,0],[7 ,2],[8 ,2],[9 ,0],[10 ,7],[11 ,13],[12 ,24],[13 ,37],[14 ,34],[15 ,49],[16 ,44],[17 ,38],[18 ,42],[19 ,42],[20 ,41],[21 ,44],[22 ,45],[23 ,48],[24, 50],[25, 40],[26, 49],[27, 44],[28, 53],[29, 46],[30, 41],[31, 46],[32 ,48],[33 ,50],[34 ,54],[35 ,54],[36 ,49],[37 ,55],[38 ,40],[39 ,46],[40 ,48],[41 ,41],[42 ,49],[43 ,50],[44 ,47],[45 ,49],[46 ,44],[47 ,44],[48 ,52],[49 ,50],[50 ,47]];
    var equation2 = [[1, 7.88],[2, 8.6],[3, 8.26],[4, 8.26],[5, 8.26],[6, 8.14],[7, 8.88],[8, 8.5],[9, 8.78],[10, 8.74],[11, 8.54],[12, 9.44],[13, 9.68],[14, 9.4],[15, 10.06],[16, 9.56],[17, 9.24],[18, 9.62],[19, 9.8],[20, 9.12],[21, 9.34],[22, 9.76],[23, 9.36],[24, 9.76],[25, 9.06],[26, 9.66],[27, 9.54],[28, 9.58],[29, 9.36],[30, 9.1],[31, 9.36],[32, 9.44],[33, 9.52],[34, 9.86],[35, 9.78],[36, 9.5],[37, 10],[38, 9.14],[39, 9.54],[40, 9.68],[41, 9.14],[42, 9.8],[43, 9.78],[44, 9.6],[45, 9.84],[46, 9.36],[47, 9.32],[48, 9.58],[49, 9.64],[50, 9.78]];
    // var equation3 = [[1 ,57],[2 ,51],[3 ,52],[4 ,49],[5 ,43],[6 ,58],[7 ,48],[8 ,46],[9 ,55],[10 ,53],[11 ,57],[12 ,52],[13 ,56],[14 ,61],[15 ,56],[16 ,57],[17 ,46],[18 ,54],[19 ,56],[20 ,51],[21 ,54],[22 ,51],[23 ,60],[24, 62],[25 ,58],[26 ,50],[27 ,55],[28 ,65],[29 ,56],[30 ,57],[31 ,54],[32 ,56],[33 ,47],[34 ,54],[35 ,55],[36, 56],[37, 57],[38, 56],[39, 55],[40, 54],[41, 59],[42, 54],[43, 58],[44, 56],[45, 51],[46, 50],[47, 50],[48, 56],[49, 49],[50, 59]];
    var equation3 = [[1, 54],[2, 46],[3, 48],[4, 46],[5, 53],[6, 44],[7, 47],[8, 55],[9, 50],[10, 61],[11, 41],[12, 48],[13 ,52],[14, 53],[15, 44],[16, 48],[17, 52],[18, 49],[19, 52],[20, 54],[21, 57],[22, 55],[23, 53],[24, 57],[25, 61],[26, 54],[27, 54],[28, 49],[29, 57],[30, 58],[31, 65],[32, 58],[33, 55],[34, 59],[35, 49],[36, 62],[37, 55],[38, 61],[39, 61],[40, 65],[41, 67],[42, 54],[43, 56],[44, 55],[45, 60],[46, 58],[47, 53],[48, 61],[49, 57],[50, 49],[51, 66],[52, 62],[53, 51],[54, 59],[55, 60],[56, 59],[57, 60],[58, 60],[59, 60],[60, 70],[61, 64],[62, 62],[63, 60],[64, 64],[65, 65],[66, 65],[67, 59],[68, 67],[69, 63],[70, 58],[71, 64],[72, 66],[73, 65],[74, 70],[75, 67],[76, 72],[77, 66],[78, 67],[79, 69],[80, 66],[81, 59],[82, 64],[83, 57],[84, 56],[85, 61],[86, 67],[87, 65],[88, 66],[89, 64],[90, 65],[91, 64],[92, 63],[93, 60],[94, 63],[95, 60],[96, 71],[97, 64],[98, 65],[99, 69],[100, 64]];
    var equation4 = [[1, 14.48],[2, 17.02],[3, 14.22],[4, 14.98],[5, 17.1],[6, 15.42],[7, 15.64],[8, 15.56],[9, 15.34],[10, 16.3],[11, 14.86],[12, 13.7],[13, 13.42],[14, 14.7],[15, 14.52],[16, 14.1],[17, 15.24],[18, 14.04],[19, 14.78],[20, 17.26],[21, 14.8],[22, 14.04],[23, 16.12],[24, 14.38],[25, 13.64],[26, 14.62],[27, 16.40],[28, 13.72],[29, 13.58],[30, 15.28],[31, 15.84],[32, 14.18],[33, 15.9],[34, 13.56],[35, 14.56],[36, 14.26],[37, 15.0],[38, 14.88],[39, 14.02],[40, 14.94],[41, 13,94],[42, 14.92],[43, 14.16],[44, 15.98],[45, 13.62],[46, 13.80],[47, 14.66],[48, 15.12],[49, 14.62],[50, 15.60],[51, 12.12],[52, 15.22],[53, 14.58],[54, 13.1],[55, 13.32],[56, 13.06],[57, 13.38],[58, 12.2],[59, 14.0],[60, 13.7],[61, 13.68],[62, 14.18],[63, 12.94],[64, 11.64],[65, 13.74],[66, 12.24],[67, 14.0],[68, 12.98],[69, 14.32],[70, 12.7],[71, 12.40],[72, 12.58],[73, 12.88],[74, 12.58],[75, 12.34],[76, 12.3],[77, 12.70],[78, 14.22],[79, 12.94],[80, 12.84],[81, 14.72],[82, 13.58],[83, 14.18],[84, 14.36],[85, 13.04],[86, 13.66],[87, 13.5],[88, 12.82],[89, 12.44],[90, 12.74],[91, 12.52],[92, 12.60],[93, 12.74],[94, 12.96],[95, 13.64],[96, 12.96],[97, 14.14],[98, 12.36],[99, 11.64],[100, 13.78]];

    var $el = $(&quot;#vanishing-tictactoe&quot;),
        data = [
            {data: equation1, label: &quot;対最強プログラム勝数&quot;},
            {data: equation2, label: &quot;対最強プログラム平均手数&quot;},
            {data: equation3, label: &quot;対乱数プログラム勝数&quot;},
            {data: equation4, label: &quot;対乱数プログラム平均手数&quot;}
            ],
        options = {
            legend: {position: &quot;nw&quot;},
            selection: {mode: &quot;xy&quot;, color: &quot;#eeeeee&quot;},
            title: &quot;勝敗の推移&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            lines:{show: true, horizontal:false},
            xaxis:{
                max: 100,
                ticks: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, [100, &quot;×100回&quot;]],
                title: &quot;対戦回数（×１００）&quot;
            },
            yaxis:{
                ticks: 20,
                min: 0,
                max: 100,
                title: &quot;対戦結果（勝ち数／手数）&quot;
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }, plotObj;

    $el.on(&quot;plotselected&quot;, function(ev, ranges) {
        plotObj = $.plot($el, data,
                         $.extend(true, {}, options, {
                             xaxis: {min: ranges.xaxis.from, max: ranges.xaxis.to},
                             yaxis: {min: ranges.yaxis.from, max: ranges.yaxis.to}
                         })
                        );
    });
    plotObj = $.plot($el, data, options);
    $(&quot;#unzoom&quot;).click(function() {
        plotObj = $.plot($el, data, options);
    });
};

if (typeof contentLoaded != &quot;undefined&quot;) {
    contentLoaded.done(linegraph);
} else {
    window.addEventListener('load', linegraph);
}

});

&lt;/script&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;勘違いでした。テストに使用していた最強プログラムは常に同じ勝ち方しかしないようになっていたため、限定された指し手に対して学習が進んでいただけで、全く別の手を指すプログラム相手には弱い状態のままでした。詳しくは&lt;a href=&quot;/programming/2017-05-27/vanishing-tictactoe3&quot;&gt;この記事&lt;/a&gt;を参照して下さい。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;「消える三目並べ」は辺の位置に初手を打てば勝てる先手必勝のゲームであることは以前の記事にも書きました。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>「消える三目並べ」、思ったより大変</title>
   <link href="https://happyclam.github.io/programming/2016-11-03/ml_miscellaneous2"/>
   <updated>2016-11-03T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-11-03/ml_miscellaneous2</id>
   <content type="html">&lt;h3 id=&quot;乱数プログラムとの対戦テスト結果は良好だったけど&quot;&gt;乱数プログラムとの対戦テスト結果は良好だったけど&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/programming/2016-10-21/ml_miscellaneous&quot;&gt;前回の記事&lt;/a&gt;で「消える三目並べ」（３手前に打った自分の駒が消えるルールの三目並べ）なら保持する局面の数（ゲーム木）を通常の三目並べより少なく出来るなんて書いてしまいましたが、「消える三目並べ」では局面のデータだけを記憶していても次にどの駒が消えるかによって最善手が違ってくるので通常の三目並べのように局面の組み合わせだけで学習させることは出来ないことに気づきました。&lt;br /&gt;
　あまり深く考えずに「消える三目並べ」のルールをプログラムに反映させて、学習機能の部分は変更せずに乱数プログラムとの対戦テストをしたところ、最初は２０％程だった勝率が徐々に上がり、10,000回対戦後の最後の１００回の対戦は勝率６０％以上に上がったので、これだけの修正でいいのか？と疑問に思いながらも、前回の記事を書いてしまいました。&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;でも、最強プログラムとの対戦では急速に学習が進みますが、乱数プログラムとの対戦では学習効果が低いため10,000回対戦後でも勝率が６０％程度でしたので、同じ結果が得られたと早合点してしまいました。&lt;br /&gt;
　でも「消える三目並べ」の最強プログラム&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;を作って対戦テストをしてみたところ&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;、学習機能を変更しないままでは、全く勝てるようになりませんでした。以前の記事&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;でも書いたように「消える三目並べ」は先手必勝なので少なくともAI側&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;が先手の時は勝てるようにならなければおかしいはずなのに、５千回程対戦させても１回も勝てません。とりあえず最強の「消える三目並べ」プログラムに先手の時はある程度勝てるようにならなければ「進化する」とは言えないでしょう。&lt;br /&gt;
　では、なぜ乱数プログラムとの対戦テストでは勝率が上がっていったのか？乱数プログラムはまったく出鱈目に指し手を決めるので、ラインを揃えようとさえしないので、少なくとも現在の局面だけを見て（例え次にどの駒が消えるかまでは考慮していないにしても）ラインを揃えれば報酬がもらえることを学習したプログラムの方が勝率が上がっていくのは当たり前ということでしょう。してみると、乱数プログラムとの対戦テストなんて学習効果を図るためには不要なテストなのかもしれません。テスト結果が良好だったので、簡単な修正で済んだことに驚きながらも「思ったより楽勝だな」なんて思ってました。しかし、このままのプログラムでは、人間や最強プログラムを相手にした場合はまったく学習効果が感じられない偽AIプログラムと言われそうです。&lt;br /&gt;
　一応スマホにインストールして自分で数百回対戦してみましたが「消える三目並べ」自体あまりやったことがなく特に強いわけでもない自分にとっては、強くなってるのかどうかわからないというのが正直な感想ですが、少なくともデータ上で強くなることを確認する必要があるでしょう。&lt;/p&gt;

&lt;h3 id=&quot;組み合わせではなく順列&quot;&gt;組み合わせではなく、順列&lt;/h3&gt;
&lt;p&gt;　冷静に考えれば当たり前なんですが、「消える三目並べ」では通常の三目並べと違い６手目以降は駒が消えていくので現在の局面（９箇所の配置）を見ただけでは最善手の判断が付きません。オセロや将棋では現局面の駒の配置と手番がわかればその局面での最善手は判断できるはずです&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;が、「消える三目並べ」では自分が新たに着手する際にどの駒が消えるのかを知っていなければ判断できません。「消える三目並べ」のルールをプログラムに反映した段階で当然指し手の手順は記憶しているのですが、学習データを保存するためのゲーム木データにも記憶しておく必要があるということです。つまり、局面の組み合わせの数ではなく、順列の数の分だけ局面データを保持する必要があります。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;手数 \ 重複チェック&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　有り　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　無し　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;252&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;504&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;756&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3,024&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15,120&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,680&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;strong&gt;60,480&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;計　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4,030&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;strong&gt;79,210&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　上の表で手順を含めた局面データをゲーム木に含めないといけないので、&lt;a href=&quot;/programming/2016-10-21/ml_miscellaneous&quot;&gt;前回の記事&lt;/a&gt;にゲーム木に必要なデータ数は左の列の4,030で済むようなことを書きましたが、正しくは右の列の合計79,210個の局面データを記憶しておく必要があります。通常の三目並べと違い、局面の重複チェックは必要ないというか、重複チェックをしてはいけなかったわけです。同じ局面でもどういう経緯でその局面に至ったかによって最善手が変わるのですから。&lt;/p&gt;

&lt;h3 id=&quot;手数が増えてもデータは増えない&quot;&gt;手数が増えてもデータは増えない&lt;/h3&gt;

&lt;div style=&quot;width:600px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/tictactoe.png&quot;&gt;&lt;img src=&quot;/images/tictactoe.png&quot; alt=&quot;消える三目並べゲーム木&quot; title=&quot;消える三目並べゲーム木&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　上の図は、手数がいくら増えたとしても６手目以降の局面は、６手目の局面60,480種類の中に手順が違う局面として必ず含まれていることを示しています。プログラムとの対戦テストでは手数は２０手を超えることもあるのですが、一局面に存在する駒の数は最大６個（×が３つ、○が３つ）までなのでいくら手数が増えてもデータが無制限に増える心配がないことは&lt;a href=&quot;/programming/2016-10-21/ml_miscellaneous&quot;&gt;前回の記事&lt;/a&gt;に書いた通りですが、アプリを作る場合思っていたより大幅にデータ量が増えてしまうことになりそうです。&lt;br /&gt;
　試しにゲーム木データをPCで作成したところ12MB程度になりました。画像をいっぱい使用する昨今のアプリに比べればそれ程でもないかもしれませんが、現在の&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;の1MB程度に較べて大幅増量になりそうです。androidアプリもiosアプリも100MBまで大丈夫なようなので、サイズ的には問題ないのですが、スマホ標準のブラウザ（WebView）内のデータ制限（androidは2MB、iosは5MB）を超えるのでアプリの作りを変える必要がありそうです。自分としてはこれが一番面倒くさい、今までMacbookでブラウザ上で開発出来ていたのに、パワーの有るPCで実機やエミュレータを使いながらの開発作業が必要になりそうです。&lt;br /&gt;
　また、データ量の問題はどうにかなるにしても、６手目以降の局面を検索する場合、上の図の限定した範囲のゲーム木に含まれているとはいっても、今までのように単純にツリーを辿るだけでは駄目で、６手目以降に関してはツリーのルートから再検索しなければいけませんし、上の図の６手目の局面の手番はすべて同じ先手番になっています（×○×○×○で次は先手の×の手番）が、実際には後手の手番で上の図の６手目の局面を迎えることもあるので、対戦結果を学習データとして格納する時の処理が複雑で煩わしい処理になりそうです。それにAIの学習が進んでいるかどうかの指標（どれだけ進化したか現在イラストで表示している機能）をどうやって実現するかも現在手探り中です。&lt;br /&gt;
　乗りかかった船なので何とかリリースまで漕ぎ着けたいと思ってますが、思っていたより時間かかりそうです&lt;img class=&quot;emoji&quot; title=&quot;pensive&quot; alt=&quot;pensive&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/pensive.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;ここで言う最強プログラムとは従来のMIN-MAX法（αβ法）を使って作ったプログラムです &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;「消える三目並べ」の最強プログラムは最低でも１１手読みを必要とするため、テストするにも時間がかかって面倒なんです&lt;img class=&quot;emoji&quot; title=&quot;weary&quot; alt=&quot;weary&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/weary.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/software/2014-10-04/arrange_line&quot;&gt;「三目並べ（tic tac toe）で遊んでみた（続き）」&lt;/a&gt;、&lt;a href=&quot;/programming/2016-07-23/33shogi&quot;&gt;「９マス将棋（３×３将棋）と三目並べの変化形」&lt;/a&gt;参照 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;ここで言うAIとは&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;で使用している機械学習によるAIです。 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;オセロと将棋に関しても、オセロは指し手が進む毎に盤面を駒が埋めていき必ず終局に向かうのに対して、将棋は駒が全て盤上を埋め尽くすわけではないので、必ずしも手数が増える毎に終局が近づくわけではないという違いがあります。オセロ、将棋、消える三目並べ、３つのゲームはそれぞれ微妙に違うわけです。こんな違いを意識している人は世の中にどれぐらいいるでしょうか&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>三目並べと同じ方法でオセロや将棋を作れるか</title>
   <link href="https://happyclam.github.io/programming/2016-10-21/ml_miscellaneous"/>
   <updated>2016-10-21T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-10-21/ml_miscellaneous</id>
   <content type="html">&lt;h3 id=&quot;無理とは分かっていても何とかしたい&quot;&gt;無理とは分かっていても何とかしたい&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;をリリースした後、このアプリと同じAIの作り方（勝ったらご褒美、負けたら罰を与える）でオセロや将棋を作れないだろうかと考えてみました。同じコードを再利用して（楽して）他のゲームが作れるなら作る側の人ならやってみたいと思うでしょう。使う側のユーザーも、なんで「進化する将棋」や「進化するオセロ」じゃないの？「三目並べでは簡単すぎて楽しめない」という人もいるかもしれません。でも、想像つくとは思いますが、三目並べなのには理由があります。ネットで検索してみたところ、オセロで出現し得る局面の数は約&lt;script type=&quot;math/tex&quot;&gt;10^{60}&lt;/script&gt;で、将棋は&lt;script type=&quot;math/tex&quot;&gt;10^{360}&lt;/script&gt;だそうです。私が作った三目並べは以前&lt;a href=&quot;/software/2015-10-19/multi_branched_tree&quot;&gt;記事&lt;/a&gt;にも書きましたが、局面の数は&lt;script type=&quot;math/tex&quot;&gt;10^7&lt;/script&gt;以下で詳細は次の表の通りです。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;手数 \ 重複チェック&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　有り　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　無し　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;252&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;504&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;756&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3,024&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15,120&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,680&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;60,480&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;181,440&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;630&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;362,880&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;126&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;362,880&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;計　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6,046&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;986,410&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　三目並べだからこそ比較的容易に作れたってことです&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。三目並べでは重複局面を省けばわずか6,046通りの局面データを保持すれば済みます。100,000回対戦テスト後の手元の学習ファイル（ゲーム木データを保存したファイル）のサイズを見ると重複チェック用のデータと合わせて約800KBですので、&lt;code&gt;一局面分のデータ（約130バイト）× 6,046局面 ＝ ８００KB&lt;/code&gt;って感じでしょうか。もしオセロの全局面を保存しようとすると、１テラバイトが&lt;script type=&quot;math/tex&quot;&gt;2^{40}&lt;/script&gt;（=約&lt;script type=&quot;math/tex&quot;&gt;10^{12}&lt;/script&gt;）なので&lt;script type=&quot;math/tex&quot;&gt;10^{60}&lt;/script&gt;というオセロの局面数（重複局面を省けばもっと減ると思いますが）を保存するためには、とんでもないディスク容量が必要です。スマホでは全然容量が足りませんし、局面の検索の時間もかかるでしょうし、今のやり方そのままではオセロや将棋のアプリを作るのは現実的ではないということです。&lt;br /&gt;
　でも、&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;はゲーム木（全局面の分岐を木構造で表現したデータ）を動的に生成するので、オセロの局面がいくら多いといっても１ゲームごとに少しずつノード（局面データ）を追加していくのであればとりあえずディスク容量に余裕があるPCで動かすソフトは作れるんじゃないか、なんて考えてとりあえず試しに作ってみようかと思ったりしたのですが、ゲーム木のノードの数が多いと一回のゲームで得られる学習効果が非常に薄まるのでいくら対戦しても全然強くならない（学習効果が実感できない）ものになるでしょう。プログラム同士で対戦させて予め学習を進めてからリリースするという方法も考えられますが、それにしてもデータを小さくしなければならないという問題は解決する必要があります。&lt;br /&gt;
　データを小さくする（ゲーム木を小さくする）ために回転・対照形を同一局面と見做して省略する&lt;a href=&quot;/software/2015-11-27/reinforcement&quot;&gt;記事&lt;/a&gt;は以前も書きましたが、この時は局面の数を求めるためだけに力技でプログラムを改変したのですが、AIに組み込むとなると、処理に手間取って操作性に影響が出るのも嫌なので手付かず状態です。機種にもよりますが現状でもAI側が指し手を決める時に動作が少し重いのを感じると思いますが、これは局面の先読みをする必要がない代わりに、検索と数値計算処理に手間がかかっているからです。&lt;/p&gt;

&lt;h3 id=&quot;消える三目並べなら何とかなりそう&quot;&gt;「消える三目並べ」なら何とかなりそう&lt;/h3&gt;
&lt;p&gt;　「無限三目並べ」、「無限まるばつ」、「Arrange Line」いろんな名前でリリースされているゲームで、正式名称は分かりませんが、「消える三目並べ」というのは、三つまでは普通に置けるけど、四つ目を置くと最初に置いた自分の駒が消えるというルールの三目並べのことです。&lt;/p&gt;

&lt;h4 id=&quot;消える三目並べのゲーム進行の一例&quot;&gt;「消える三目並べ」のゲーム進行の一例&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/battle_sample.png&quot; alt=&quot;例１&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　上の図の進行を見ていただければルールはすぐにわかると思いますが、５手目でダブルリーチを掛けている先手（X）が勝ちかと思いきや、次の手を打つと自分の３手前の駒が消えるのでダブルリーチを掛けたにも関わらず先手（X）が負けになっています。&lt;/p&gt;

&lt;p&gt;　このゲームに関しては以前にも&lt;a href=&quot;/software/2014-09-23/tictactoe_arrange&quot;&gt;「ちょっと変わった三目並べ」というアプリ&lt;/a&gt;の記事として書きました。思いつきの汚いコードを晒しています&lt;img class=&quot;emoji&quot; title=&quot;grin&quot; alt=&quot;grin&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/grin.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;が、指し手をキュー（queue）に格納するようにコードを書き直して、どれぐらいの局面の数になるのか確認してみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;手数 \ 重複チェック&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　有り　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　無し　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;252&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;504&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;756&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3,024&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15,120&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,680&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;60,480&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;計　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4,030&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　そうすると、思惑通りというか予想通りというか当たり前というか、Xが３手Oが３手の計６手進んだあとは、局面の数は増えることがありません。重複チェック無しだとカウント処理が終わらないので&lt;code&gt;-&lt;/code&gt;としましたが、&lt;del&gt;上の表でわかる通り、通常の三目並べよりデータ量は少なくて済みます。&lt;/del&gt;ゲーム終了までの手数は増えていきますが、AIに報酬や罰を与えるのはゲーム終了時の１回だけなので、局面の重複チェックさえしていればデータが無制限に増えることもありません。&lt;br /&gt;
　おまけにAIに勝つためには通常の三目並べより頭を使うので、三目並べじゃ物足りないという人にとっても楽しめそうな気がします。初めのうちは簡単に勝てていたのにだんだん勝てなくなるというのがAI（人工知能）の醍醐味だと思うので自分の思惑通りのアプリが出来そうです。それともう一つ、通常の三目並べはお互い最善手を選択し続けると引分になりますが、このゲームは引分にはならない（千日手はあり得る）ので、その点も良さそうです。&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」&lt;/a&gt;をプレイしていて、「人」に進化するまでやってみようと思ってますが、引分ばかりでは辛いなと思っていたところなので、まずこれを作ってリリースしようかなと思っています。&lt;br /&gt;
　これが完成すれば次はミニ将棋（３X３将棋、５X５将棋、９マス将棋）辺りに挑戦しようかと思ってます。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;名前を忘れてしまったのですが、２０年以上前に対戦する度に強くなると謳った将棋ソフト（シェアウェア）があったと思うのですが、どのような仕組みだったのかよく知りません。今でもあるのでしょうか？ &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>JavaScriptでスプライトシートを使う</title>
   <link href="https://happyclam.github.io/programming/2016-10-04/spritesheet"/>
   <updated>2016-10-04T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-10-04/spritesheet</id>
   <content type="html">&lt;h3 id=&quot;せっかくtexturepackerのブロガーライセンスを取得したのでアプリに使ってみました&quot;&gt;せっかくTexturePackerのブロガーライセンスを取得したのでアプリに使ってみました&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/programming/2016-08-25/texturepacker&quot;&gt;以前の記事&lt;/a&gt;に書いたように、CEO直々にブロガーライセンスを認めてもらったので義理を果たすためにも記事を書いておくことにしました&lt;img class=&quot;emoji&quot; title=&quot;smile&quot; alt=&quot;smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;ただ単に画像ファイルをパックするだけでは意味が無いので簡単なアニメーションを表示しています。&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;androidアプリ&lt;/a&gt;で使用するので、ネットワークに繋がっていなくても使用できるようにCDNは使わずに&lt;a href=&quot;https://github.com/CreateJS/&quot;&gt;ここ&lt;/a&gt;から必要なファイルをダウンロードして使用します。&lt;/p&gt;

&lt;h3 id=&quot;スプライトシートの作成&quot;&gt;スプライトシートの作成&lt;/h3&gt;
&lt;p&gt;　まずはスプライトシートの作成ですが、右側のメニューから[Data] -&amp;gt; [Data Format] -&amp;gt; [EaselJS / CreateJS]を選んで、画像を画面中央にドラッグ＆ドロップするだけです。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/texturepacker1.png&quot;&gt;&lt;img src=&quot;/images/texturepacker1.png&quot; alt=&quot;TexturePacker起動画面&quot; title=&quot;Texture Packer 起動画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　その後、上部のメニューから[File] -&amp;gt; [Publish sprite sheet]でファイル出力します。&lt;br /&gt;
　画像が一枚のシートに収まらない時はエラーになるので、[Layout] -&amp;gt; [Multipack]をチェックしてやり直します。[Layout] -&amp;gt; [Max Size]でシートのサイズを変更することも出来ます。&lt;/p&gt;

&lt;div style=&quot;width:480px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/texturepacker2.png&quot;&gt;&lt;img src=&quot;/images/texturepacker2.png&quot; alt=&quot;ドラッグ＆ドロップ後画面&quot; title=&quot;ドラッグ＆ドロップ後画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;javascriptからスプライトを生成してアニメーション&quot;&gt;JavaScriptからスプライトを生成してアニメーション&lt;/h3&gt;
&lt;p&gt;　TexturePackerで作成したスプライトシート（pngファイル）とjsonファイルを使用して作ったサンプルが以下のコードです。スプライトシート内の大きさが異なる画像を、Canvasのサイズに合わせて徐々に拡大表示するものです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用したHTMLファイル&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-HTML&quot;&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html lang=&quot;ja&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;script src=&quot;js/easeljs-0.8.2.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;js/tweenjs-0.6.2.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
      //ここに以下のJavaScriptをコピペ
    &amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;スプライトシートテスト（Tictactoe Evo）&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;javascript:init();&quot;&amp;gt;&amp;lt;button type=&quot;button&quot;&amp;gt;アニメーション&amp;lt;/button&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;canvas id=&quot;canvasImage&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;display:block; margin:0 auto;&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;使用したスクリプト&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;    &amp;lt;script&amp;gt;
    var stage, imgData, frame, filename;
    function setImageData(idx) {
        switch (idx) {
        case 0:
            frame = [1, 1, 767, 714];
            filename = &quot;./images/test.png&quot;;
            break;
        case 1:
            frame = [1, 717, 382, 336];
            filename = &quot;./images/test.png&quot;;
            break;
        default:
            frame = [1, 1, 767, 714];
            filename = &quot;./images/test.png&quot;;
            break;
        }
    };
    function handleImageLoad() {
        var data = {
            images: [imgData],
            frames: [
	            frame
            ]
        }
        var orgX = document.getElementById(&quot;canvasImage&quot;).clientWidth;
        var orgY = document.getElementById(&quot;canvasImage&quot;).clientHeight;
        var limitX = orgX / frame[2];
        var limitY = orgY / frame[3];
        var spriteSheet = new createjs.SpriteSheet(data);

        var sprite = new createjs.Sprite(spriteSheet, 0);
        sprite.x = 0;  sprite.y = 0; sprite.scaleX = 0; sprite.scaleY = 0;
        stage.addChild(sprite);

        createjs.Ticker.setFPS(60);
        createjs.Ticker.addEventListener('tick', tickHandler);

        createjs.Tween.get(sprite).to({alpha: 1, scaleX: limitX, scaleY: limitY}, 2000);
    };

    function tickHandler(event) {
        stage.update();
    };

    function init() {
        var imgIndex = Math.floor(Math.random() * 2) + 1;
        stage = new createjs.Stage('canvasImage');
        stage.clear();
        imgData = new Image();
        imgData.onload = handleImageLoad;
        setImageData(imgIndex);
        imgData.src = filename;
    };

    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;TexturePackerで作成したスプライトシート（png）&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/test.png&quot;&gt;&lt;img src=&quot;/images/test.png&quot; alt=&quot;サンプルで使用したスプライトシート&quot; title=&quot;サンプルで使用したスプライトシート&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;実際に動くサンプル&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;script src=&quot;https://code.createjs.com/easeljs-0.8.2.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://code.createjs.com/tweenjs-0.6.2.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var stage, imgData, frame, filename;
    function setImageData(idx) {
        switch (idx) {
        case 0:
            frame = [1, 1, 767, 714];
            filename = &quot;/images/test.png&quot;;
            break;
        case 1:
            frame = [1, 717, 382, 336];
            filename = &quot;/images/test.png&quot;;
            break;
        default:
            frame = [1, 1, 767, 714];
            filename = &quot;/images/test.png&quot;;
            break;
        }
    };
    function handleImageLoad() {
        var data = {
            images: [imgData],
            frames: [
	            frame
            ]
        }
        var orgX = document.getElementById(&quot;canvasImage&quot;).clientWidth;
        var orgY = document.getElementById(&quot;canvasImage&quot;).clientHeight;
        var limitX = orgX / frame[2];
        var limitY = orgY / frame[3];
        var spriteSheet = new createjs.SpriteSheet(data);

        var sprite = new createjs.Sprite(spriteSheet, 0);
        sprite.x = 0;  sprite.y = 0; sprite.scaleX = 0; sprite.scaleY = 0;
        stage.addChild(sprite);

        createjs.Ticker.setFPS(60);
        createjs.Ticker.addEventListener('tick', tickHandler);

        createjs.Tween.get(sprite).to({alpha: 1, scaleX: limitX, scaleY: limitY}, 2000);
    };

    function tickHandler(event) {
        stage.update();
    };

    function init() {
        var imgIndex = Math.floor(Math.random() * 2) + 1;
        stage = new createjs.Stage('canvasImage');
        stage.clear();
        imgData = new Image();
        imgData.onload = handleImageLoad;
        setImageData(imgIndex);
        imgData.src = filename;
    };

&lt;/script&gt;

&lt;p&gt;&lt;a href=&quot;javascript:init();&quot;&gt;&lt;button type=&quot;button&quot;&gt;アニメーション&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div&gt;&lt;canvas id=&quot;canvasImage&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;display:block; margin:0 auto;&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;TexturePackerから出力されたJSONファイル&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;{

&quot;images&quot;: [
    &quot;test.png&quot;
],

&quot;frames&quot;: [
    [1, 1, 767, 714, 0, -18, -19],
    [1, 717, 382, 336, 0, -7, -11]
],

&quot;animations&quot;: {
    &quot;pirorikin&quot;: { &quot;frames&quot;: [0] },
    &quot;kabi&quot;: { &quot;frames&quot;: [1] }
},

&quot;texturepacker&quot;: [
        &quot;SmartUpdateHash: $TexturePacker:SmartUpdate:ce59b366b5148ae3ce22fac87822487c:5be175c4ace8ca5d076f4d54ec83fb03:02ab132358d6d8b512e80119463a8329$&quot;,
        &quot;Created with TexturePacker (https://www.codeandweb.com/texturepacker) for EaselJS&quot;
]

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　TexturePackerから出力されたJSONファイルのフォーマットをそのまま利用する方法があると思うのですが、とりあえずJSONファイル内の画像の座標のみ抜き出してJavaScriptで使用しています。&lt;/p&gt;

&lt;p&gt;　※イラスト画像は&lt;a href=&quot;https://www.irasutoya.com&quot;&gt;「いらすとや」様&lt;/a&gt;のものを利用させていただきました。&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>Tic-tac-toe Evoリリースしました</title>
   <link href="https://happyclam.github.io/project/2016-09-19/tictactoe_evo"/>
   <updated>2016-09-19T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2016-09-19/tictactoe_evo</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=io.github.happyclam&quot;&gt;&lt;img src=&quot;/images/ja_badge_web_generic.png&quot; alt=&quot;進化する三目並べ&quot; title=&quot;進化する三目並べ&quot; width=&quot;155&quot; height=&quot;60&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://itunes.apple.com/jp/app/jin-huasuru-san-mu-bingbe/id1160636693?l=ja&amp;amp;ls=1&amp;amp;mt=8&quot;&gt;&lt;img src=&quot;/images/Download_on_the_App_Store_JP_135x40.svg&quot; alt=&quot;進化する三目並べ&quot; title=&quot;進化する三目並べ&quot; width=&quot;135&quot; height=&quot;40&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby/tree/machinelearning&quot;&gt;Ruby版のソース&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;進化する三目並べtic-tac-toe-evoについて&quot;&gt;「進化する三目並べ（Tic-tac-toe Evo）」について&lt;/h3&gt;
&lt;p&gt;　「進化する三目並べ（Tic-tac-toe Evo）」は、&lt;a href=&quot;https://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「Statistics Hacks」&lt;/a&gt;という統計学の本に紹介されていた強化学習の内容に興味を持った私が自作したRubyのPC用のプログラム（&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;github&lt;/a&gt;に公開している）を、せっかく作ったのだからスマホアプリにして公開してみようと考えて、CoffeeScript（JavaScript）に書き換えてCordovaを使ってスマホアプリに作り変えたものです。&lt;br /&gt;
　詳しくは&lt;a href=&quot;https://happyclam.github.io/software/2015-10-25/machine_learning&quot;&gt;「算数で作る機械学習プログラム」&lt;/a&gt;というタイトルから始まる一連の記事を読んでいただきたいのですが、ここではスマホアプリに関する内容に限定して特有の機能などについて補足していきたいと思います。プログラミングに興味の有る方はソースコード（&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;github&lt;/a&gt;）も見て下さい。&lt;br /&gt;
　アプリにもこの記事のリンクを追加していますので、サポートページとして使っていくつもりです。&lt;/p&gt;

&lt;h5 id=&quot;-進化の過程について&quot;&gt;※ 進化の過程について&lt;/h5&gt;
&lt;p&gt;　三目並べプログラムの学習度合いによって「ピロリ菌」から「人」まで、学習度合いをいろんな生物に例えて画像を表示していますが、「系統樹」「進化」等をキーワードにしてネットで調べながら自分なりに選んだ生物の画像を表示しています。必ずしも人類の進化の過程を正しく表現しているわけではありません。個人的には恐竜の画像なども登場させたかったのですが、ヒトへの進化の過程に恐竜は全く関係ないそうで、自分なりに正しいと思えるものを選んでいます。特に&lt;a href=&quot;https://kagakubar.com/mandala/mandala01.html&quot;&gt;「僕たちの祖先をめぐる15億年の旅」&lt;/a&gt;というサイトが参考になりました。&lt;/p&gt;

&lt;h3 id=&quot;タッチエフェクト機能追加ver136&quot;&gt;タッチエフェクト機能追加（ver1.3.6）&lt;/h3&gt;
&lt;p&gt;　タッチ操作にアプリの反応が遅れているだけなのかタッチ操作が効かなかったのかの区別が付きにくい時があるので、少しでもイライラを無くすために、タッチしたマス目が白っぽくフェードアウトしていく視覚効果を付加しました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;span&gt;タッチエフェクト（バージョン1.3.6以降）&lt;/span&gt;
&lt;a href=&quot;/images/touch-effects.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/touch-effects.png&quot; alt=&quot;タッチエフェクト&quot; title=&quot;タッチエフェクト&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;手番表示機能追加ver136&quot;&gt;手番表示機能追加（ver1.3.6）&lt;/h3&gt;
&lt;p&gt;　アプリで×が先手と決めていることもあって、盤面を見れば次の手番は×か◯かは一目瞭然なので表示していなかったのですが、次にリリース予定の「消える三目並べ」（×３個、◯３個の局面が長々と続くため局面を見ただけでは次の手番がわからない）に備えて表示するようにしました。&lt;/p&gt;

&lt;div style=&quot;width:220px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;span&gt;手番表示（バージョン1.3.6以降）&lt;/span&gt;
&lt;a href=&quot;/images/next-turn.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/next-turn.png&quot; alt=&quot;手番表示&quot; title=&quot;手番表示&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;twitter投稿機能追加ver135&quot;&gt;Twitter投稿機能追加（ver1.3.5）&lt;/h3&gt;
&lt;p&gt;　SNS機能追加のプラグイン（cordova-plugin-x-socialsharing）を組み込みTwitter投稿を可能にしました。プラグインの機能自体はメールへの画像添付やBlueToothでの画像送信も出来るようですがすべての機能を試したわけでもなく、端末によっては使用できない可能性もあります。&lt;/p&gt;

&lt;div style=&quot;width:220px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;span&gt;Twitter投稿ボタン追加&lt;br /&gt;（バージョン1.3.5以降）&lt;/span&gt;
&lt;a href=&quot;/images/twitter_button.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/twitter_button.png&quot; alt=&quot;Twitterボタンスクリーンショット&quot; title=&quot;Twitter投稿ボタン追加&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;学習速度の向上ver130&quot;&gt;学習速度の向上（ver1.3.0）&lt;/h3&gt;
&lt;p&gt;　詳しくは&lt;a href=&quot;/project/2016-12-23/compressed_gametree&quot;&gt;この記事&lt;/a&gt;に書きましたが、学習速度を改善しました。今までのものは、なかなか進化しなくてすぐに飽きてしまった人もいると思いますが、これでかなり改善されたのではないかと思います。但し、学習データの互換性がなくなったので、1.3.0以前のバージョンをお使いの方は、申し訳ありませんが今まで学習した（進化した）分が初期化され、一から（ピロリ菌から）やり直しになってしまいます。でも進化の速度はかなり速くなったので、旧バージョンをそのまま使うより新バージョンに乗り換えたほうがすぐに進化が追いつくと思います。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;span&gt;ウナギに進化するまで約2,000回対戦&lt;br /&gt;（1.3.0以前のバージョン）&lt;/span&gt;
&lt;a href=&quot;/images/eel_old.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/eel_old.png&quot; alt=&quot;旧バージョンスクリーンショット&quot; title=&quot;1.3.0以前のスクリーンショット&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;span&gt;約600回の対戦でウナギに進化&lt;br /&gt;（バージョン1.3.0以降）&lt;/span&gt;
&lt;a href=&quot;/images/eel_new.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/eel_new.png&quot; alt=&quot;新バージョンスクリーンショット&quot; title=&quot;1.3.0以降のスクリーンショット&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　あと、今までの一手毎にゲーム木を生成するバージョンは&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby/tree/dynamic&quot;&gt;dynamicブランチ&lt;/a&gt;に移動し、今回のバージョンを&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby/tree/machinelearning&quot;&gt;machinelearningブランチ&lt;/a&gt;にしています。&lt;/p&gt;

&lt;h3 id=&quot;過去のイラスト表示ver122&quot;&gt;過去のイラスト表示（ver1.2.2）&lt;/h3&gt;
&lt;p&gt;　現時点での学習状況（進化の度合い）をイラストで表現しているわけですが、過去に表示されていたせっかくのかわいいイラストを見ることが出来ないのはもったいないと思ったので、スワイプ操作で過去に表示されていた画像を再度表示できるようにしました。画像の上に指をおいて左または上にスワイプすると「戻る」右または下にスワイプすると「進む」です。&lt;br /&gt;
　あくまで過去の画像が見れるだけで、この先どんな動物に進化するのかは今まで通り見ることは出来ません。「人」まで進化したらすべて見ることが出来ます。「人」の先はどうなるのか、それはやってみてからのお楽しみということにしておきます。&lt;/p&gt;

&lt;h3 id=&quot;デリケートなカテゴリに分類される広告をブロックver122&quot;&gt;デリケートなカテゴリに分類される広告をブロック（ver1.2.2）&lt;/h3&gt;
&lt;p&gt;　アプリ説明欄に「お子様と進化を競ってみては」なんて書いておきながら、広告の種類に関して無頓着でした。デフォルトでブロックされている「制限付きのカテゴリ」に加えて、下図のように「デリケートなカテゴリ」もブロック設定しましたのでお子様にも安心して遊んでいただけると思います。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/ad_setting.png&quot;&gt;&lt;img src=&quot;/images/ad_setting.png&quot; alt=&quot;アプリの広告設定&quot; title=&quot;アプリの広告設定&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;アプリの更新について&quot;&gt;アプリの更新について&lt;/h3&gt;
&lt;p&gt;　Google Playからインストールした場合は、Google Playアプリのメニューから「マイアプリ＆ゲーム」を選んで「更新」のリンクをタップすれば今までの学習データを引き継いだまま更新できます。Amazon App Storeからインストールした場合は、Amazonから送られてくる更新通知を待って更新してください。旧バージョンを削除してから最新バージョンをインストールすることは可能ですが、そうすると対戦成績や学習データが初期化されてしまいますので気をつけてください。&lt;/p&gt;

&lt;h3 id=&quot;イラストのアニメーション機能追加ver118&quot;&gt;イラストのアニメーション機能追加（ver1.1.8）&lt;/h3&gt;
&lt;p&gt;　TexturePackerを使用して画像をスプライトシート化しました。この件に関してはどんな作業が必要だったか近々別の記事を書くつもりです。絵心があればもう少し凝ったアニメーションを付加したかったのですが、今後収益化出来そうならどなたか絵師さんに発注するかもしれません。&lt;/p&gt;

&lt;h3 id=&quot;大画面端末タブレット対応ver118&quot;&gt;大画面端末（タブレット）対応（ver1.1.8）&lt;/h3&gt;
&lt;p&gt;　タブレット端末を持っていないのでiosシミュレータで確認しているだけですが、おそらく大きな端末でも違和感なく使えると思います。今にして思えば、リリース時からやっておくべき作業だったと思いますが、自分がタブレット機を持っていないのと、学習機能のアルゴリズムがちゃんと動作しているかばかり気にしていてすっかり頭から抜け落ちていました。&lt;/p&gt;

&lt;h3 id=&quot;スプラッシュ画像追加ver118&quot;&gt;スプラッシュ画像追加（ver1.1.8）&lt;/h3&gt;
&lt;p&gt;　スプラッシュ画面は要らないと思っていたのですが、せっかくCordova使って開発しているので一応ios対応しておこうと思い、iosシミュレータで起動時に表示されるCordovaアイコンを消そうと調べながらいろいろ作業していたら勝手に付加されました。&lt;/p&gt;

&lt;h3 id=&quot;github上のソースと違う点ver103&quot;&gt;&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;github上のソース&lt;/a&gt;と違う点（ver1.0.3）&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;アプリの学習効率&lt;/li&gt;
  &lt;li&gt;学習度合い（進化の度合い）を表す指標の追加&lt;/li&gt;
  &lt;li&gt;全局面のツリー構造生成の仕方&lt;/li&gt;
  &lt;li&gt;データの読込・保存&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;１アプリの学習効率について&quot;&gt;１．アプリの学習効率について&lt;/h4&gt;
&lt;p&gt;　このアプリの「進化」とは、学習の進捗度合いのことです。学習レベルを表すのに人類の進化に例えれば面白いかなと考えて「進化する三目並べ」としたしだいです。
　今まで数回に渡って&lt;a href=&quot;https://happyclam.github.io/software/2015-12-25/log-linear&quot;&gt;強化学習について&lt;/a&gt;や&lt;a href=&quot;https://happyclam.github.io/software/2016-01-16/flotr2&quot;&gt;学習効果のグラフ&lt;/a&gt;の記事を書きましたが、&lt;a href=&quot;https://happyclam.github.io/software/2016-01-07/correlation&quot;&gt;この記事&lt;/a&gt;で紹介した「線形関数を使って、終盤の手ほど重要視する」やり方をアプリに採用しています。リリース直前に行った最強プログラムと乱数を使ったプログラムとの対戦テストの結果は以下です（1,000回の対戦を1回として100回の対戦、合計100,000回）。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;回 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝540敗460分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;481勝383敗136分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝424敗576分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;518勝352敗130分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝318敗682分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;567勝315敗118分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝270敗730分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;574勝310敗116分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝191敗809分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;618勝261敗121分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝136敗864分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;617勝271敗112分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝120敗880分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;637勝242敗121分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝118敗882分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;677勝217敗106分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 99敗901分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;663勝219敗118分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 74敗926分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;664勝240敗96分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 60敗940分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;708勝181敗111分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 40敗960分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;693勝209敗98分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 33敗967分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;685勝209敗106分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 34敗966分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;685勝200敗115分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 24敗976分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;717勝190敗93分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 21敗979分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;697勝182敗121分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 20敗980分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;731勝164敗105分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 13敗987分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;750勝159敗91分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　１９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 14敗986分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;732勝163敗105分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 15敗985分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;747勝144敗109分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 15敗985分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;725勝178敗97分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 11敗989分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;732勝177敗91分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 17敗983分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;734勝168敗98分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  7敗993分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;766勝148敗86分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  9敗991分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;751勝150敗99分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 15敗985分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;761勝149敗90分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 12敗988分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;740勝158敗102分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  8敗992分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;763勝143敗94分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　２９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 11敗989分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;743勝153敗104分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 13敗987分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;767勝142敗91分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  8敗992分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;748勝149敗103分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  5敗995分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;762勝136敗102分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 23敗977分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;775勝137敗88分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  4敗996分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;760勝146敗94分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 13敗987分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;753勝141敗106分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  7敗993分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;803勝116敗81分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  7敗993分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;768勝124敗108分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  6敗994分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;771勝147敗82分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　３９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  3敗997分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;789勝114敗97分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  6敗994分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;792勝127敗81分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  4敗996分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;768勝132敗100分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  8敗992分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;785勝119敗96分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  4敗996分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;790勝118敗92分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝 13敗987分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;794勝121敗85分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  2敗998分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;792勝116敗92分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  5敗995分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;791勝127敗82分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  6敗994分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;777勝124敗99分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  2敗998分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;801勝112敗87分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　４９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  6敗994分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;805勝105敗90分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　５０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  6敗984分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;766勝153敗81分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　　　:　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;:&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;:&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　９１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  4敗996分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;831勝98敗71分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　９２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  4敗996分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;821勝82敗97分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　９３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  3敗997分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;838勝86敗76分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　９４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  5敗995分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;821勝106敗73分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　９５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  1敗999分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;824勝96敗80分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　９６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  2敗998分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;820勝107敗73分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　９７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  0敗1000分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;818勝88敗94分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　９８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  2敗998分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;832勝94敗74分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;　９９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  4敗996分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;832勝99敗69分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１００回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝  1敗999分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;797勝102敗101分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　上の表の通り、最強プログラム（バックトラック法でゲーム終了まで読み切るので負けることがない）と対戦させたほうが学習効率がいいのは一目瞭然（「強い人と対戦するほど進化が速い」とアプリ紹介欄に書いているのはこのことです）ですが、大まかに言って９０％負けない（＝１００敗を切る）ようになるまでに9,000回、９９％負けない（負け数が一桁になる）ようになるまでに24,000回程度の対戦が必要になることが上記テスト結果からわかります。ただ、テストで使用した最強プログラムは常に最善手を選ぶ（最短手数で勝つ）わけではないですし、内部で乱数を使用していないのでいつも同じ手しか選ばないので、人間が対戦すると実際にはもう少し速く学習が進む余地はあると思っています。だから正直なところ実際にどれ位の速度で学習（進化）するのか自分でもわかっていません。&lt;/p&gt;

&lt;h4 id=&quot;２アプリの進化の度合いの数値について&quot;&gt;２．アプリの「進化の度合い」の数値（％）について&lt;/h4&gt;
&lt;p&gt;　Androidアプリにするに当たって学習効果をどのようにユーザーに伝えようかと考えたのですが、今までブログでやっていたグラフ表示だけでは面白くない。また、上記のような対戦成績はどの程度学習が進んだかの指標には使えません。人間がわざと負けてアプリの勝率が上がれば「進化した」なんて言えるわけありませんし、対戦する人間が強くても、乱数プログラムのように弱くても、対戦回数を重ねるだけで学習が進むからこそ人工知能（AI）と言えるわけですから。
　そこで最初は現時点で保持しているすべての局面データからすべてのリーチ&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;が掛かっている局面を検索して「どれぐらいの確率で勝ちを逃さないか」を計算したのですが、それよりも「どれぐらいの確率で相手が揃うのを防ぐか」を計算した値のほうが上記の対戦成績と似た推移を示したのでその値を「進化の度合い」としてアプリに表示しています。これは人間同士の対局でも同じで、まずは相手が三目揃うのを防ぐ手を優先すると思うので学習度合い（進化度合い）を示す指標としては割りと妥当じゃないかと思ってます。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/screen_degree.png&quot;&gt;&lt;img src=&quot;/images/screen_degree.png&quot; alt=&quot;進化度合い&quot; title=&quot;進化度合い&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h4 id=&quot;３局面のツリーデータ生成について&quot;&gt;３．局面のツリーデータ生成について&lt;/h4&gt;
&lt;p&gt;　&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby/tree/machinelearning&quot;&gt;githubのRubyのソース&lt;/a&gt;では起動時にすべての局面のデータ（多分木データ）を生成しますが、Cordovaアプリ（ハイブリッドアプリ）ではブラウザ（WebViewというブラウザーコンポーネント）上で動くのでネイティブアプリに比べて動作が遅いので、起動時にすべての局面を生成すると２分ぐらい掛かってしまいます。だから初めての起動時は初期局面のみ生成し、未知の局面が現れる度にそのノードに紐づく子ノードを動的に生成するようにしています。&lt;/p&gt;

&lt;h4 id=&quot;４データの読込保存初期化&quot;&gt;４．データの読込・保存・初期化&lt;/h4&gt;
&lt;p&gt;　ツリーデータの保存・読込はlocalStorage.setItemとlocalStorage.getItemを使っています。データベースは使っていません。
　アイコンを長押しして表示される「アプリ情報」メニューから「データを消去」を選べば、Androidの機能を使って対戦成績と学習データの初期化が出来ます。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/screen_initialize.png&quot;&gt;&lt;img src=&quot;/images/screen_initialize.png&quot; alt=&quot;データの初期化&quot; title=&quot;データの初期化画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　あと、もともとRubyのコンソールアプリを元にしているため画面出力に関わるメソッドが&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby/tree/machinelearning&quot;&gt;githubのソース&lt;/a&gt;とは別物になってます。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;あと一手で勝ちになる局面 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>TexturePackerのフリーライセンス</title>
   <link href="https://happyclam.github.io/programming/2016-08-25/texturepacker"/>
   <updated>2016-08-25T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-08-25/texturepacker</id>
   <content type="html">&lt;h3 id=&quot;cocosのパッケージ区分がよくわからない&quot;&gt;Cocosのパッケージ区分がよくわからない&lt;/h3&gt;
&lt;p&gt;　最近&lt;a href=&quot;https://www.cocos2d-x.org/wiki/Getting_Started_Cocos2d-js&quot;&gt;Cocos2d-js&lt;/a&gt;を弄り始めたのですがGUIのパッケージがいろいろあって違いがよくわかっていません。以前CocosStudio（Version3.1）というGUI環境でスプライトシートの作成が出来ていたのですが、なぜか自分の環境で新規プロジェクトの作成が出来なくなってしまいました（コマンドラインでの開発&lt;code&gt;cocos new&lt;/code&gt;は問題なく使えます）。新たにCocosCreatorが出てきたことと関係しているのかどうかわかりませんが、スプライトシートを作るだけならTexturePackerだけあればいいので１年間のフリーライセンスを取得することにしました。cocosについてはまた別の記事をいつか書こうと思ってます。&lt;/p&gt;

&lt;h3 id=&quot;ブロガーライセンスの取得の手順が変わった&quot;&gt;ブロガーライセンスの取得の手順が変わった？&lt;/h3&gt;
&lt;p&gt;　TexturePackerの一年間限定のフリーライセンスの取得に関して検索してみると昔のもの（&lt;a href=&quot;https://oxosi.hatenablog.com/entry/2014/12/27/204407&quot;&gt;TexturePackerの1年ライセンスキーを無料でもらおう&lt;/a&gt;）が多く、昔は申請後にライセンスキーがメールで送られてくるだけだったようですが、今は一手間増えて申請が認められたら自分のブログに認証キーを書き込んで、ブログ所有者本人であることを確認後にライセンスキーが送られてくるような手順になっているみたいです。&lt;a href=&quot;http://moonrailgun.com/2016/04/04/感谢TexturePacker提供的免费软件授权/&quot;&gt;こちらの記事&lt;/a&gt;を参考にしました。&lt;br /&gt;
　過去に実際に申請をした人たちの記事を読んでいたら対応はまちまちのようで一週間返信がなくて再度申請したら通ったとか、すぐにライセンスキーが送られてきたとか、ブログを褒めてもらえたとか、いろいろなパターンがあるようです。自分の場合もちょっとしたやりとりがありました。&lt;br /&gt;
　まず申請の意思の確認のためのメールが送られてきました。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Please confirm your subscription to TexturePacker Blogger License &lt;br /&gt;
&lt;strong&gt;Thanks for your interest in TexturePacker Blogger License,&lt;/strong&gt; &lt;br /&gt;
You signed up for the newsletter on www.codeandweb.com. The newsletter contains: Getting started with the free blogger license for TexturePacker, SpriteIlluminator and PhysicsEditor..&lt;br /&gt;
Please ignore this mail if you did not signup for the newsletter. You only receive the newsletter if you confirm the subscription by clicking on the button below.&lt;br /&gt;
You can unsubscribe from receiving mails at any time.&lt;br /&gt;
Best&lt;br /&gt;
Andresa&lt;br /&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;　次にブログ所有者本人かどうか確認したいのでどこかのページにこのコードを書き込んでくれと言われました。書きこんだ後に通知するためのリンクボタンが付いています。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hi OOOOOO,&lt;br /&gt;
you’ve requested a license for TexturePacker.&lt;br /&gt;
Congratulations: Your blog qualifies for a free license!&lt;br /&gt;
Please verify that this is really your blog by adding the following code somewhere on the blog page.&lt;br /&gt;
TP:XXXXXXXX&lt;br /&gt;
You can remove the code in about 1-4 days. Click on the button below after you’ve added the code.&lt;br /&gt;
Best&lt;br /&gt;
Andreas&lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;button&gt;OK, I’ve added the code&lt;/button&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　送られてきたコードをブログのどこに書けばいいのかよくわからなかったのですが、以下のようにトップページ（http://happyclam.github.io/index.html）にコメントとして書き込んでリンクをクリックしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--
TP:XXXXXXXX
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　そしたら数日後に前回と同じ内容のメールが届きました。どうすればよかったのかよくわからなかったので「トップページにコメントとしてコードを書きこんだけどこれじゃダメなの？」と返信したら「あ〜コメントになってたので気づかなかった」という返事とともにすぐにライセンスキーが送られてきました。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hi OOOOOO,&lt;br /&gt;
you requested a license for TexturePacker:&lt;br /&gt;
TexturePacker: TP-XXXX-XXXX-XXXX-XXXX&lt;br /&gt;
Have fun with the license. I would be happy if you would write blog post about my tools in return.&lt;br /&gt;
Please let me know if you write a tutorial or review - we might link back from our &lt;a href=&quot;#&quot;&gt;tutorials page&lt;/a&gt;.&lt;br /&gt;
Kind regards Andreas Loew&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　私はどうすればよかったのでしょうか？まず、私が少し誤解していたのが、前述の&lt;a href=&quot;https://oxosi.hatenablog.com/entry/2014/12/27/204407&quot;&gt;日本語の紹介記事&lt;/a&gt;や他の申請した人の記事を読んで、レビューや紹介記事を書くことは必須ではないと思い気軽に申請したのですが、向こうとしては記事を書いてそこにコードを埋め込むことを期待していたのかもしれません（それにしても誰もが見えるところに意味不明の認証コードを表示するの？）。確かに&lt;a href=&quot;https://www.codeandweb.com/request-free-license&quot;&gt;本家サイトの申請ページ&lt;/a&gt;にも必須ではないとは書かれていますが、運用方針が変わったのかもしれません。あまりにも売上に繋がらなくて嫌気が差してるとか&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;。ライセンスコードとともに送られてきたメールの「記事を書いたら連絡してね」という文言とともに付けられていた「tutorials page」のリンクも４０４エラーになっていました。&lt;br /&gt;
　それとこういう手続は自動でスクリプトが処理していると思っていたので、サイトのページをパースして文字列検索でもしているのかな？とか勝手に想像していましたが、CEO自身が記事を読んでいるようですね。CEO自身からメールの返信が来たことにも驚きました。日本なら手作業で申請の対応をするにしても、若手の担当者にやらせていることでしょう。&lt;br /&gt;
　厚かましいかもしれませんが、こちらとしてもTexturePackerがどうしても必要というわけでもなく、数種類の画像をドラッグ＆ドロップしてスプライトシートを作成するだけなので、非常に多くの機能は私にとっては持て余し気味で、レビュー記事を書くほど使い込んでもいないし現時点では購入する気にはなれないんですよねぇ。最終的には「感謝して使わせてもらいます」と返信しましたが、それほど多くの画像を使う予定もないし、そもそもが購入した本のサンプルコードでスプライトシートを使っていたから真似をしただけという状態ですから、もう少し使ってみてから購入するかどうか決めようと思います。&lt;br /&gt;
　このAndreasっていうCEOはQ&amp;amp;Aサイトとかでも積極的に回答したりしているようで、未だにパソコン操作出来ないような人がIT企業の社長やってたりする日本とは大違いですね。&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>９マス将棋（３×３将棋）と三目並べの変化形</title>
   <link href="https://happyclam.github.io/programming/2016-07-23/33shogi"/>
   <updated>2016-07-23T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-07-23/33shogi</id>
   <content type="html">&lt;h3 id=&quot;たかが３３の狭い空間でも完全読み切りは大変だ&quot;&gt;たかが３×３の狭い空間でも完全読み切りは大変だ&lt;/h3&gt;
&lt;p&gt;　Twitterで&lt;a href=&quot;https://mainichi.jp/articles/20160612/k00/00e/040/105000c&quot;&gt;９マス将棋発売&lt;/a&gt;というニュースが流れていたので、検索してみると同じ９マス（３×３）と言えどもいろいろなパターンがあるようです&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。Androidアプリで見つけた&lt;a href=&quot;https://play.google.com/store/apps/details?id=org.dyndns.vivi.SkskShogi33&quot;&gt;「３×３将棋」&lt;/a&gt;というのをやってみると玉頭戦を戦っている気分になれて、想像していた以上に楽しめました。他にも一番シンプルなものでは盤上には玉だけを配置して、持ち駒に銀と歩を持ったところからゲームを開始する&lt;a href=&quot;http://www.nakajim.net/?3三将棋&quot;&gt;「３三将棋」&lt;/a&gt;というルールもあるようです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;span&gt;３三将棋の初期盤面&lt;/span&gt;
&lt;a href=&quot;/images/33shogi_screen_00.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/33shogi_screen_00.png&quot; alt=&quot;３三将棋の初期盤面&quot; title=&quot;３三将棋の初期盤面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;/software/2014-09-09/pre_shogi&quot;&gt;以前の記事&lt;/a&gt;でShoesとRubyで作成した将棋プログラムの記事を書きましたが、この３三将棋のルールなら先手必勝あるいは後手必勝の手順が見つけられるかもと思い、ちょっとだけ試してみました。&lt;br /&gt;
　やり方は以前&lt;a href=&quot;/software/2014-09-23/tictactoe_arrange&quot;&gt;ちょっと変わった三目並べの記事&lt;/a&gt;で書いた方法と同じで、先読みの制限手数を指定して徐々にその先読み手数を伸ばしていくというやり方です。先読み手数を制限せずに勝負がつくまでという条件で先読みを続けたいところ（通常の三目並べならそれが可能）ですが、おそらく何年経ってもプログラムが終了しない状況になってしまうでしょう。MIN-MAX法（＋αβ法）で先読み手数を指定して、その手数に達するまでに先手勝ち（あるいは後手勝ち）の評価値を返してくれば、必勝手順があるという確認方法です。現れ得るすべての局面を読む（手数を制限せずに先読みする完全読み切り）ことをしなくていいので、必勝手順があるかどうかの結論を得るにはこの方法が一番簡単です。この時先読みに使用する評価関数は先手勝ち（最大値）、後手勝ち（最小値）、それ以外（０）の３値だけを返す評価関数を使います。局面が有利か不利かは関係ないので玉の硬さがどうとか「と金」の評価値がどうとかは計算する必要はありません。また、初型からの詰将棋を解くのとも少し違います、王手を続けなければいけないわけではありませんし、自玉が詰まされなくても指す手が無くて負けることもあるからです。どうやら３三将棋は王手が掛かってなくても指す手が無くなって負けるパターンが多いようです。&lt;br /&gt;
　で、結論から先に言うと、先手必勝なのか後手必勝なのか千日手になるのか結局はっきりした結論は得られませんでした。たかだか十数手の先読みしか試せなかったのでその手数内では必勝手順はないということです（詰み手順もありません）。たかが３×３の盤上の変化と言えども、将棋はオセロや囲碁と違って一手毎にマス目が埋まり徐々に終局が近づいていくゲームと違うのでマス目が少ないからと言ってもなかなか結論を出すのは難しそうです（オセロや囲碁なら簡単と言ってるわけではありません）。&lt;br /&gt;
　対戦の手順の一例を示すと以下の様な感じです。&lt;/p&gt;

&lt;script&gt;
    var i;
    var n = 0;
    var pngs = new Array(20);
    for (i=0; i&lt;20; i++) {
        pngs[i] = new Image(640,480);
    };
    pngs[0].src　=&quot;/images/33shogi_screen_01.png&quot;;
    pngs[1].src　=&quot;/images/33shogi_screen_02.png&quot;;
    pngs[2].src　=&quot;/images/33shogi_screen_03.png&quot;;
    pngs[3].src　=&quot;/images/33shogi_screen_04.png&quot;;
    pngs[4].src　=&quot;/images/33shogi_screen_05.png&quot;;
    pngs[5].src　=&quot;/images/33shogi_screen_06.png&quot;;
    pngs[6].src　=&quot;/images/33shogi_screen_07.png&quot;;
    pngs[7].src　=&quot;/images/33shogi_screen_08.png&quot;;
    pngs[8].src　=&quot;/images/33shogi_screen_09.png&quot;;
    pngs[9].src　=&quot;/images/33shogi_screen_10.png&quot;;
    pngs[10].src　=&quot;/images/33shogi_screen_11.png&quot;;
    pngs[11].src　=&quot;/images/33shogi_screen_12.png&quot;;
    pngs[12].src　=&quot;/images/33shogi_screen_13.png&quot;;
    pngs[13].src　=&quot;/images/33shogi_screen_14.png&quot;;
    pngs[14].src　=&quot;/images/33shogi_screen_15.png&quot;;
    pngs[15].src　=&quot;/images/33shogi_screen_16.png&quot;;
    pngs[16].src　=&quot;/images/33shogi_screen_17.png&quot;;
    pngs[17].src　=&quot;/images/33shogi_screen_18.png&quot;;
    pngs[18].src　=&quot;/images/33shogi_screen_19.png&quot;;
    pngs[19].src　=&quot;/images/33shogi_screen_20.png&quot;;
    function first_png(object, img) {
        n = 0;
        object.src = img[0].src;
    };
    function last_png(object, img) {
        n = 19
        object.src = img[19].src;
    };
    function next_png(object, img) {
        console.log(n);
        if (n &lt; 19) {
            n += 1;
            object.src = img[n].src;
        }
    };
    function prev_png(object, img) {
        console.log(n);
        if (n &gt; 0) {
            n -= 1;
            object.src = img[n].src;
        }
    };
&lt;/script&gt;

&lt;form id=&quot;frmboard&quot; name=&quot;board&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;&amp;lt;&amp;lt;&quot; onclick=&quot;first_png(document.board.pngscreen, pngs);&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;&amp;lt;&quot; onclick=&quot;prev_png(document.board.pngscreen, pngs);&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;&amp;gt;&quot; onclick=&quot;next_png(document.board.pngscreen, pngs);&quot; /&gt;
    &lt;input type=&quot;button&quot; value=&quot;&amp;gt;&amp;gt;&quot; onclick=&quot;last_png(document.board.pngscreen, pngs);&quot; /&gt;&lt;br /&gt;    
　　&lt;img id=&quot;pngscreen&quot; name=&quot;screen&quot; src=&quot;/images/33shogi_screen_01.png&quot; width=&quot;640&quot; height=&quot;480&quot; vspace=&quot;10&quot; /&gt;
&lt;/form&gt;

&lt;p&gt;　最終局面は後手の指す手が無くなって、先手勝ちになってます。この例のように自分が試した多くの結果が先手か後手か一方が指す手が無くなって負けるパターンでした。一度形勢を損ねたら指す手が悪手しかなくなり更に形勢を悪くしていく感じです。&lt;br /&gt;
　また、自分が試したプログラムは千日手対応をしていないのですが、指定した先読み手数内に必勝手順があるなら千日手を避けてその手順を選ぶはずなので関係ありません。もっと深く読めば「先手必勝」あるいは「後手必勝」の結論が出る可能性がありますが、逆に「先手勝ち」あるいは「後手勝ち」の評価が得られたけど、実はもっと深く読めば「千日手」の結論に変わるということはあり得ないということです。この辺りの事情は&lt;a href=&quot;/software/2014-10-04/arrange_line&quot;&gt;以前の記事&lt;/a&gt;にも書いた通りですが、「お互いに最善手を選ぶと千日手になる」という結論を出すには、完全読み切りするしかないのかもしれません。自分としては&lt;a href=&quot;/software/2014-10-04/arrange_line&quot;&gt;以前の記事&lt;/a&gt;の時と同様に、試しにやってみて結論が出れば面白いなと思ってやってみただけなのでこれで良しとします。&lt;/p&gt;

&lt;h3 id=&quot;思わぬ収穫が&quot;&gt;思わぬ収穫が&lt;/h3&gt;
&lt;p&gt;　３三将棋の結論が出なかったのでわざわざこの記事を書く気はなかったのですが、いろいろプログラムを弄っている最中に以前書いた&lt;a href=&quot;/software/2014-10-04/arrange_line&quot;&gt;変則三目並べの記事&lt;/a&gt;&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;の「&lt;strong&gt;先手必勝&lt;/strong&gt;」の結論が追認されるような発見があったので書いておこうという気になりました。どちらかというと自分にとってはこちらの話の方が本題です。「無限三目並べは先手必勝」というお話です。９マス将棋のタイトルに惹かれて訪問された方、すいません。&lt;br /&gt;
　&lt;a href=&quot;/software/2014-10-04/arrange_line&quot;&gt;この記事&lt;/a&gt;を書いた時は&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.bbside.arrangeline&quot;&gt;「ArrangeLine」&lt;/a&gt;というアプリを使っていたのですが、同様のアプリで&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.nekobukiya.tictactoe&amp;amp;hl=ja&quot;&gt;「無限○×」&lt;/a&gt;、&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.devhydrangea.Sanmokunarabe&amp;amp;hl=ja&quot;&gt;「無限三目並べ」&lt;/a&gt;というものがあることを知り、それぞれダウンロードして試してみました。やはり自分のソフトと対戦させてみるとアプリの設定を最強にしていても先手では自分のソフトが必ず勝ちますし、やはりこのゲーム（無限三目並べ）は先手必勝のゲームなんだなと思って遊んでいると、&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.devhydrangea.Sanmokunarabe&amp;amp;hl=ja&quot;&gt;「無限三目並べ」&lt;/a&gt;というアプリではなんと以下のように先手の場合は初手に辺の位置（&lt;a href=&quot;/software/2014-09-23/tictactoe_arrange&quot;&gt;以前の記事&lt;/a&gt;の2,4,6,8の位置）を選択できないようになっていたのです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/mugen_sanmoku.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/mugen_sanmoku.png&quot; alt=&quot;無限三目並べの実行画面&quot; title=&quot;無限三目並べの実行画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　やはりこのゲーム（三手前に打った駒が消えるルールの三目並べ、無限三目並べ）は辺の位置に初手を打てば先手必勝ということでしょう。私は記事に書いたとおり、自作プログラムを弄っていてたまたま無限三目並べというゲームが先手必勝なのではないかという結論を得たのですが、どうやらテーブルゲーム業界（実際にあるかどうか知りません）では公然の秘密（ネタバレ防止目的？）として知られていたことなのかもしれません。私はこのゲームの作者を知りませんし、この分野の研究者（そんな人がいる？）の知り合いもいませんのでわかりませんが、既に誰かが結論を出してどこかに論文でも存在するのかもしれません。&lt;br /&gt;
　とにかく自分で行き着いた結論が間違ってなかったようなので嬉しくなってこの記事を書くことにしました。&lt;br /&gt;
　※その後自作のアプリもリリースしました→&lt;a href=&quot;https://play.google.com/store/apps/details?id=tictactoe_van.io.github.happyclam&quot;&gt;消える三目並べ&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;思うこと&quot;&gt;思うこと&lt;/h3&gt;
&lt;p&gt;　自作の将棋プログラムはRuby製（動的型付け）なので速度的に限界があるので、C++で一から３×３の将棋プログラム（いずれはスマホアプリ）を作ってみようかなどと考えてます&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。でも将棋はルールを反映させるだけでも一苦労なんですよねぇ。オセロなら一から作りなおしても大した手間は掛からないのですが…。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;ニュースで流れていた９マス将棋のルールについては&lt;a href=&quot;http://rosetrend1.com/2016/06/18/9マス将棋ルールまとめ！無料フラッシュやアプリ/&quot;&gt;ここ&lt;/a&gt;が詳しかったです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;決まった名称が無いようなのですが、３手前に打った駒が消えるルールの三目並べを「無限三目並べ」と呼ぶことが多いようです。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;単純にC++に置き換えただけでは大した効果はなく先読みの深さが数手伸びるだけだと思います。詳しく知りませんが、どうぶつしょうぎの完全読み切りをしたプログラムは速度アップのためのデータ構造もかなり工夫しているようです。局面データを単なる配列データで保持している自分のやり方では完全読み切りは無理そうです。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>CoffeeScriptで割り込み処理</title>
   <link href="https://happyclam.github.io/programming/2016-05-18/coffee_settimeout"/>
   <updated>2016-05-18T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-05-18/coffee_settimeout</id>
   <content type="html">&lt;h3 id=&quot;重たい処理をしている最中に再描画する方法&quot;&gt;重たい処理をしている最中に再描画する方法&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/programming/2016-05-02/coffee_serialize&quot;&gt;前回&lt;/a&gt;同様Ruby製プログラムをCoffeeScript（JavaScript）に移植する際の話ですが、PC上で動くプログラムでもそうですが、重たい処理をしている最中に画面の更新をしたい時があると思います。三目並べの全局面データを作成する処理がRuby製プログラムで４、５秒かかるのですが、この処理をブラウザ上で動かすCoffeeScript（JavaScript）製のプログラムにした時の顛末を書きます。&lt;/p&gt;

&lt;h3 id=&quot;スレッドが使えない&quot;&gt;スレッドが使えない&lt;/h3&gt;
&lt;p&gt;　今回の三目並べプログラムは&lt;a href=&quot;/project/2015-10-10/tictactoe_bfs&quot;&gt;BFS（Breadth First Search）アルゴリズム&lt;/a&gt;や&lt;a href=&quot;/software/2015-10-25/machine_learning&quot;&gt;機械学習プログラム&lt;/a&gt;の動作確認用のサンプルとして作ったものですから、レスポンスが遅くても問題なかったのですが、以前Rubyと&lt;a href=&quot;https://shoesrb.com&quot;&gt;Shoes&lt;/a&gt;でGUIの将棋プログラムを作った時は、先読みさせる時に別スレッドを起動して画面を更新しました。人間とソフトの対戦中のループ処理内に&lt;code&gt;Thread.new&lt;/code&gt;で囲んだブロックを以下のように入れておくだけで、ソフトが思考中でもユーザーの操作を妨げることなく画面の再描画やメニュー操作をすることが出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@thinking = Thread.new do
    #思考ルーチンを呼び出す処理　
    @game_end = true unless @game.command(@board, player)
    #画面再描画処理
    draw_board
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　非GUIのソフトならsleep関数を呼び出すだけで済む場合もあると思いますし、Windowsのソフト（GUIソフト）でも簡単な仕組みが用意してあって、何らかのループ処理中に&lt;code&gt;PM_REMOVE&lt;/code&gt;フラグを付けて&lt;code&gt;PeekMessage&lt;/code&gt;というWindowsAPIを呼び出すだけで画面を再描画させることが出来ます。VisualBasicなら&lt;code&gt;DoEvents&lt;/code&gt;コマンドを呼び出すだけ、Delphiなら&lt;code&gt;Application.ProcessMessages&lt;/code&gt;を呼び出すだけで画面を再描画（Windowsシステムの待ち行列に溜まっているWindowsメッセージを処理）してくれます。非常に重たい処理を行う関数があったとして、その中で画面の再描画をしたい場合を疑似コードで書いてみると以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#重たい処理を行う関数
function heavy()
    #重たいループ処理（while文）
    while 何らかの条件
        #重複しない局面を保存する処理
        Pickup()
        #画面描画関数呼び出し
        Draw()
        #OSに制御を返す（＝再描画される）
        PeekMessage || DoEvents || Application.ProcessMessages || etc...
    end
end

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;やりたい処理を行う&lt;/li&gt;
  &lt;li&gt;画面描画処理を行う&lt;/li&gt;
  &lt;li&gt;OSに制御を返す&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　1.2.に加えて3.の処理を追加するだけでループ中に画面の再描画をさせることが出来ます。&lt;br /&gt;
　でもJavaScriptはブラウザのプロセス内で動くプログラムなのでシングルスレッドでしか動かせないので、ループ処理の中に１行追加するだけでいいというわけにはいかないようです。タイマーを使った割り込み処理と言っていいと思うのですが、重たい処理をぶつ切りに区切って一定時間毎に実行するイメージに書き換える必要があります。上記のように一行書き加えるだけで済むようなものではなく、処理の流れを考慮してコードを書き換えないといけないので結構面倒です。大昔&lt;code&gt;MS−DOS&lt;/code&gt;の割り込み処理を書いた時を思い出しました。その時とはコードスタイルが違いますが…。&lt;/p&gt;

&lt;h3 id=&quot;配列を使ったサンプル&quot;&gt;配列を使ったサンプル&lt;/h3&gt;
&lt;p&gt;　実際にはBFSで三目並べの全局面（986,410）を検索して、重複のない局面６０４６個のオブジェクトを多分木データオブジェクトに追加していく処理（２分ほどかかる）だったのですが、分かりやすいように単純な配列を使ったサンプルコードに書き換えてみました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;処理中に再描画しないサンプル&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;$ -&amp;gt;
    new Sample

class Sample
    constructor: -&amp;gt;
        @status = null
        @trees = null
        @progressBar = document.getElementById(&quot;progressbar&quot;)
        @startbtn = document.getElementById(&quot;btnStart&quot;)
        @spanCount = document.getElementById(&quot;spanCount&quot;)
        @statusarea = document.getElementById(&quot;spanStatus&quot;)
        @labelprogress = document.getElementById(&quot;trees&quot;)
        $('#btnStart').on 'click', (e) =&amp;gt;
            target = $(e.currentTarget)
            @btnstart(target)

    btnstart: (target) -&amp;gt;
        @trees = new Array()
        @heavy()
        @statusarea.innerHTML = @trees.length.toString()

    heavy: -&amp;gt;
        seq = 0
        while seq &amp;lt; 6046
            seq += 1
            @trees.push(seq)
            bar = (seq / 6046) * 100
            console.log(@trees.length.toString())
            @spanCount.innerHTML = Math.floor(bar) if bar?
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;進捗状況をプログレスバーに表示しながら処理するサンプル&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;$ -&amp;gt;
    new Sample

class Sample
    constructor: -&amp;gt;
        @status = null
        @trees = null
        @progressBar = document.getElementById(&quot;progressbar&quot;)
        @startbtn = document.getElementById(&quot;btnStart&quot;)
        @spanCount = document.getElementById(&quot;spanCount&quot;)
        @statusarea = document.getElementById(&quot;spanStatus&quot;)
        @labelprogress = document.getElementById(&quot;trees&quot;)
        $('#btnStart').on 'click', (e) =&amp;gt;
            target = $(e.currentTarget)
            @btnstart(target)

    btnstart: (target) -&amp;gt;
        @labelprogress.style.display = &quot;block&quot;
        @heavy(0)

    heavy: (seq) -&amp;gt;
        if seq == 0
            @trees = new Array()
        if seq &amp;lt; 6046
            seq += 1
            @trees.push(seq)
            bar = (seq / 6046) * 100
            setTimeout (=&amp;gt;
                @heavy(seq)
            ), 0
        else
            bar = 100
            @labelprogress.style.display = &quot;none&quot;
        console.log(@trees.length.toString())
        @statusarea.innerHTML = @trees.length.toString()
        @progressBar.value = Math.floor(bar) if bar?
        @spanCount.innerHTML = Math.floor(bar) if bar?
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;共通で使用するHTML&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;ja&quot;&amp;gt;
&amp;lt;head&amp;gt;  
  &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;SetTimeout サンプル&amp;lt;/title&amp;gt;
  &amp;lt;script src=&quot;js/jquery-1.11.2.min.js&quot;&amp;gt; &amp;lt;/script&amp;gt;
  &amp;lt;script src=&quot;sample.js&quot; defer&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p id=&quot;title&quot;&amp;gt;SetTimeout サンプル&amp;lt;/p&amp;gt;
&amp;lt;label id=&quot;trees&quot; style=&quot;display: none;&quot;&amp;gt;&amp;lt;progress id=&quot;progressbar&quot; value=&quot;0&quot; max=&quot;100&quot;&amp;gt;&amp;lt;/progress&amp;gt;&amp;lt;span id=&quot;spanCount&quot;&amp;gt;&amp;lt;/span&amp;gt;%&amp;lt;/label&amp;gt;
&amp;lt;p&amp;gt;
&amp;lt;input id=&quot;btnStart&quot; type=&quot;button&quot; value=&quot;Start!&quot;&amp;gt;
&amp;lt;span id=&quot;spanStatus&quot; style=&quot;color: red;&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;coffee -c&lt;/code&gt;でCoffeeScriptファイルをコンパイル後（sample.js）ブラウザで実行&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/settimeout.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/settimeout.png&quot; alt=&quot;setTimeoutを使ったサンプル&quot; title=&quot;SetTimeoutを使ったサンプル&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;settimeoutを使った割り込み処理に書き換えるコツ&quot;&gt;setTimeoutを使った割り込み処理に書き換えるコツ&lt;/h3&gt;
&lt;p&gt;　配列を使ったサンプルだとそれほどでもないですが、処理内容によってはタイマーを使った（setTimeoutを使った）割り込み処理に書き換える際に、どこから手をつけていいか悩むことがあるかもしれません。コツとしては重たいループ処理をまずはカウンターを使った処理に書き換えることです。今回BFSで局面を辿っていく際に新規局面を生成してキュー（queue）に追加し、&lt;strong&gt;「キューが空になるまで繰り返す」&lt;/strong&gt;というループだったのですが、&lt;strong&gt;「カウンターの数値が何回になるまで繰り返す」&lt;/strong&gt;というようにシーケンシャルな数値の条件に書き換えて、そのトータルの回数（今回は6046）を終了条件とした再帰関数を作るってことです。&lt;br /&gt;
　あと気をつけないといけないのは、setTimeoutで呼び出した関数は非同期で実行されるということです。スタートボタンを押した時のイベントに、以下のように重たい関数の実行が終わったら配列の総数を表示するコードを書いていますが、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    btnstart: (target) -&amp;gt;
        @trees = new Array()
        @heavy()
        @statusarea.innerHTML = @trees.length.toString()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　setTimeoutを使ったサンプルをこれと同じように書いてもheavy関数の実行終了を待たずに実行されるので意味がありません。setTimeoutを使ったサンプルで、初期化処理（&lt;code&gt;@trees = new Array()&lt;/code&gt;）と終了時の処理（&lt;code&gt;@statusarea.innerHTML = @trees.length.toString()&lt;/code&gt;）をheavy関数内に移動しているのはそのためです。&lt;br /&gt;
　それから、&lt;a href=&quot;https://azu.github.io/promises-book/&quot;&gt;Promise&lt;/a&gt;を使えば敢えて同期をとって実行させることも出来るらしいと聞いたので、何か得るものがあるかと思い少し弄ってみたのですが、setTimeoutを使わずに同様のことが出来るようになるわけでもなさそうだったので使うのをやめました、用途が違うようです。どんなツールを使ってもブラウザ上で動作するシングルスレッド環境には変わりないので、前述のWindowsソフトのような書き方は出来なくて、タイマーによる割り込み処理を避けることはたぶん無理なのでしょう。&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>CoffeeScriptでシリアライズ</title>
   <link href="https://happyclam.github.io/programming/2016-05-02/coffee_serialize"/>
   <updated>2016-05-02T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-05-02/coffee_serialize</id>
   <content type="html">&lt;h3 id=&quot;オブジェクトのシリアライズ機能ってデータだけでいいのか&quot;&gt;オブジェクトのシリアライズ機能ってデータだけでいいのか？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/programming/2015-01-25/ruby_to_js&quot;&gt;以前の記事&lt;/a&gt;でJavaScriptは嫌いだけど、CoffeeScriptは好き（Rubyも好きです）と書きましたが、またJavaScriptが嫌になる出来事に遭遇しました。なんとJavaScriptにはオブジェクトをシリアライズする機能が標準では無いようです。データ交換のためJSONは今までから使っていましたが、JSON形式だとメソッドを復元することが出来ません。自分が知らないだけで探せば何か方法があるのだろうと思っていたのですが、外部のライブラリを使わない限りシリアライズは無理なようです。昔からRubyでもDelphiでもVC++でも使ってたしPHPでも使った記憶があるシリアライズ機能が無いなんて、JavaScriptはオブジェクト指向言語って言えるのか？って感じがしますが、&lt;code&gt;JSON.stringify&lt;/code&gt;でデータのみを文字列化出来るからそれこそがシリアライズ機能であって、なんでメソッドを含めないといけないのだ？という意見もあるようです。確かにメソッドをシリアライズの対象に含めると複数の同じオブジェクトをシリアライズした場合に重複して無駄だという考え方もあるようです。それにJavaScriptの場合はブラウザ上で動作させるので、セキュリティ上の配慮から敢えて標準装備していないのかもしれません。自分としては学術的な議論は置いといて、他の言語で出来るのだから同じようにやらせて欲しいってだけなのですが…。&lt;/p&gt;

&lt;h3 id=&quot;結局データだけ保存してインスタンス生成し直すしかない&quot;&gt;結局データだけ保存して、インスタンス生成し直すしかない？&lt;/h3&gt;
&lt;p&gt;　以前から記事に書いていたRubyで作った三目並べプログラムをCoffeeScript(JavaScript)に移植しようと思ってシリアライズの必要に駆られたのですが、強化学習後の三目並べの全局面分の多分木データをシリアライズしてファイルに保存し、次回再開するときはその学習結果が反映されているファイルを読み込みデシリアライズして対戦を開始できるようにしたいわけです。Rubyなら以下のコードで簡単に実現出来たことです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;class Tree
  def self.read(path)
    begin
      Pathname.new(path).open(&quot;rb&quot;) do |f|
        trees = Marshal.load(f)
      end
    rescue
      p $!
    end
  end

  def self.save(path, obj)
    begin
      Pathname.new(path).open(&quot;wb&quot;) do |f|
        Marshal.dump(obj, f)
      end
    rescue
      p $!
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　学習データを保持したオブジェクトを&lt;code&gt;Marshal.dump&lt;/code&gt;でファイルに保存し、それを&lt;code&gt;Marshal.load&lt;/code&gt;するだけで、復元できます。ファイルから読み込まれたオブジェクトはnewしてインスタンスを生成したオブジェクトと変わりなく機能し、Treeクラスに用意してあるメソッドも呼び出せます。呼び出し側のコードは以下のたった２行です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#保存するとき
Tree::save(&quot;./trees.dump&quot;, @trees)

#読み込むとき
@trees = Tree::read(&quot;./trees.dump&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　でもJavaScriptだと&lt;code&gt;JSON.stringify&lt;/code&gt;でデータを保存することは出来てもメソッドの情報が保存されないので、復元するときには、オブジェクトが保持していたデータを使ってあらためてインスタンスを生成する必要があります。Treeクラスはコンポジットパターンになっていて、一つの局面を保持するTreeオブジェクトが入れ子状になって、枝分かれする局面を保持する形になっているのですが、オブジェクトが内包しているオブジェクトも同様にあらためて生成しなければならないので、全局面分の盤面オブジェクト（Boardオブジェクト）を全部 new していく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;class Tree
    @deserialize: (src) -&amp;gt;
        buf = new Tree(new Board())
        @build(buf, src)
        return buf
    #ファイルから読み取ったデータで初期化しながら、再帰関数を使って多分木データを再形成していく
    @build: (root, src) -&amp;gt;
        for c in src.child
            newroot = new Tree(new Board(c.value), c.score)
            root.child.push(newroot)
            @build(newroot, c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　保存するときは&lt;code&gt;JSON.stringify&lt;/code&gt;でデータだけを文字列化するだけですが、復元するときに面倒な作業が必要になります。Rubyの場合はどんなオブジェクトであろうと&lt;code&gt;Marshal.dump&lt;/code&gt;と&lt;code&gt;Marshal.load&lt;/code&gt;を呼び出せば済むのですが、JavaScriptの場合はオブジェクトの中身によって（クラス定義によって）やることが違ってきて、オブジェクトの中に多くのオブジェクトを抱えているとそれらをすべて文字列データを元に生成し直さないといけないので、Rubyのコードと比較してとても面倒です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;#保存するとき
localStorage.setItem(&quot;SerializedData&quot;, JSON.stringify(@trees))

#読み込むとき
data = localStorage.getItem(&quot;SerializedData&quot;)
try
    src = JSON.parse(data)
catch e
    console.log e
@trees = Tree.deserialize(src)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;問題は復元deserializeunserializeする時&quot;&gt;問題は復元（deserialize,unserialize）する時&lt;/h3&gt;
&lt;p&gt;　初期盤面の局面から多岐にわたる局面を探索アルゴリズムを使って樹状に形成し、そのオブジェクトを一気にファイルに出力したり読み込んだりネットワークに送ったりするためにあるのがシリアライズ（連続化？）なのに、ファイルから読み込んだデータを元にしてあらためて新規ノードを追加しているのでは、手間が掛かり過ぎて（どちらの手番かとか、駒が置けるかどうかなどのロジックは考慮せずに単純にnewしていけばいいだけの単純作業ではありますが…）、全然”serial”じゃありません。だからシリアライズ機能を実現したとは言えないのですが、&lt;br /&gt;
とりあえずこの方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;シリアライズ時はJSON.stringifyで文字列化&lt;/li&gt;
  &lt;li&gt;デシリアライズ時は文字列データを元に内包しているオブジェクトも含めてをあらためて生成し直す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　で、RubyのコードをCoffeeScript（JavaScript）に移植することが出来ました&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
　それと、この方法でオブジェクトを復元する時は、コンストラクタでやっている初期化処理を出来るだけ軽くするために、ファイルから読み込んだデータで一気に初期化出来るような作りになるよう気をつける必要があるでしょう。今回そのためにRuby製とは違ったconstructorの作りに変更する必要が生じました。まぁこれはやっておいて損のない作業ではありますが、それもこれもJavaScriptにシリアライズ機能がないために生じた作業です。&lt;br /&gt;
　RubyのプログラムをJavaScriptに移植する作業はCoffeeScriptがその違いを吸収してくれるのでほとんど一対一でコードを置き換えるだけで済むのですが、言語の違いよりもPC上で動いているソフトをブラウザ上で動かすソフトに置き換えるという違いの影響が大きいので制約がいろいろ出てきます。今回のこともブラウザのセキュリティ上の配慮が影響しているのであれば、言語仕様の違いというより、そちらに含めるべきものかもしれません。他にも面倒な違いがあるので、また近いうちに記事を書こうと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;他にもブラウザ上のデータベース（IndexedDB）を使ってデータを格納する方法も試したのですが、全然速くならなかったので止めました。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Withings Activitéの電池のもち</title>
   <link href="https://happyclam.github.io/hardware/2016-04-25/activite_batt"/>
   <updated>2016-04-25T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/hardware/2016-04-25/activite_batt</id>
   <content type="html">&lt;h3 id=&quot;検索ワードトップに-withings-が&quot;&gt;検索ワードトップに withings が&lt;/h3&gt;
&lt;p&gt;　Google Analyticsを見ていると最近このサイトに辿り着く検索ワードに「withings」が目立つようになってきました。以前は「αβ法」や「rails」等のプログラミング関連のキーワードでこのサイトに訪れる人が多かったのですが、やはりプログラミングする人よりしない人の方が圧倒的に多いのだから一見さんは特にそうなるのでしょう。もともと訪問者が少ない弱小零細ブログですが、そういえばMacbookが発売された時にその記事を書いたら一時的に訪問者が増えたことからも、プログラミングの話題なんかより、関わる人の絶対数が多い言葉の方が人が集まり易いのは当然でしょう。Withingsの製品が別段ブームになっているとは思えませんが、情報を求めている人もいるみたいなので気づいたことを記事にしておきます。&lt;/p&gt;

&lt;h3 id=&quot;電池自体は７ヶ月もった&quot;&gt;電池自体は７ヶ月もった&lt;/h3&gt;
&lt;p&gt;　去年の８月から使い始めて約５ヶ月後の今年の１月ぐらいにサイレントアラームが動かなくなりました。特にサイレントアラームが絶対必要というわけではなかったのでそのまま使用し続けて様子を見ていたのですが、先日ようやく電池が切れました。電池残量が少ないとサイレントアラームが機能しないようになっているのでしょう。多分そうだろうと思いながらも一度電池がなくなるまで使い続けてみようと思いながら使っていたのですが、アラームが動かなくなってからは時間も遅れ気味になって２、３日に一回ぐらいのペースで時刻合わせする羽目になっていたので、今度からはアラームが動かなくなるタイミングで電池交換しようと思っています。&lt;br /&gt;
　今まで、電池が少ないからアラームが動かないのか、壊れたから動かなくなったのか、はっきりしない状態でドキドキ感を多少楽しみながら放置していたわけですが、壊れてなくてよかったです&lt;img class=&quot;emoji&quot; title=&quot;grin&quot; alt=&quot;grin&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/grin.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;サイレントアラームの止め方&quot;&gt;サイレントアラームの止め方&lt;/h3&gt;
&lt;p&gt;　これは&lt;a href=&quot;/project/2015-09-19/activite#withings-activit&quot;&gt;以前の記事&lt;/a&gt;にも書いたのですが、未だに気づいていない人が多いと思います。いろんなサイトに出来ないと書いてあるので試してみようと思わない人も多いと思います。以前記事を書いた時と違って今はサイレントアラームを止めるコツを掴みました。ブルブルが止まった瞬間に&lt;strong&gt;「カッカッカッ」という感じで本体右上辺りをつめ先で３回叩く&lt;/strong&gt;というものです。多分２回でもいいと思う（実際２回で止まることもあります）のですが本体のアラームが稼働している時（ブルブルしている時）はタップされたことが認識できないと思うので、念のために１回余計にタップしています。タイミングが大事なので失敗することもあるのですが、昔と違って今はだいたい３回目ぐらいのブルブルが来るまでには止めることが出来るようになりました。でもサイレントアラームは止めることが出来ないと書いてあるブログは見つけることはあるのですが、未だに止めることが出来ると書いてあるブログ等を見かけないので、&lt;a href=&quot;/project/2015-09-19/activite#withings-activit&quot;&gt;以前の記事&lt;/a&gt;に書いたように私の持っている個体が特別（故障している）なのかもしれません&lt;img class=&quot;emoji&quot; title=&quot;question&quot; alt=&quot;question&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/question.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;浸水防止の輪ゴム&quot;&gt;浸水防止の輪ゴム&lt;/h3&gt;
&lt;p&gt;　電池交換しようと思い裏蓋を開けたらポロッと輪ゴムが落ちました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/activite_band.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/activite_band.png&quot; alt=&quot;Withings Activitéの輪ゴム&quot; title=&quot;Withings Activité内部の輪ゴム&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　浸水防止用の輪ゴムのようですが、ゴムが伸びきってしまってヨレヨレになって落ちたようです。せっかく蓋を開けたのだから、ゴムを新しいのに替えたかったのですが、非常に細いので普通の輪ゴムでは代用が効かないようです。試しにもっと小さな輪ゴムを引き伸ばして枠に嵌めてみたのですが、いくら引き伸ばしたといっても体積が大きいので蓋を閉めようとするとゴムがハミ出すような感じになって蓋を閉めることが出来ませんでした。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/activite_mini.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/activite_mini.png&quot; alt=&quot;Withings Activitéの輪ゴムの代用品？&quot; title=&quot;Withings Activitéの輪ゴムの代用品？&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　聞くところによるとビーズ用のゴムなら細いのが色々あるらしいのですが、輪ゴム上にはなっていない（ビーズを通すから当たり前）ので諦めました（ビーズ用のゴムの両端を縛って輪ゴムにして使ってみようかとも思いましたが、出っ張りが出来てかえって浸水し易くなるような気がします）。仕方なくヨレヨレのゴムをそのまま使って蓋を閉めましたが、代用になる輪ゴムはどこかで手に入らないものでしょうかねぇ&lt;img class=&quot;emoji&quot; title=&quot;persevere&quot; alt=&quot;persevere&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/persevere.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>電子書籍出版して２週間経ちました</title>
   <link href="https://happyclam.github.io/miscellaneous/2016-04-02/self-publishing"/>
   <updated>2016-04-02T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/miscellaneous/2016-04-02/self-publishing</id>
   <content type="html">&lt;h3 id=&quot;html5coffeescriptで作る-最強の三目並べプログラムamazon楽天&quot;&gt;「HTML5+CoffeeScriptで作る 最強の三目並べプログラム」（&lt;a href=&quot;https://www.amazon.co.jp/dp/B01D1IJ0S0&quot;&gt;Amazon&lt;/a&gt;、&lt;a href=&quot;https://books.rakuten.co.jp/rk/8353a2085f33386d8fe9102c7b8eb4c3&quot;&gt;楽天&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;　個人出版してみた結果売れ行きはどうなのか、興味ある人いると思います。私自身も試しに出版してみたらどうなるだろうという好奇心で出版したようなものです。現在約２週間経ちましたが楽天で２冊、Amazonで１冊です。買っていただいた方ありがとうございました。&lt;img class=&quot;emoji&quot; title=&quot;bow&quot; alt=&quot;bow&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/bow.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　最初Amazonに出版して三日経っても反応無かったので楽天に出版したのですが、楽天に出してすぐに１部売れました。登録してすぐに売れたものですから、KWLの中の人が作者を励ます為に買ってくれたのか？もしかして知り合い？とかいろいろ想像してしまいました。一応匿名で出しているつもりですが、どこで身元がバレているかわかりませんから。それにしても全く宣伝せずに２週間で３部も売れたというのは自分では上出来だと思っていますが、新着ということで目にする機会があっただけで、このまま放っておいたら今後一切売れないような気もします。Twitterを使った販促や他のサイトでの販売もその効果に興味があるのでやってみるかもしれませんが、売れたかどうかより、買って読んでくれた人がどう思っているかの方が大事だと思っています。&lt;br /&gt;
　でも、自費出版というのは昔からそういうものだと思うのですが、売れるかどうかなんてことより（もちろん売れたら嬉しいですが）自分が世に出したいから出すわけです。だからもっと言えば買って読んでくれた人がどう思ってようがそれさえも大きな関心はないという感じです。そういうわけですから出版し終えたばかりなのに、早速次の本を出す構想を練っています。なんか使命感に駆られるという感じです、たとえ誰も待ち望んでいなくても&lt;img class=&quot;emoji&quot; title=&quot;sweat_smile&quot; alt=&quot;sweat_smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/sweat_smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;epubの作成方法&quot;&gt;epubの作成方法&lt;/h3&gt;
&lt;p&gt;　以前にも&lt;a href=&quot;/miscellaneous/2015-06-09/pandoc_epub&quot;&gt;電子出版に関して&lt;/a&gt;記事を書きましたが、そこではこのブログを書いているやり方と同じmarkdown形式で文章を書いてそれを何らかの方法でPDFかepubに変換して出版したいと書きました。でも、最新のpandocコマンド（1.16.0.2）で試してみても細々な不満があったのでmarkdownからepubを生成するのは諦めて、使い方を覚えるのは面倒臭くて嫌だったのですが結局MacのPagesを使って一から書くことにしました。本を書くということに不慣れなこともあって、文章だけでなく何度も構成や図表を変更するので、そういう細々とした作業は市販のソフトを使った方が楽になると感じました。&lt;a href=&quot;/miscellaneous/2015-06-09/pandoc_epub&quot;&gt;以前の記事&lt;/a&gt;に書いたような自前でepubを作るやり方はもうこれで絶対変更しないと言い切れるぐらい文章が確定してからでないとやってられないと思います。でもそうは言ってもepubに変換してから修正したくなることが多いのですが、Pagesなら出力形式をepubに指定すれば何度でも出力できるので、ちょっと修正してはまたepubに出力するという作業が非常に楽でした。ブログ書いている分にはmarkdownの方が楽なんですけど、結局その違いは、最終出力をすぐに確認出来る状態で入力作業を進められるかどうかが大事なことだということでしょう。&lt;/p&gt;

&lt;h3 id=&quot;ゴールドラッシュにはスコップを売るべし&quot;&gt;「ゴールドラッシュにはスコップを売るべし」&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/miscellaneous/2015-06-09/pandoc_epub&quot;&gt;以前の記事&lt;/a&gt;にも書きましたが最初はどこに出版するのかいろいろ迷っていたので、個人出版のノウハウ本みたいな電子書籍も何冊か買ってみましたが、役に立ったと思ったのは、この１冊（&lt;a href=&quot;https://selfpublishing.jimdo.com&quot;&gt;「電子書籍の個人作家でも、３年かければ１０００冊売れる！　セルフパブリッシングを楽しむ方法」&lt;/a&gt;）だけでした。それ以外は買って損したと思うものばかり（こんなこと言うと自分に返ってくるものですが、言わずにはいられないほど酷いものがあるんです。タイトルは伏せておきますので許して下さい）でした。今となっては特にこの本を他人にお勧めしようとは思いませんが、この本のタイトルにあるように３年で１０００冊売れたそうで、宣伝費用をかけずにこれだけ売れるのは凄いことだろうなとは思います。本を売ることが目的ならこういう類の本を書くのが一番手っ取り早いような気がします。私もそうでしたが、やっぱりみんな実際にやってみた人の体験談を知りたいんだと思います。今、ゴールドラッシュと言えるほど個人出版が流行っているのかどうか知りませんが、昔に較べて気軽に出版出来るので増えていくことは間違いないと思います。ゴールドラッシュでは自分で金鉱を見つけ出すより、そういう夢を見ている人達を相手にスコップやデニムを売った方が確実にお金になるでしょう。だから今のところ考えていませんが、私も将来体験談をまとめてノウハウ本を出すかもしれません。その時は「使命感に駆られて」とか言っていたくせに小遣い稼ぎに走ったぞと私を罵倒してください。&lt;img class=&quot;emoji&quot; title=&quot;grin&quot; alt=&quot;grin&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/grin.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>楽天Kobo電子書籍検索API使ってみた</title>
   <link href="https://happyclam.github.io/project/2016-03-30/koboAPI"/>
   <updated>2016-03-30T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2016-03-30/koboAPI</id>
   <content type="html">&lt;p&gt;Project: 「&lt;a href=&quot;https://kwl-books.herokuapp.com&quot;&gt;&lt;strong&gt;楽天Kobo電子書籍新着チェッカー&lt;/strong&gt;&lt;/a&gt;」: &lt;a href=&quot;https://github.com/happyclam/kwl-books&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;自分の本が検索されない&quot;&gt;自分の本が検索されない&lt;/h3&gt;
&lt;p&gt;　以前からやってみたかった電子書籍出版やってみました（&lt;a href=&quot;https://www.amazon.co.jp/dp/B01D1IJ0S0&quot;&gt;Amazon KDP&lt;/a&gt;、&lt;a href=&quot;https://books.rakuten.co.jp/rk/8353a2085f33386d8fe9102c7b8eb4c3&quot;&gt;楽天Kobo&lt;/a&gt;）。その顛末については別の記事を書こうと思っていますが、先に「楽天Kobo電子書籍新着チェッカー」を作ってみたのでそれについて書きます。&lt;br /&gt;
　楽天Koboの電子書籍出版サービス（KWL、Kobo Writing Life）に自分の本を登録して、リリースまで時間が掛かると書いてあったから&lt;a href=&quot;https://wakufactory.jp/kobo/kwlnew.html&quot;&gt;「KoboWritingLife新着チェッカー」&lt;/a&gt;というサイトを見つけて、自分の本が出版されたかどうかチェックしていました。丸一日ぐらい経った後、まだ自分の本が表示されていなかったので、試しに楽天のサイトから検索してみたら、自分の本がヒットするではないですか、「なんで自分の本は出てこないの？」って感じです。この&lt;a href=&quot;https://wakufactory.jp/kobo/kwlnew.html&quot;&gt;新着チェッカー&lt;/a&gt;がどれほど利用されているのかわかりませんが、「自分の本を表示してくれないサイトが新着チェッカーとしてメジャーになってもらっては困る」、「なんとか自分で世間の人に使って貰えるこれ以上の新着チェッカーを作らなければならない」という使命感に駆られて（嘘です）作ってみることにしました。&lt;br /&gt;
　自分で楽天APIを弄ってみてから想像するとおそらく自分の本が表示されないのは、自分の本を登録している「PC・システム開発」というジャンルが検索対象になっていないからだと思いますが、真相はわかりません。自分の本だけ意地悪されているわけでないことは確かでしょう。&lt;br /&gt;
　ということでジャンル別に検索する形で作りました。自己責任でご利用ください（免責条項）。&lt;a href=&quot;https://webservice.rakuten.co.jp/guide/&quot;&gt;楽天のサイト&lt;/a&gt;でも簡単にAPIを試してみることも出来ます。試すだけなら開発者用のIDをわざわざ取得しなくても利用できます。&lt;/p&gt;

&lt;h3 id=&quot;やっていること仕様&quot;&gt;やっていること（仕様）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用するのは楽天Kobo系APIだけ（「楽天ブックス系API」と「楽天Kobo系API」に分かれているようです）&lt;br /&gt;
※深くは追求してませんが、&lt;a href=&quot;https://wakufactory.jp/kobo/kwlnew.html&quot;&gt;件のサイト&lt;/a&gt;で自分の本が検索出来なかったのはこのAPIの違いによるものかもしれません。APIを分けている理由も知りませんが、Kobo系は簡易版みたいな感じかもしれません。&lt;/li&gt;
  &lt;li&gt;予約販売分は検索対象外（予約販売分を含めると未来の発売日分のデータばかりになるため）&lt;/li&gt;
  &lt;li&gt;サイトにアクセスがあると、その都度最新のジャンルデータを取得して表示し差分を保存する&lt;/li&gt;
  &lt;li&gt;ジャンルがクリックされると、一度のAPIで取得出来る最大３０件の最新出版データを保存して日付の新しい順に過去に取得した分を含めて最大５０件表示&lt;br /&gt;
※最初は先頭３桁が”123”のもの（KWLの分だけ）に限定しようと思ったのですがデータが少なくてあまりにも寂しい検索結果になるので他のものも表示することにしました。&lt;/li&gt;
  &lt;li&gt;発売日から３０日経過を目処に古い新着データは削除していく（ジャンルデータ取得時に日付をチェックして削除）。&lt;br /&gt;
※herokuの無料枠で運用しているのでデータが大量に溜まると困ると思ってこうしています。更新頻度が高いジャンルは３０日経過していなくても表示されなくなります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用しているapi&quot;&gt;使用しているAPI&lt;/h3&gt;
&lt;p&gt;　発行しているAPIは以下の二種類だけです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;楽天Koboジャンル検索APIで電子書籍のジャンル一覧を取得&lt;br /&gt;
　例、koboGenreId=101、101は電子書籍&lt;br /&gt;
HTTPS https://app.rakuten.co.jp/services/api/Kobo/GenreSearch/20131010?applicationId=XXXXXXXXXXXXXXXXXXX&amp;amp;format=json&amp;amp;koboGenreId=101&lt;/li&gt;
  &lt;li&gt;楽天Kobo電子書籍検索APIでジャンル別の新着データを取得&lt;br /&gt;
　例、salesType=0は予約販売でない、koboGenreId=101912は「PC・システム開発」&lt;br /&gt;
HTTPS https://app.rakuten.co.jp/services/api/Kobo/EbookSearch/20140811?applicationId=XXXXXXXXXXXXXXXXXXX&amp;amp;format=json&amp;amp;koboGenreId=101912&amp;amp;salesType=0&amp;amp;sort=-releaseDate&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/kwlchecker.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/kwlchecker.png&quot; alt=&quot;kwl-checker&quot; title=&quot;KWL新着チェッカー&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;er図&quot;&gt;ER図&lt;/h3&gt;
&lt;object data=&quot;/pdf/koboapi.pdf&quot; width=&quot;760&quot; height=&quot;900&quot;&gt;
&lt;p&gt;ご覧の環境では、object要素がサポートされていないようです。&lt;a href=&quot;/pdf/koboapi.pdf&quot;&gt;PDFファイルをダウンロードしてください&lt;/a&gt;&lt;/p&gt;
&lt;/object&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>モバイルプリンター PX-S05B</title>
   <link href="https://happyclam.github.io/hardware/2016-03-21/pr_epson"/>
   <updated>2016-03-21T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/hardware/2016-03-21/pr_epson</id>
   <content type="html">&lt;h3 id=&quot;またプリンターを買ってしまった&quot;&gt;またプリンターを買ってしまった&lt;/h3&gt;
&lt;p&gt;　去年プリンターを処分してから、もうプリンターはコンビニで済まして自分で持たないつもりだったけど、確定申告にも使うし出力結果をすぐに確認したい時が多いのでやっぱり持つことにしました。でも狭い家の床をプリンターに占有されるのは嫌だったので、買ったのはエプソンのモバイルプリンター &lt;a href=&quot;https://ink-revolution.com/contentsplus/epson-px-s05w-px-s05b-mobile-purinter/&quot;&gt;PX-S05B&lt;/a&gt;です。外で印刷する予定はないし、事前に機種等を調べずに半ば衝動買いに近い感じで買ったのですが、本棚に収納出来るので気に入りました。&lt;/p&gt;

&lt;h3 id=&quot;macアドレス&quot;&gt;MACアドレス&lt;/h3&gt;
&lt;p&gt;　自宅ルーターのMACアドレスフィルタリング設定をするためにプリンターのMACアドレスはどうやれば知ることが出来るんだ？とプリンターのメニューを弄っているうちにネットワーク接続エラーで「エラー情報を印刷しますか？」みたいな表示が出てOKを選択したら以下のように欲しかった情報が印刷されました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/epson_setting.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/epson_setting.png&quot; alt=&quot;ネットワーク診断レポート&quot; title=&quot;ネットワーク診断レポート&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　エプソンの製品を使ったことがなかったので「またMACアドレスの記載が無いのかよ」と勝手に決めつけて&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;作業していたのですが、後から気づいたのですが外箱にちゃんとMACアドレスが記載されていました&lt;img class=&quot;emoji&quot; title=&quot;cold_sweat&quot; alt=&quot;cold_sweat&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/cold_sweat.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　さすがエプソンさんは物を売ってるだけの業者じゃなくてメーカーだから、抜かりは無いですね&lt;img class=&quot;emoji&quot; title=&quot;smile&quot; alt=&quot;smile&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/smile.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;廃インク吸収体&quot;&gt;廃インク吸収体&lt;/h3&gt;
&lt;p&gt;　このプリンターの売りの一つがエプソンがメンテナンスボックスと呼んでる廃インク吸収体という消耗品を自分で交換できる点だそうです。今まで廃インク吸収体がいっぱいになるとメーカーに送る必要があったのに、この機種は自分で交換可能だということです。この廃インク吸収体というのはインクジェットプリンターには必ずあるらしいのですが、私は長年インクジェットプリンターを使ってきたのにその存在を知りませんでしたし、メーカーに送った経験もありません。それは今までプライベートではブラザー製のインクジェットしか購入したことがなく、それらしきエラーに見舞われたことはあったのですが、ブラザーの場合ネットで検索すれば今でも見つかりますが、廃インク吸収体の交換時期を示すカウンターを自分でリセットする方法があって、リセットしながらそのまま使い続けることが出来たからです。私がプリンターを使う頻度がそれほど多くなかったのでこのやり方でやっていけたのだと思いますが、こんな私にとって廃インク吸収体を自分で交換出来るなんて言われても全然メリットに感じません。ヨドバシの定員に廃インク吸収体の説明を受けながら、あの時のプリンターのエラーはそういうことだったのかと昔の経験を思い出しながら、ブラザーってオープンというか緩いというか改めてブラザーという会社が好きになったのでした。それとともにブラザー製のインクジェットが全てそうなのかどうか知りませんが、自分以外の普通の人は廃インク吸収体がいっぱいになる度にメーカーに送ってお金も取られる使い方をしていたのかと思うとなんか得した気分になりました。それにカウンターをリセットするだけで特に不都合なく使用できるのならそもそも廃インク吸収体の交換自体が必須というわけでもなさそうですが、プリンター業界の闇に関しては詳しく知らないのでこれ以上は言及しないことにします。&lt;br /&gt;
　ヨドバシの定員に廃インク吸収体の話を聞いてから、ブラザー製で似たような機種があるならそっちの方がいいなと思いながらも、無いようだったのでこの機種を買って帰ったのですが、後からこの機種に関して&lt;a href=&quot;https://www.amazon.co.jp/gp/customer-reviews/R15E5KAC5D77GH/ref=cm_cr_arp_d_rvw_ttl?ie=UTF8&amp;amp;ASIN=B00L9X1T02&quot;&gt;Amazonのレビュー&lt;/a&gt;を読んでみると「廃インク吸収体を自分で交換出来る」という謳い文句自体も鵜呑みにしてはいけないようです。&lt;a href=&quot;https://www.amazon.co.jp/gp/customer-reviews/R15E5KAC5D77GH/ref=cm_cr_arp_d_rvw_ttl?ie=UTF8&amp;amp;ASIN=B00L9X1T02&quot;&gt;このレビュー&lt;/a&gt;の真偽はわかりませんが、とりあえず偶にしか使用しない自分の使い方なら大きな不満が出ることは無いかなという感じです。&lt;/p&gt;

&lt;h3 id=&quot;wi-fi-direct&quot;&gt;Wi-Fi Direct&lt;/h3&gt;
&lt;p&gt;　「ノートPCとモバイルプリンターをWi-Fi環境で使用していて、スマートデバイスからプリントしたい時に、同じネットワークに入れずにWi-Fi Directでプリントできます。」ということです。スマホで撮った写真をWi-Fi Directで印刷してみましたが、自宅無線LAN環境からWi-Fi Directにプリンタ側で切り替えて簡単に印刷出来ました。これは便利なので、必要なくても出先で使ってみたくなります。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/epson_direct.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/epson_direct.png&quot; alt=&quot;Wi-Fi Direct&quot; title=&quot;Wi-Fi Direct&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/hardware/2015-06-12/kobo_aura&quot;&gt;楽天kobo auraを購入&lt;/a&gt;した時は記載がなくて困りました。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Cordova のアップデート</title>
   <link href="https://happyclam.github.io/programming/2016-02-14/cordova_update"/>
   <updated>2016-02-14T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-02-14/cordova_update</id>
   <content type="html">&lt;h3 id=&quot;google-play-からのお達し&quot;&gt;Google Play からのお達し&lt;/h3&gt;
&lt;p&gt;　２／９に「Google Play warning: You are using a vulnerable version of Apache Cordova」というタイトルでGoogleからメールが来ました。バージョン4.1.1以前のApacheCordovaにセキュリティ上の脆弱性が見つかったので、公開している&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;Cordova製のアプリ&lt;/a&gt;を更新しろという内容です。&lt;br /&gt;
&lt;strong&gt;Please migrate your app(s) to Apache Cordova v.4.1.1 or higher as soon as possible and increment the version number of the upgraded APK.&lt;/strong&gt;&lt;br /&gt;
と書いてあり、更新しなければ2016年5月9日以降は公開を停止するとも書いてありました。備忘録のつもりで作業内容を記事に残しておきます。&lt;br /&gt;
　それにしても、メールのタイトルをGoogleやTwitterで検索してもほとんどヒットしなかったのでCordova(PhoneGap)製のアプリって少ないんでしょうねぇ。それとも皆さんマメに更新しているからこんなメール来ないってことでしょうか？&lt;/p&gt;

&lt;h3 id=&quot;cordova開発環境の更新&quot;&gt;Cordova開発環境の更新&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ cordova platform ls
Installed platforms: android 3.7.1, ios 3.8.0
Available platforms: amazon-fireos, blackberry10, browser, firefoxos, osx, webos
$ cordova -v
6.0.0

$ cordova platform update android
Updating android project...
Android project updated with cordova-android@5.1.0
$ cordova platform ls
Installed platforms: android 5.1.0, ios 3.8.0
Available platforms: amazon-fireos, blackberry10, browser, firefoxos, osx, webos
$ cordova platform update ios
Updating ios project...
iOS project updated with cordova-ios@4.0.1
$ cordova platform ls
Installed platforms: android 5.1.0, ios 4.0.1
Available platforms: amazon-fireos, blackberry10, browser, firefoxos, osx, webos
$ cordova -v
6.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　android 3.7.1から5.1.0に無事更新されました。配布するビルドパッケージを作成する前に、cordovaが生成するファイルもいろいろ変わっているだろうと思ってプロジェクトを新規に作ることにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#使用しているプラグイン一覧をconfig.xmlに出力
$cordova plugin save
$cordova plugin list
android.support.v4 1.0.0 &quot;Android Support v4&quot;
com.admob.google 2.0.14 &quot;AdMob Google Ads + Tappx&quot;
com.connectivity.monitor 1.1.0 &quot;Connectivity Monitoring&quot;
com.google.play.services 22.0.0 &quot;Google Play Services for Android&quot;
com.ios.libgoogleadmobads 1.1.1 &quot;iOS Google AdMob Ads library&quot;
org.apache.cordova.device 0.3.0 &quot;Device&quot;
org.apache.cordova.dialogs 0.3.0 &quot;Notification&quot;

#プロジェクトの新規作成
$cordova create Tictactoe com.herokuapp.tictactoe_cf Tictactoe -d
$cd Tictactoe
$cordova platform add android
$cordova platform add ios
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　予めファイルに出力したプラグインを&lt;code&gt;cordova plugin add&lt;/code&gt;コマンドで順番にインストール。プラグインの名前は&lt;code&gt;cordova plugin search&lt;/code&gt;で確認出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cordova plugin list
cordova-android-support-v4 4.0.0 &quot;Android Support v4&quot;
cordova-admob 4.1.6 &quot;AdMob Google Ads + Tappx&quot;
cordova-connectivity-monitor 1.2.2 &quot;Connectivity Monitoring&quot;
cordova-google-play-services 25.0.0 &quot;Google Play Services for Android&quot;
cordova-libgoogleadmobads 7.3.1 &quot;iOS Google AdMob Ads library&quot;
cordova-plugin-device 1.1.1 &quot;Device&quot;
cordova-plugin-dialogs 1.2.0 &quot;Notification&quot;
cordova-plugin-whitelist 1.2.1 &quot;Whitelist&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　cordova-plugin-whitelistプラグインが勝手に追加されていました、デフォルトで組み込まれる？ようです。こういう知らないうちに変わっていることがあるので、新規プロジェクトで作り直す方がいいと思います。&lt;/p&gt;

&lt;h3 id=&quot;パッケージファイルapkを更新&quot;&gt;パッケージファイル（APK）を更新&lt;/h3&gt;
&lt;p&gt;　開発環境の更新はできたのであとはビルドするだけですが、その前にAndroidManifest.xml内のバージョンNo.（android:versionCodeとandroid:versionName）をインクリメントしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cd platforms/android/
$ant release
Buildfile: build.xml does not exist!
Build failed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　今まで&lt;code&gt;ant release&lt;/code&gt;コマンドでビルドしていたのですが、バージョンアップで変更になったのか、エラーになりました。&lt;br /&gt;
　エラーメッセージはbuild.xmlが無いと言ってるだけなので、旧プロジェクトからbuild.xmlを持って来れば出来そうですが、新しいやり方に従って以下のようにビルド&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cordova build android --release
Built the following apk(s): 
	/Users/xxxx/workspace/Tictactoe45/platforms/android/build/outputs/apk/android-release-unsigned.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　私はその気はありませんが、GUI環境に移行すればもっと分かりやすいメニューがあるのかもしれません。&lt;br /&gt;
　その後、私有鍵は以前作成したものを使い、デジタル署名も以前のバージョンと同様に出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$jarsigner -verbose -sigalg MD5withRSA -digestalg SHA1 -keystore ~/mine/myAndroidKey.keystore ./platforms/android/build/outputs/apk/android-release-unsigned.apk myAndroidKeyAlias
$mkdir -p Release/android
$~/Library/Android/sdk/build-tools/23.0.1/zipalign -v 4 ./platforms/android/build/outputs/apk/android-release-unsigned.apk ./Release/android/Tictactoe-release1-3-2.apk
$adb install -r ./Release/android/Tictactoe-release1-3-2.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　実機での動作確認が済めば、&lt;a href=&quot;https://play.google.com/apps/publish/?hl=JA&quot;&gt;Google Play Developer Console&lt;/a&gt;からアップロードして完了です。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/screenshot_googleplay.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/screenshot_googleplay.png&quot; alt=&quot;GooglePlayAPK画面&quot; title=&quot;Google Play APK画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　↑バージョン（android:versionCode）が６桁の数字（103028）になってしまっていますが、なぜか私の環境からGooglePlayのサイトにパッケージファイルをアップロードするとAndroidManifest.xmlに記載した数値（10302）に一桁追加されてしまうのです。以前のものより数値が小さいとアップロード出来ないらしいので、１桁でいいはずの数字なのに今は６桁になってしまっています。う〜ん不思議だ&lt;img class=&quot;emoji&quot; title=&quot;confused&quot; alt=&quot;confused&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/confused.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>herokuのNode.jsプロジェクトでエラー</title>
   <link href="https://happyclam.github.io/programming/2016-02-01/node_express"/>
   <updated>2016-02-01T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2016-02-01/node_express</id>
   <content type="html">&lt;h3 id=&quot;久々にプロジェクトに変更を加えてherokuにアップしたらエラーに見舞われた&quot;&gt;久々にプロジェクトに変更を加えてherokuにアップしたらエラーに見舞われた&lt;/h3&gt;
&lt;p&gt;　以前&lt;a href=&quot;/programming/2015-04-25/mongo_upsert&quot;&gt;記事&lt;/a&gt;にも書きましたが、公開した&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;androidアプリ&lt;/a&gt;の&lt;a href=&quot;https://tictactoe-cf.herokuapp.com/&quot;&gt;ランキング表示用のサイト&lt;/a&gt;で使用しているGoogle AnalyticsのトラッキングIDが間違えていたので&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;、トラッキングID（UA-XXXXXXXX-X）だけ書き換えて heroku にアップロードしたらエラーが出てランキング表示機能が使えなくなりました。全然プログラムコードと関係ない文字列を書き換えただけなのにです。&lt;br /&gt;
　Node.jsは最近はほとんど触ってなかったので何をどうすればいいのかすっかり忘れていたため復旧に手間取ったので顛末を記事にしておきます。本来はプロジェクト全体を網羅したドキュメントを残すべきでしょうけど…。&lt;/p&gt;

&lt;h3 id=&quot;原因不明&quot;&gt;原因不明？&lt;/h3&gt;
&lt;p&gt;　herokuのログには&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error: Most middleware (like errorHandler) is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出ていました。この時点ではよくわからなかったのですが、どうやらheroku上で実行モジュールをビルドする際に、何か仕様が変更されたパッケージを組み込んだためにエラーが発生したようです。とりあえずメッセージに沿って作業しました。&lt;/p&gt;

&lt;h3 id=&quot;エラーの対処&quot;&gt;エラーの対処&lt;/h3&gt;

&lt;p&gt;指定されたリンク先に書いてある通りapp.jsを書き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//app.js変更前
if ('production' == app.get('env')) {
    app.use(express.errorHandler());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//app.js変更後
var errorhandler = require('errorhandler');

if ('production' == app.get('env')) {
    app.use(errorhandler());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　herokuにpushした後、自分のスマホからアクセスしてみるとまだランキングが表示されません。herokuのログは以下です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error: Cannot find module 'errorhandler'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　そこで、まずローカル環境で動作させようとして&lt;code&gt;node app.js&lt;/code&gt;とコマンドを打つと今度は以下のエラー&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error: Cannot find module 'express'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　よくあることですが、どんどん解決すべき問題がスタックに積み上げられて増えていきます。&lt;br /&gt;
Googleで検索したところ、上記エラーは&lt;code&gt;npm link express&lt;/code&gt;と打つことで解決しました。&lt;br /&gt;
　で、再度&lt;code&gt;node app.js&lt;/code&gt;と打つと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error: Cannot find module 'errorhandler'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　目出度くherokuと同じエラーがローカル環境で再現しました。そして&lt;code&gt;npm install errorhandler&lt;/code&gt;を実行した後、再度&lt;code&gt;node app&lt;/code&gt;を実行すると無事にNodeが起動しました。でもこれをheroku上で実現するのはどうするのか？と一瞬考えた後、package.jsonというファイルで管理していたことを思い出し、以下のように一行書き加えました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
//変更前
  , &quot;dependencies&quot;: {
      &quot;express&quot;: &quot;4.12.1&quot;
    , &quot;jade&quot;: &quot;&amp;gt;= 0.0.1&quot;
    , &quot;less-middleware&quot;: &quot;*&quot;
    , &quot;mongodb&quot;: &quot;2.0.27&quot;
  },
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
//変更後
  , &quot;dependencies&quot;: {
      &quot;express&quot;: &quot;4.12.1&quot;
    , &quot;jade&quot;: &quot;&amp;gt;= 0.0.1&quot;
    , &quot;less-middleware&quot;: &quot;*&quot;
    , &quot;mongodb&quot;: &quot;2.0.27&quot;
    , &quot;errorhandler&quot;: &quot;&amp;gt;=1.4.3&quot;
  },
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　これをherokuにpushしたところ無事にランキング表示機能が動作しました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/screenshot_unbeaten.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/screenshot_unbeaten.png&quot; alt=&quot;ランキング表示画面&quot; title=&quot;三目並べ「無敗」ランキング表示画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;エラーの原因&quot;&gt;エラーの原因&lt;/h3&gt;
&lt;p&gt;　それにしてもソースファイルの文字列リテラルを書き換えただけでなぜ動かなくなったのか？使用するパッケージのバージョンは〜以上と指定していることが多いので、それが影響したのかと思っていたのですが、Expressのバージョンは&lt;code&gt;&quot;express&quot;: &quot;4.12.1&quot;&lt;/code&gt;となっており、リビジョン番号まで指定されています。&lt;br /&gt;
　どうやら.gitignoreファイルが以下のようになっていて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#.gitignore変更前
*.log
node_modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　node_modulesディレクトリ以下のファイルがgitの管理下に入っていたのがよくなかったようです。’node_module’行の最後にスラッシュが無いので、gitにディレクトリと判断されずnode_modulesディレクトリ以下のファイルがいつの間にか勝手に差し替えられてしまったようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#.gitignore変更後
*.log
node_modules/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　以下のようにnode_modules以下のファイルをインデックスから削除してようやく作業完了です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rm -r --cached node_modules
git commit -av
git push origin
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;androidアプリのAdMobとGoogle Adsenseを別々のgmailアドレスで利用しようとしたらエラーに見舞われて、それ以来ずっと放ったらかしにしていたのでした。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Flotライブラリで拡大表示可能なグラフ作成</title>
   <link href="https://happyclam.github.io/software/2016-01-17/flot_library"/>
   <updated>2016-01-17T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2016-01-17/flot_library</id>
   <content type="html">&lt;h3 id=&quot;ブログgithub-pagesでグラフ描画flot&quot;&gt;ブログ（&lt;a href=&quot;https://jekyllrb-ja.github.io/docs/github-pages/&quot;&gt;Github Pages&lt;/a&gt;）でグラフ描画（&lt;a href=&quot;https://www.flotcharts.org&quot;&gt;Flot&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;　以前&lt;a href=&quot;/programming/2014-10-27/my-posi-chart/&quot;&gt;lazy-high-chartの記事&lt;/a&gt;を書いたことがありましたが、RailsのようなWebアプリではなくこのブログ（Jekyllで生成）のような静的サイトでグラフを描画する必要性を感じた経験はなかったのですが、&lt;a href=&quot;/software/2016-01-16/flotr2/&quot;&gt;前回の記事&lt;/a&gt;のようなグラフばかりのページを作る時は便利だと実感しました。LibreやExcelにデータを貼り付けてグラフ化してそれを画像ファイルに変換してページに貼り付けるより手間が省けます。それだけじゃなくインタラクティブなグラフにすることでより情報を伝えやすくなるというのが今回のお話です。&lt;br /&gt;
　前回は&lt;a href=&quot;http://www.amazon.co.jp/本-JavaScriptによるデータビジュアライゼーション入門-Stephen-Thomas/dp/4873117461/ref=sr_1_1?ie=UTF8&amp;amp;qid=1452166533&amp;amp;sr=8-1&amp;amp;keywords=javascript+ビジュアライゼーション&quot;&gt;「JavaScriptによるデータビジュアライゼーション入門」&lt;/a&gt;に紹介されていた&lt;a href=&quot;https://www.humblesoftware.com/flotr2&quot;&gt;Flotr2&lt;/a&gt;を使ってグラフを描画していたのですが、インタラクティブなグラフにする際には同じ本に紹介されているjQuery版の&lt;a href=&quot;https://www.flotcharts.org&quot;&gt;Flotライブラリ&lt;/a&gt;を使いました。同じものだと思っていたのですが、結構違いがあるようです。&lt;br /&gt;
　&lt;a href=&quot;/software/2016-01-16/flotr2/#dfs-regression&quot;&gt;前回の記事の最後に描画したグラフ&lt;/a&gt;と同じパラメータを渡して描画したものが以下のグラフです。マウスでドラッグした範囲を拡大表示することが出来ます。&lt;/p&gt;

&lt;div id=&quot;dfs-regression&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;button id=&quot;unzoom&quot;&gt;元に戻す&lt;/button&gt;&lt;/p&gt;

&lt;p&gt;　&lt;a href=&quot;https://www.humblesoftware.com/flotr2&quot;&gt;Flotr2&lt;/a&gt;の時と同じパラメータを指定して描画しているにも関わらず、&lt;a href=&quot;/software/2016-01-16/flotr2/#dfs-regression&quot;&gt;前回の記事&lt;/a&gt;と比較すればグラフの見た目に結構違いがあることがわかると思います。グラフの色の違いは色指定していないためデフォルトの色が違うだけなのですが、グリッドの線が表示されていたりグラフの凡例が表示されていなかったり、いくつかのパラメータが無視されています。JavaScript製なので「ページのソースの表示」でコードそのものを見ることも出来ます。&lt;/p&gt;

&lt;h3 id=&quot;flotライブラリを使うために必要だった作業&quot;&gt;Flotライブラリを使うために必要だった作業&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://jekyllrb-ja.github.io/docs/github-pages/&quot;&gt;Github Pages&lt;/a&gt;の使い方もいろいろあると思いますが、私の場合自宅でgitサーバを運用して、Jekyllで静的ファイルを出力しgithubに保存しています。だからローカル環境で完結させたいので、&lt;a href=&quot;https://www.flotcharts.org&quot;&gt;Flotライブラリ&lt;/a&gt;をダウンロードして使用しています。&lt;a href=&quot;http://www.amazon.co.jp/本-JavaScriptによるデータビジュアライゼーション入門-Stephen-Thomas/dp/4873117461/ref=sr_1_1?ie=UTF8&amp;amp;qid=1452166533&amp;amp;sr=8-1&amp;amp;keywords=javascript+ビジュアライゼーション&quot;&gt;「JavaScriptによるデータビジュアライゼーション入門」&lt;/a&gt;の中で紹介されているCDN(Contents Delivery Network)を使用した方法でも動きましたが、以下の２つのファイルをJekyll環境にコピーすれば上記のグラフは動作しました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jquery.min.js&lt;/li&gt;
  &lt;li&gt;jquery.flot.min.js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　既にgoogleAPI用のjqueryを使用していたのですが、それだと動かなかったのでFlotライブラリに同梱されていたものを読み込んでいます。以下のコードは有効に働いているoptionだけ記述しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var $el = $(&quot;#dfs-regression&quot;),
        data = [
            {data: equation1, label: &quot;方程式１&quot;},
            {data: equation2, label: &quot;方程式２&quot;},
            {data: equation3, label: &quot;方程式３&quot;},
            {data: equation4, label: &quot;方程式４&quot;}
            ],
        options = {
            legend: {position: &quot;se&quot;},
            selection: {mode: &quot;x&quot;, color: &quot;#eeeeee&quot;},
            lines:{show: true, horizontal:false},
            xaxis:{
                max: 110
            },
            yaxis:{
                max: 1000
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            }
        }, plotObj;

    $el.on(&quot;plotselected&quot;, function(ev, ranges) {
        plotObj = $.plot($el, data,
                         $.extend(true, {}, options, {
                             xaxis: {min: ranges.xaxis.from, max: ranges.xaxis.to},
                             yaxis: {min: ranges.yaxis.from, max: ranges.yaxis.to}
                         })
                        );
    });
    plotObj = $.plot($el, data, options);
    $(&quot;#unzoom&quot;).click(function() {
        plotObj = $.plot($el, data, options);
    });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;データ値の追跡&quot;&gt;データ値の追跡&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://www.humblesoftware.com/flotr2&quot;&gt;Flotr2&lt;/a&gt;では&lt;code&gt; options{ mouse: { track:true }}&lt;/code&gt;とするだけで、マウスでグラフ上を通過した時に、値を表示してくれたのですが、&lt;a href=&quot;https://www.flotcharts.org&quot;&gt;Flot&lt;/a&gt;には無い？ようです。&lt;a href=&quot;https://www.flotcharts.org&quot;&gt;Flotのサイト&lt;/a&gt;の例を見ても、グラフ上の値を追跡表示するには自前でイベントを追加して結構面倒なことをしなければいけないようです。以前使った&lt;a href=&quot;/programming/2014-10-27/my-posi-chart/&quot;&gt;lazy-high-chart&lt;/a&gt;だとグラフの凡例と値をToolTipで表示することが、オプションで簡単に出来た記憶があるのに、そんなもんでしょうか？う〜ん、バージョンアップに期待することにして、今回はこれ以上弄らないことにします。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
jQuery(function ($){

linegraph = function() {
    var equation1 = [[1 ,414],[2 ,638],[3 ,779],[4 ,864],[5 ,930],[6 ,952],[7 ,946],[8 ,964],[9 ,972],[10 ,980],[11 ,980],[12 ,981],[13 ,980],[14 ,984],[15 ,982],[16 ,986],[17 ,993],[18 ,980],[19 ,985],[20 ,993],[21 ,990],[22 ,991],[23 ,987],[24 ,991],[25 ,989],[26 ,992],[27 ,998],[28 ,994],[29 ,995],[30 ,994],[31 ,994],[32 ,995],[33 ,995],[34 ,993],[35 ,998],[36 ,993],[37 ,992],[38 ,995],[39 ,995],[40 ,993],[41 ,991],[42 ,997],[43 ,997],[44 ,995],[45 ,994],[46 ,996],[47 ,996],[48 ,995],[49 ,997],[50 ,996],[51 ,991],[52 ,995],[53 ,999],[54 ,994],[55 ,991],[56 ,996],[57 ,994],[58 ,993],[59 ,997],[60 ,997],[61 ,998],[62 ,997],[63 ,995],[64 ,1000],[65 ,998],[66 ,999],[67 ,999],[68 ,1000],[69 ,999],[70 ,996],[71 ,999],[72 ,996],[73 ,996],[74 ,997],[75 ,999],[76 ,998],[77 ,998],[78 ,995],[79 ,998],[80 ,997],[81 ,998],[82 ,999],[83 ,998],[84 ,998],[85 ,997],[86 ,999],[87 ,997],[88 ,998],[89 ,999],[90 ,1000],[91 ,996],[92 ,998],[93 ,997],[94 ,996],[95 ,1000],[96 ,998],[97 ,998],[98 ,998],[99 ,999],[100 ,997]];
    var equation2 = [[1 ,460],[2 ,688],[3 ,775],[4 ,850],[5 ,897],[6 ,950],[7 ,945],[8 ,962],[9 ,968],[10 ,975],[11 ,981],[12 ,981],[13 ,981],[14 ,986],[15 ,986],[16 ,986],[17 ,991],[18 ,985],[19 ,983],[20 ,985],[21 ,985],[22 ,985],[23 ,986],[24 ,991],[25 ,992],[26 ,990],[27 ,992],[28 ,996],[29 ,989],[30 ,991],[31 ,991],[32 ,989],[33 ,993],[34 ,992],[35 ,992],[36 ,995],[37 ,994],[38 ,991],[39 ,997],[40 ,996],[41 ,994],[42 ,994],[43 ,994],[44 ,996],[45 ,996],[46 ,995],[47 ,996],[48 ,994],[49 ,997],[50 ,996],[51 ,993],[52 ,997],[53 ,994],[54 ,993],[55 ,997],[56 ,996],[57 ,998],[58 ,996],[59 ,994],[60 ,998],[61 ,997],[62 ,997],[63 ,996],[64 ,998],[65 ,997],[66 ,999],[67 ,997],[68 ,997],[69 ,995],[70 ,995],[71 ,997],[72 ,998],[73 ,996],[74 ,996],[75 ,999],[76 ,997],[77 ,996],[78 ,996],[79 ,1000],[80 ,998],[81 ,995],[82 ,998],[83 ,997],[84 ,998],[85 ,997],[86 ,998],[87 ,999],[88 ,998],[89 ,998],[90 ,994],[91 ,999],[92 ,1000],[93 ,997],[94 ,995],[95 ,999],[96 ,997],[97 ,999],[98 ,999],[99 ,997],[100 ,997]];
    var equation3 = [[1 ,458],[2 ,564],[3 ,671],[4 ,768],[5 ,828],[6 ,877],[7 ,921],[8 ,935],[9 ,957],[10 ,961],[11 ,965],[12 ,974],[13 ,977],[14 ,976],[15 ,972],[16 ,979],[17 ,979],[18 ,978],[19 ,980],[20 ,978],[21 ,981],[22 ,983],[23 ,982],[24 ,984],[25 ,986],[26 ,979],[27 ,989],[28 ,992],[29 ,992],[30 ,993],[31 ,990],[32 ,991],[33 ,992],[34 ,992],[35 ,989],[36 ,993],[37 ,985],[38 ,991],[39 ,995],[40 ,992],[41 ,991],[42 ,992],[43 ,993],[44 ,988],[45 ,991],[46 ,988],[47 ,994],[48 ,994],[49 ,996],[50 ,996],[51 ,998],[52 ,996],[53 ,993],[54 ,996],[55 ,994],[56 ,998],[57 ,998],[58 ,996],[59 ,996],[60 ,993],[61 ,997],[62 ,998],[63 ,993],[64 ,992],[65 ,996],[66 ,998],[67 ,997],[68 ,996],[69 ,994],[70 ,998],[71 ,993],[72 ,995],[73 ,992],[74 ,997],[75 ,995],[76 ,996],[77 ,996],[78 ,993],[79 ,994],[80 ,998],[81 ,998],[82 ,998],[83 ,999],[84 ,996],[85 ,998],[86 ,997],[87 ,998],[88 ,998],[89 ,998],[90 ,998],[91 ,994],[92 ,999],[93 ,996],[94 ,997],[95 ,997],[96 ,997],[97 ,993],[98 ,995],[99 ,996],[100 ,998]];
    var equation4 = [[1 ,472],[2 ,571],[3 ,683],[4 ,754],[5 ,843],[6 ,897],[7 ,932],[8 ,943],[9 ,955],[10 ,969],[11 ,971],[12 ,979],[13 ,982],[14 ,983],[15 ,982],[16 ,977],[17 ,982],[18 ,988],[19 ,986],[20 ,990],[21 ,986],[22 ,982],[23 ,990],[24 ,988],[25 ,992],[26 ,993],[27 ,988],[28 ,993],[29 ,986],[30 ,994],[31 ,995],[32 ,992],[33 ,994],[34 ,993],[35 ,996],[36 ,993],[37 ,993],[38 ,988],[39 ,997],[40 ,996],[41 ,997],[42 ,993],[43 ,993],[44 ,996],[45 ,989],[46 ,996],[47 ,994],[48 ,994],[49 ,998],[50 ,995],[51 ,996],[52 ,997],[53 ,996],[54 ,995],[55 ,994],[56 ,999],[57 ,998],[58 ,998],[59 ,996],[60 ,997],[61 ,997],[62 ,995],[63 ,997],[64 ,993],[65 ,994],[66 ,997],[67 ,998],[68 ,997],[69 ,997],[70 ,996],[71 ,996],[72 ,996],[73 ,994],[74 ,995],[75 ,997],[76 ,997],[77 ,995],[78 ,998],[79 ,998],[80 ,997],[81 ,999],[82 ,998],[83 ,1000],[84 ,998],[85 ,998],[86 ,996],[87 ,998],[88 ,999],[89 ,999],[90 ,998],[91 ,999],[92 ,997],[93 ,999],[94 ,997],[95 ,996],[96 ,999],[97 ,999],[98 ,997],[99 ,997],[100 ,998]];

    var $el = $(&quot;#dfs-regression&quot;),
        data = [
            {data: equation1, label: &quot;方程式１&quot;},
            {data: equation2, label: &quot;方程式２&quot;},
            {data: equation3, label: &quot;方程式３&quot;},
            {data: equation4, label: &quot;方程式４&quot;}
            ],
        options = {
            legend: {position: &quot;se&quot;},
            selection: {mode: &quot;x&quot;, color: &quot;#eeeeee&quot;},
            title: &quot;小石の初期値と補充分を１０から１に修正&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            lines:{show: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }, plotObj;

    $el.on(&quot;plotselected&quot;, function(ev, ranges) {
        plotObj = $.plot($el, data,
                         $.extend(true, {}, options, {
                             xaxis: {min: ranges.xaxis.from, max: ranges.xaxis.to},
                             yaxis: {min: ranges.yaxis.from, max: ranges.yaxis.to}
                         })
                        );
    });
    plotObj = $.plot($el, data, options);
    $(&quot;#unzoom&quot;).click(function() {
        plotObj = $.plot($el, data, options);
    });
};
       
if (typeof contentLoaded != &quot;undefined&quot;) {
    contentLoaded.done(linegraph);
} else {
    window.addEventListener('load', linegraph);
}

});

&lt;/script&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>学習効果をグラフ化してみる</title>
   <link href="https://happyclam.github.io/software/2016-01-16/flotr2"/>
   <updated>2016-01-16T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2016-01-16/flotr2</id>
   <content type="html">&lt;h3 id=&quot;ブログgithub-pagesでグラフ描画flotr2&quot;&gt;ブログ（&lt;a href=&quot;https://jekyllrb-ja.github.io&quot;&gt;Github Pages&lt;/a&gt;）でグラフ描画（&lt;a href=&quot;https://www.humblesoftware.com/flotr2&quot;&gt;Flotr2&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;　ジュンク堂書店でオライリーのカレンダーを入手するために&lt;a href=&quot;http://www.amazon.co.jp/本-JavaScriptによるデータビジュアライゼーション入門-Stephen-Thomas/dp/4873117461/ref=sr_1_1?ie=UTF8&amp;amp;qid=1452166533&amp;amp;sr=8-1&amp;amp;keywords=javascript+ビジュアライゼーション&quot;&gt;「JavaScriptによるデータビジュアライゼーション入門」&lt;/a&gt;という本を買ってしまいました。前回まで三目並べプログラムの学習効果の記事を書いていましたが、１０万回対戦（学習）後の最終結果だけではなく、推移をグラフ化してみたいと思っていながらも面倒なのでやってなかったのですが、本を買ったことでやる気が出たので、awkやemacsのキーボードマクロを駆使してグラフ用データを編集してみました。今回はとりあえず買った本の内容は置いといて、グラフ化した学習効果の結果について書きます。&lt;/p&gt;

&lt;h3 id=&quot;小石の数を減らしたことの影響&quot;&gt;小石の数を減らしたことの影響&lt;/h3&gt;
&lt;p&gt;　前回までのテストで小石の初期値や補充数を少なくすることが一番効果的だということがわかったので、まずは小石の初期値と補充分を１０個にしていた「従来の強化学習」と、「１０個から１個に修正した」分と、全てのテストを通して一番学習効果が高かった線形関数（&lt;script type=&quot;math/tex&quot;&gt;y = \frac{1}{総手数} x&lt;/script&gt;）を使った「終盤の手ほど重要視」するパターンの３つのグラフを比較してみます。&lt;br /&gt;
　横軸の１目盛りが千回分の対戦で、縦軸に下から勝ち（青）・負け（黄緑）・引分（赤）の数を積み上げてグラフにしています。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;対乱数プログラムにおける学習効率の比較&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;最終成績&quot;&gt;最終成績&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;No.&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;学習方法&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　対乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;65,266勝22,986敗11,748分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;74,470勝15,664敗9,866分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;76,304勝13,126敗10,570分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;推移グラフ&quot;&gt;推移グラフ&lt;/h5&gt;

&lt;div id=&quot;rand-allten-int&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;rand-allone-int&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;rand-linear&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　このグラフを見ると弱い対戦相手（乱数プログラム）を使っていくら学習を続けても、ある回数（３、４万回）に達すると限界に達してそれ以上続けても学習効果が望めなくなる（強くならない）ことが推測できます。これは人間が将棋や囲碁を学習する際にも当てはまりそうです。また、３つのグラフを比較すると学習し始めた頃は学習の仕方によって伸び方が違ってくるということも見て取れますが、これも人間と同じだと言えそうです。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;対最強プログラムにおける学習効率の比較&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;最終成績-1&quot;&gt;最終成績&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;No.&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;学習方法&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝9,678敗90,322分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝3,891敗96,109分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝2,038敗97,962分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;推移グラフ-1&quot;&gt;推移グラフ&lt;/h5&gt;

&lt;div id=&quot;dfs-allten-int&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;dfs-allone-int&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;dfs-linear&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　人間の実力と並んでいるであろうと考えられる「引き分け率９割７分」に達するのは、学習方法１が約44,000回後、学習方法２が約17,000回後、学習方法３が約9,000回後です。小石の総数を減らすことと終盤を重要視する方法を組み入れることで、学習効果が向上することがグラフからはっきりと見てとれます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;グラフの傾きを変えることによる影響&quot;&gt;グラフの傾きを変えることによる影響&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2015-12-25/log-linear/&quot;&gt;前々回の記事&lt;/a&gt;でいろいろな方程式を使って結果を比較しましたが、途中経過がなかったので違いがよく分かりませんでした。対最強プログラムに対する引き分け数だけを取り出してみて同一グラフ上に学習度合いの推移を描画し比較してみました。&lt;/p&gt;

&lt;div id=&quot;dfs-regression&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;/software/2015-12-25/log-linear/&quot;&gt;前々回の記事&lt;/a&gt;の方程式１（青、&lt;script type=&quot;math/tex&quot;&gt;y = \frac{1}{総手数} x&lt;/script&gt;）と方程式２（黄緑、&lt;script type=&quot;math/tex&quot;&gt;y = 0.029 \times 1.882^x&lt;/script&gt;）が、わずかですが他の２つの方程式より学習効率がいいということがグラフから分かります。&lt;br /&gt;
　でも、グラフが少し見にくいですね。１０万回分の対戦データを取らなくても、２万回分程度のデータでグラフを描画すべきだったのでしょうか？でも、そうするともっと対戦を続けた場合どうなるか知りたくなるので、これはこれでいいと思います。こういう時こそ今回導入したグラフライブラリの出番です。&lt;br /&gt;
　そこで&lt;a href=&quot;https://www.flotcharts.org&quot;&gt;Flotライブラリ&lt;/a&gt;を使って、次の記事で拡大表示可能なグラフに変更してみます。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

function show_dfs_allone_int(){
    var dfs_lose = [];
    var dfs_win = [[1 ,645],[2 ,465],[3 ,413],[4 ,327],[5 ,278],[6 ,201],[7 ,167],[8 ,136],[9 ,79],[10 ,61],[11 ,55],[12 ,43],[13 ,50],[14 ,47],[15 ,46],[16 ,36],[17 ,26],[18 ,23],[19 ,23],[20 ,28],[21 ,24],[22 ,23],[23 ,18],[24 ,15],[25 ,22],[26 ,14],[27 ,16],[28 ,19],[29 ,12],[30 ,15],[31 ,16],[32 ,13],[33 ,11],[34 ,9],[35 ,15],[36 ,14],[37 ,12],[38 ,14],[39 ,15],[40 ,12],[41 ,11],[42 ,15],[43 ,10],[44 ,5],[45 ,10],[46 ,10],[47 ,9],[48 ,10],[49 ,7],[50 ,8],[51 ,7],[52 ,12],[53 ,10],[54 ,18],[55 ,14],[56 ,13],[57 ,8],[58 ,5],[59 ,9],[60 ,13],[61 ,5],[62 ,13],[63 ,4],[64 ,10],[65 ,12],[66 ,3],[67 ,5],[68 ,7],[69 ,7],[70 ,2],[71 ,3],[72 ,6],[73 ,5],[74 ,8],[75 ,6],[76 ,6],[77 ,5],[78 ,10],[79 ,7],[80 ,9],[81 ,5],[82 ,6],[83 ,6],[84 ,6],[85 ,6],[86 ,4],[87 ,6],[88 ,3],[89 ,5],[90 ,4],[91 ,4],[92 ,7],[93 ,7],[94 ,4],[95 ,7],[96 ,2],[97 ,4],[98 ,1],[99 ,5],[100 ,4],];
    var dfs_draw = [[1 ,355],[2 ,535],[3 ,587],[4 ,673],[5 ,722],[6 ,799],[7 ,833],[8 ,864],[9 ,921],[10 ,939],[11 ,945],[12 ,957],[13 ,950],[14 ,953],[15 ,954],[16 ,964],[17 ,974],[18 ,977],[19 ,977],[20 ,972],[21 ,976],[22 ,977],[23 ,982],[24 ,985],[25 ,978],[26 ,986],[27 ,984],[28 ,981],[29 ,988],[30 ,985],[31 ,984],[32 ,987],[33 ,989],[34 ,991],[35 ,985],[36 ,986],[37 ,988],[38 ,986],[39 ,985],[40 ,988],[41 ,989],[42 ,985],[43 ,990],[44 ,995],[45 ,990],[46 ,990],[47 ,991],[48 ,990],[49 ,993],[50 ,992],[51 ,993],[52 ,988],[53 ,990],[54 ,982],[55 ,986],[56 ,987],[57 ,992],[58 ,995],[59 ,991],[60 ,987],[61 ,995],[62 ,987],[63 ,996],[64 ,990],[65 ,988],[66 ,997],[67 ,995],[68 ,993],[69 ,993],[70 ,998],[71 ,997],[72 ,994],[73 ,995],[74 ,992],[75 ,994],[76 ,994],[77 ,995],[78 ,990],[79 ,993],[80 ,991],[81 ,995],[82 ,994],[83 ,994],[84 ,994],[85 ,994],[86 ,996],[87 ,994],[88 ,997],[89 ,995],[90 ,996],[91 ,996],[92 ,993],[93 ,993],[94 ,996],[95 ,993],[96 ,998],[97 ,996],[98 ,999],[99 ,995],[100 ,996]];

    Flotr.draw(
        document.getElementById(&quot;dfs-allone-int&quot;),
        [
            {data: dfs_lose, label: &quot;勝ち&quot;},
            {data: dfs_win, label: &quot;負け&quot;},
            {data: dfs_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;小石の初期値と補充分を１０から１に修正&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_rand_allone_int(){
    var rand_lose = [[1 ,462],[2 ,508],[3 ,519],[4 ,519],[5 ,583],[6 ,587],[7 ,623],[8 ,636],[9 ,662],[10 ,672],[11 ,651],[12 ,690],[13 ,683],[14 ,689],[15 ,653],[16 ,687],[17 ,663],[18 ,705],[19 ,690],[20 ,729],[21 ,709],[22 ,717],[23 ,746],[24 ,720],[25 ,713],[26 ,722],[27 ,736],[28 ,726],[29 ,738],[30 ,747],[31 ,740],[32 ,734],[33 ,738],[34 ,752],[35 ,737],[36 ,748],[37 ,744],[38 ,759],[39 ,759],[40 ,740],[41 ,734],[42 ,748],[43 ,754],[44 ,772],[45 ,779],[46 ,752],[47 ,787],[48 ,765],[49 ,767],[50 ,777],[51 ,793],[52 ,771],[53 ,768],[54 ,763],[55 ,779],[56 ,781],[57 ,772],[58 ,774],[59 ,790],[60 ,784],[61 ,805],[62 ,772],[63 ,775],[64 ,799],[65 ,794],[66 ,769],[67 ,798],[68 ,740],[69 ,778],[70 ,778],[71 ,770],[72 ,805],[73 ,803],[74 ,792],[75 ,803],[76 ,794],[77 ,780],[78 ,772],[79 ,809],[80 ,797],[81 ,785],[82 ,787],[83 ,777],[84 ,784],[85 ,798],[86 ,788],[87 ,805],[88 ,795],[89 ,799],[90 ,787],[91 ,825],[92 ,815],[93 ,798],[94 ,788],[95 ,799],[96 ,840],[97 ,806],[98 ,799],[99 ,810],[100 ,806]];
    var rand_win = [[1 ,424],[2 ,379],[3 ,359],[4 ,353],[5 ,294],[6 ,287],[7 ,249],[8 ,250],[9 ,223],[10 ,209],[11 ,226],[12 ,197],[13 ,207],[14 ,186],[15 ,237],[16 ,209],[17 ,213],[18 ,194],[19 ,199],[20 ,162],[21 ,185],[22 ,187],[23 ,169],[24 ,179],[25 ,180],[26 ,167],[27 ,160],[28 ,175],[29 ,151],[30 ,150],[31 ,150],[32 ,166],[33 ,173],[34 ,144],[35 ,157],[36 ,150],[37 ,146],[38 ,143],[39 ,155],[40 ,149],[41 ,169],[42 ,148],[43 ,159],[44 ,139],[45 ,133],[46 ,138],[47 ,130],[48 ,126],[49 ,137],[50 ,124],[51 ,138],[52 ,124],[53 ,147],[54 ,140],[55 ,134],[56 ,131],[57 ,138],[58 ,128],[59 ,123],[60 ,120],[61 ,129],[62 ,133],[63 ,125],[64 ,126],[65 ,122],[66 ,129],[67 ,112],[68 ,155],[69 ,117],[70 ,101],[71 ,122],[72 ,119],[73 ,105],[74 ,117],[75 ,103],[76 ,121],[77 ,130],[78 ,128],[79 ,110],[80 ,112],[81 ,122],[82 ,120],[83 ,125],[84 ,124],[85 ,108],[86 ,113],[87 ,114],[88 ,113],[89 ,111],[90 ,123],[91 ,99],[92 ,100],[93 ,112],[94 ,116],[95 ,111],[96 ,88],[97 ,107],[98 ,112],[99 ,103],[100 ,108]];
    var rand_draw = [[1 ,114],[2 ,113],[3 ,122],[4 ,128],[5 ,123],[6 ,126],[7 ,128],[8 ,114],[9 ,115],[10 ,119],[11 ,123],[12 ,113],[13 ,110],[14 ,125],[15 ,110],[16 ,104],[17 ,124],[18 ,101],[19 ,111],[20 ,109],[21 ,106],[22 ,96],[23 ,85],[24 ,101],[25 ,107],[26 ,111],[27 ,104],[28 ,99],[29 ,111],[30 ,103],[31 ,110],[32 ,100],[33 ,89],[34 ,104],[35 ,106],[36 ,102],[37 ,110],[38 ,98],[39 ,86],[40 ,111],[41 ,97],[42 ,104],[43 ,87],[44 ,89],[45 ,88],[46 ,110],[47 ,83],[48 ,109],[49 ,96],[50 ,99],[51 ,69],[52 ,105],[53 ,85],[54 ,97],[55 ,87],[56 ,88],[57 ,90],[58 ,98],[59 ,87],[60 ,96],[61 ,66],[62 ,95],[63 ,100],[64 ,75],[65 ,84],[66 ,102],[67 ,90],[68 ,105],[69 ,105],[70 ,121],[71 ,108],[72 ,76],[73 ,92],[74 ,91],[75 ,94],[76 ,85],[77 ,90],[78 ,100],[79 ,81],[80 ,91],[81 ,93],[82 ,93],[83 ,98],[84 ,92],[85 ,94],[86 ,99],[87 ,81],[88 ,92],[89 ,90],[90 ,90],[91 ,76],[92 ,85],[93 ,90],[94 ,96],[95 ,90],[96 ,72],[97 ,87],[98 ,89],[99 ,87],[100 ,86]];

    Flotr.draw(
        document.getElementById(&quot;rand-allone-int&quot;),
        [
            {data: rand_lose, label: &quot;勝ち&quot;},
            {data: rand_win, label: &quot;負け&quot;},
            {data: rand_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;小石の初期値と補充分を１０から１に修正&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: false,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_dfs_allten_int(){
    var dfs_lose = [];
    var dfs_win = [[1 ,807],[2 ,620],[3 ,583],[4 ,511],[5 ,507],[6 ,448],[7 ,392],[8 ,375],[9 ,358],[10 ,348],[11 ,324],[12 ,295],[13 ,276],[14 ,233],[15 ,225],[16 ,179],[17 ,176],[18 ,167],[19 ,141],[20 ,143],[21 ,133],[22 ,112],[23 ,114],[24 ,92],[25 ,89],[26 ,90],[27 ,78],[28 ,73],[29 ,76],[30 ,66],[31 ,79],[32 ,58],[33 ,61],[34 ,54],[35 ,52],[36 ,48],[37 ,41],[38 ,45],[39 ,43],[40 ,33],[41 ,38],[42 ,36],[43 ,32],[44 ,25],[45 ,32],[46 ,27],[47 ,28],[48 ,23],[49 ,29],[50 ,27],[51 ,20],[52 ,33],[53 ,19],[54 ,23],[55 ,34],[56 ,14],[57 ,31],[58 ,21],[59 ,18],[60 ,21],[61 ,21],[62 ,13],[63 ,19],[64 ,24],[65 ,19],[66 ,15],[67 ,17],[68 ,9],[69 ,23],[70 ,16],[71 ,13],[72 ,16],[73 ,20],[74 ,16],[75 ,15],[76 ,17],[77 ,17],[78 ,15],[79 ,13],[80 ,14],[81 ,14],[82 ,16],[83 ,13],[84 ,9],[85 ,16],[86 ,12],[87 ,16],[88 ,17],[89 ,14],[90 ,14],[91 ,19],[92 ,8],[93 ,14],[94 ,13],[95 ,16],[96 ,13],[97 ,8],[98 ,11],[99 ,11],[100 ,16]];
    var dfs_draw = [[1 ,193],[2 ,380],[3 ,417],[4 ,489],[5 ,493],[6 ,552],[7 ,608],[8 ,625],[9 ,642],[10 ,652],[11 ,676],[12 ,705],[13 ,724],[14 ,767],[15 ,775],[16 ,821],[17 ,824],[18 ,833],[19 ,859],[20 ,857],[21 ,867],[22 ,888],[23 ,886],[24 ,908],[25 ,911],[26 ,910],[27 ,922],[28 ,927],[29 ,924],[30 ,934],[31 ,921],[32 ,942],[33 ,939],[34 ,946],[35 ,948],[36 ,952],[37 ,959],[38 ,955],[39 ,957],[40 ,967],[41 ,962],[42 ,964],[43 ,968],[44 ,975],[45 ,968],[46 ,973],[47 ,972],[48 ,977],[49 ,971],[50 ,973],[51 ,980],[52 ,967],[53 ,981],[54 ,977],[55 ,966],[56 ,986],[57 ,969],[58 ,979],[59 ,982],[60 ,979],[61 ,979],[62 ,987],[63 ,981],[64 ,976],[65 ,981],[66 ,985],[67 ,983],[68 ,991],[69 ,977],[70 ,984],[71 ,987],[72 ,984],[73 ,980],[74 ,984],[75 ,985],[76 ,983],[77 ,983],[78 ,985],[79 ,987],[80 ,986],[81 ,986],[82 ,984],[83 ,987],[84 ,991],[85 ,984],[86 ,988],[87 ,984],[88 ,983],[89 ,986],[90 ,986],[91 ,981],[92 ,992],[93 ,986],[94 ,987],[95 ,984],[96 ,987],[97 ,992],[98 ,989],[99 ,989],[100 ,984]];

    Flotr.draw(
        document.getElementById(&quot;dfs-allten-int&quot;),
        [
            {data: dfs_lose, label: &quot;勝ち&quot;},
            {data: dfs_win, label: &quot;負け&quot;},
            {data: dfs_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の強化学習&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_rand_allten_int(){
    var rand_lose = [[1 ,440],[2 ,444],[3 ,458],[4 ,488],[5 ,467],[6 ,497],[7 ,500],[8 ,506],[9 ,518],[10 ,515],[11 ,535],[12 ,545],[13 ,561],[14 ,542],[15 ,550],[16 ,567],[17 ,553],[18 ,540],[19 ,567],[20 ,560],[21 ,595],[22 ,602],[23 ,584],[24 ,603],[25 ,625],[26 ,557],[27 ,619],[28 ,643],[29 ,604],[30 ,624],[31 ,634],[32 ,640],[33 ,620],[34 ,634],[35 ,621],[36 ,633],[37 ,668],[38 ,632],[39 ,649],[40 ,665],[41 ,638],[42 ,664],[43 ,682],[44 ,664],[45 ,689],[46 ,699],[47 ,644],[48 ,687],[49 ,701],[50 ,679],[51 ,684],[52 ,685],[53 ,695],[54 ,667],[55 ,673],[56 ,678],[57 ,679],[58 ,696],[59 ,697],[60 ,695],[61 ,703],[62 ,703],[63 ,687],[64 ,689],[65 ,684],[66 ,703],[67 ,716],[68 ,699],[69 ,724],[70 ,717],[71 ,720],[72 ,710],[73 ,713],[74 ,727],[75 ,728],[76 ,718],[77 ,734],[78 ,736],[79 ,718],[80 ,727],[81 ,720],[82 ,714],[83 ,716],[84 ,724],[85 ,744],[86 ,738],[87 ,728],[88 ,723],[89 ,733],[90 ,726],[91 ,736],[92 ,732],[93 ,718],[94 ,729],[95 ,746],[96 ,738],[97 ,754],[98 ,725],[99 ,731],[100 ,734]];
    var rand_win = [[1 ,438],[2 ,420],[3 ,412],[4 ,396],[5 ,388],[6 ,386],[7 ,385],[8 ,364],[9 ,358],[10 ,351],[11 ,353],[12 ,335],[13 ,318],[14 ,341],[15 ,327],[16 ,313],[17 ,325],[18 ,315],[19 ,320],[20 ,309],[21 ,281],[22 ,284],[23 ,277],[24 ,269],[25 ,243],[26 ,311],[27 ,264],[28 ,233],[29 ,282],[30 ,259],[31 ,247],[32 ,242],[33 ,265],[34 ,264],[35 ,247],[36 ,238],[37 ,224],[38 ,240],[39 ,227],[40 ,231],[41 ,233],[42 ,220],[43 ,202],[44 ,216],[45 ,206],[46 ,177],[47 ,228],[48 ,195],[49 ,179],[50 ,196],[51 ,205],[52 ,190],[53 ,198],[54 ,221],[55 ,210],[56 ,191],[57 ,192],[58 ,193],[59 ,200],[60 ,208],[61 ,191],[62 ,196],[63 ,204],[64 ,188],[65 ,188],[66 ,170],[67 ,186],[68 ,181],[69 ,168],[70 ,168],[71 ,168],[72 ,181],[73 ,172],[74 ,162],[75 ,158],[76 ,180],[77 ,153],[78 ,145],[79 ,169],[80 ,160],[81 ,176],[82 ,168],[83 ,179],[84 ,160],[85 ,152],[86 ,164],[87 ,155],[88 ,162],[89 ,171],[90 ,155],[91 ,152],[92 ,153],[93 ,165],[94 ,157],[95 ,140],[96 ,140],[97 ,139],[98 ,165],[99 ,151],[100 ,152]];
    var rand_draw = [[1 ,122],[2 ,136],[3 ,130],[4 ,116],[5 ,145],[6 ,117],[7 ,115],[8 ,130],[9 ,124],[10 ,134],[11 ,112],[12 ,120],[13 ,121],[14 ,117],[15 ,123],[16 ,120],[17 ,122],[18 ,145],[19 ,113],[20 ,131],[21 ,124],[22 ,114],[23 ,139],[24 ,128],[25 ,132],[26 ,132],[27 ,117],[28 ,124],[29 ,114],[30 ,117],[31 ,119],[32 ,118],[33 ,115],[34 ,102],[35 ,132],[36 ,129],[37 ,108],[38 ,128],[39 ,124],[40 ,104],[41 ,129],[42 ,116],[43 ,116],[44 ,120],[45 ,105],[46 ,124],[47 ,128],[48 ,118],[49 ,120],[50 ,125],[51 ,111],[52 ,125],[53 ,107],[54 ,112],[55 ,117],[56 ,131],[57 ,129],[58 ,111],[59 ,103],[60 ,97],[61 ,106],[62 ,101],[63 ,109],[64 ,123],[65 ,128],[66 ,127],[67 ,98],[68 ,120],[69 ,108],[70 ,115],[71 ,112],[72 ,109],[73 ,115],[74 ,111],[75 ,114],[76 ,102],[77 ,113],[78 ,119],[79 ,113],[80 ,113],[81 ,104],[82 ,118],[83 ,105],[84 ,116],[85 ,104],[86 ,98],[87 ,117],[88 ,115],[89 ,96],[90 ,119],[91 ,112],[92 ,115],[93 ,117],[94 ,114],[95 ,114],[96 ,122],[97 ,107],[98 ,110],[99 ,118],[100 ,114]];

    Flotr.draw(
        document.getElementById(&quot;rand-allten-int&quot;),
        [
            {data: rand_lose, label: &quot;勝ち&quot;},
            {data: rand_win, label: &quot;負け&quot;},
            {data: rand_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の強化学習&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_rand_linear(){
    var rand_lose = [[1 ,486],[2 ,499],[3 ,595],[4 ,541],[5 ,602],[6 ,629],[7 ,635],[8 ,662],[9 ,660],[10 ,680],[11 ,661],[12 ,665],[13 ,683],[14 ,672],[15 ,730],[16 ,715],[17 ,704],[18 ,693],[19 ,704],[20 ,726],[21 ,732],[22 ,740],[23 ,747],[24 ,760],[25 ,742],[26 ,752],[27 ,752],[28 ,739],[29 ,754],[30 ,769],[31 ,753],[32 ,742],[33 ,774],[34 ,779],[35 ,773],[36 ,793],[37 ,773],[38 ,767],[39 ,754],[40 ,791],[41 ,772],[42 ,789],[43 ,766],[44 ,757],[45 ,796],[46 ,801],[47 ,799],[48 ,786],[49 ,764],[50 ,799],[51 ,799],[52 ,790],[53 ,782],[54 ,765],[55 ,799],[56 ,791],[57 ,800],[58 ,798],[59 ,799],[60 ,800],[61 ,809],[62 ,806],[63 ,803],[64 ,792],[65 ,797],[66 ,816],[67 ,803],[68 ,787],[69 ,808],[70 ,808],[71 ,813],[72 ,787],[73 ,817],[74 ,808],[75 ,793],[76 ,799],[77 ,807],[78 ,797],[79 ,813],[80 ,814],[81 ,822],[82 ,815],[83 ,819],[84 ,798],[85 ,806],[86 ,838],[87 ,815],[88 ,820],[89 ,828],[90 ,837],[91 ,817],[92 ,804],[93 ,809],[94 ,822],[95 ,826],[96 ,805],[97 ,835],[98 ,813],[99 ,804],[100 ,814]];
    var rand_win = [[1 ,405],[2 ,372],[3 ,288],[4 ,291],[5 ,267],[6 ,246],[7 ,233],[8 ,203],[9 ,214],[10 ,191],[11 ,198],[12 ,205],[13 ,187],[14 ,186],[15 ,145],[16 ,170],[17 ,194],[18 ,186],[19 ,181],[20 ,162],[21 ,158],[22 ,143],[23 ,142],[24 ,138],[25 ,152],[26 ,133],[27 ,128],[28 ,154],[29 ,123],[30 ,123],[31 ,138],[32 ,141],[33 ,121],[34 ,133],[35 ,129],[36 ,118],[37 ,114],[38 ,123],[39 ,131],[40 ,110],[41 ,115],[42 ,105],[43 ,112],[44 ,132],[45 ,109],[46 ,106],[47 ,119],[48 ,108],[49 ,103],[50 ,95],[51 ,103],[52 ,88],[53 ,121],[54 ,114],[55 ,95],[56 ,112],[57 ,107],[58 ,110],[59 ,90],[60 ,104],[61 ,102],[62 ,97],[63 ,99],[64 ,109],[65 ,99],[66 ,88],[67 ,101],[68 ,105],[69 ,115],[70 ,97],[71 ,82],[72 ,106],[73 ,96],[74 ,103],[75 ,109],[76 ,93],[77 ,104],[78 ,116],[79 ,91],[80 ,102],[81 ,87],[82 ,91],[83 ,92],[84 ,100],[85 ,95],[86 ,86],[87 ,99],[88 ,88],[89 ,89],[90 ,71],[91 ,100],[92 ,103],[93 ,90],[94 ,75],[95 ,73],[96 ,111],[97 ,75],[98 ,83],[99 ,93],[100 ,87]];
    var rand_draw = [[1 ,109],[2 ,129],[3 ,117],[4 ,168],[5 ,131],[6 ,125],[7 ,132],[8 ,135],[9 ,126],[10 ,129],[11 ,141],[12 ,130],[13 ,130],[14 ,142],[15 ,125],[16 ,115],[17 ,102],[18 ,121],[19 ,115],[20 ,112],[21 ,110],[22 ,117],[23 ,111],[24 ,102],[25 ,106],[26 ,115],[27 ,120],[28 ,107],[29 ,123],[30 ,108],[31 ,109],[32 ,117],[33 ,105],[34 ,88],[35 ,98],[36 ,89],[37 ,113],[38 ,110],[39 ,115],[40 ,99],[41 ,113],[42 ,106],[43 ,122],[44 ,111],[45 ,95],[46 ,93],[47 ,82],[48 ,106],[49 ,133],[50 ,106],[51 ,98],[52 ,122],[53 ,97],[54 ,121],[55 ,106],[56 ,97],[57 ,93],[58 ,92],[59 ,111],[60 ,96],[61 ,89],[62 ,97],[63 ,98],[64 ,99],[65 ,104],[66 ,96],[67 ,96],[68 ,108],[69 ,77],[70 ,95],[71 ,105],[72 ,107],[73 ,87],[74 ,89],[75 ,98],[76 ,108],[77 ,89],[78 ,87],[79 ,96],[80 ,84],[81 ,91],[82 ,94],[83 ,89],[84 ,102],[85 ,99],[86 ,76],[87 ,86],[88 ,92],[89 ,83],[90 ,92],[91 ,83],[92 ,93],[93 ,101],[94 ,103],[95 ,101],[96 ,84],[97 ,90],[98 ,104],[99 ,103],[100 ,99]];

    Flotr.draw(
        document.getElementById(&quot;rand-linear&quot;),
        [
            {data: rand_lose, label: &quot;勝ち&quot;},
            {data: rand_win, label: &quot;負け&quot;},
            {data: rand_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;終盤の手ほど重要視（線形関数）&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_dfs_linear(){
    var rand_lose = [];
    var rand_win = [[1 ,586],[2 ,362],[3 ,221],[4 ,136],[5 ,70],[6 ,48],[7 ,54],[8 ,36],[9 ,28],[10 ,20],[11 ,20],[12 ,19],[13 ,20],[14 ,16],[15 ,18],[16 ,14],[17 ,7],[18 ,20],[19 ,15],[20 ,7],[21 ,10],[22 ,9],[23 ,13],[24 ,9],[25 ,11],[26 ,8],[27 ,2],[28 ,6],[29 ,5],[30 ,6],[31 ,6],[32 ,5],[33 ,5],[34 ,7],[35 ,2],[36 ,7],[37 ,8],[38 ,5],[39 ,5],[40 ,7],[41 ,9],[42 ,3],[43 ,3],[44 ,5],[45 ,6],[46 ,4],[47 ,4],[48 ,5],[49 ,3],[50 ,4],[51 ,9],[52 ,5],[53 ,1],[54 ,6],[55 ,9],[56 ,4],[57 ,6],[58 ,7],[59 ,3],[60 ,3],[61 ,2],[62 ,3],[63 ,5],[64, 0],[65 ,2],[66 ,1],[67 ,1],[68,0],[69 ,1],[70 ,4],[71 ,1],[72 ,4],[73 ,4],[74 ,3],[75 ,1],[76 ,2],[77 ,2],[78 ,5],[79 ,2],[80 ,3],[81 ,2],[82 ,1],[83 ,2],[84 ,2],[85 ,3],[86 ,1],[87 ,3],[88 ,2],[89 ,1],[90, 0],[91 ,4],[92 ,2],[93 ,3],[94 ,4],[95, 0],[96 ,2],[97 ,2],[98 ,2],[99 ,1],[100 ,3]];
    var rand_draw = [[1 ,414],[2 ,638],[3 ,779],[4 ,864],[5 ,930],[6 ,952],[7 ,946],[8 ,964],[9 ,972],[10 ,980],[11 ,980],[12 ,981],[13 ,980],[14 ,984],[15 ,982],[16 ,986],[17 ,993],[18 ,980],[19 ,985],[20 ,993],[21 ,990],[22 ,991],[23 ,987],[24 ,991],[25 ,989],[26 ,992],[27 ,998],[28 ,994],[29 ,995],[30 ,994],[31 ,994],[32 ,995],[33 ,995],[34 ,993],[35 ,998],[36 ,993],[37 ,992],[38 ,995],[39 ,995],[40 ,993],[41 ,991],[42 ,997],[43 ,997],[44 ,995],[45 ,994],[46 ,996],[47 ,996],[48 ,995],[49 ,997],[50 ,996],[51 ,991],[52 ,995],[53 ,999],[54 ,994],[55 ,991],[56 ,996],[57 ,994],[58 ,993],[59 ,997],[60 ,997],[61 ,998],[62 ,997],[63 ,995],[64 ,1000],[65 ,998],[66 ,999],[67 ,999],[68 ,1000],[69 ,999],[70 ,996],[71 ,999],[72 ,996],[73 ,996],[74 ,997],[75 ,999],[76 ,998],[77 ,998],[78 ,995],[79 ,998],[80 ,997],[81 ,998],[82 ,999],[83 ,998],[84 ,998],[85 ,997],[86 ,999],[87 ,997],[88 ,998],[89 ,999],[90 ,1000],[91 ,996],[92 ,998],[93 ,997],[94 ,996],[95 ,1000],[96 ,998],[97 ,998],[98 ,998],[99 ,999],[100 ,997]];

    Flotr.draw(
        document.getElementById(&quot;dfs-linear&quot;),
        [
            {data: rand_lose, label: &quot;勝ち&quot;},
            {data: rand_win, label: &quot;負け&quot;},
            {data: rand_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;終盤の手ほど重要視（線形関数）&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_dfs_regression(){
    var equation1 = [[1 ,414],[2 ,638],[3 ,779],[4 ,864],[5 ,930],[6 ,952],[7 ,946],[8 ,964],[9 ,972],[10 ,980],[11 ,980],[12 ,981],[13 ,980],[14 ,984],[15 ,982],[16 ,986],[17 ,993],[18 ,980],[19 ,985],[20 ,993],[21 ,990],[22 ,991],[23 ,987],[24 ,991],[25 ,989],[26 ,992],[27 ,998],[28 ,994],[29 ,995],[30 ,994],[31 ,994],[32 ,995],[33 ,995],[34 ,993],[35 ,998],[36 ,993],[37 ,992],[38 ,995],[39 ,995],[40 ,993],[41 ,991],[42 ,997],[43 ,997],[44 ,995],[45 ,994],[46 ,996],[47 ,996],[48 ,995],[49 ,997],[50 ,996],[51 ,991],[52 ,995],[53 ,999],[54 ,994],[55 ,991],[56 ,996],[57 ,994],[58 ,993],[59 ,997],[60 ,997],[61 ,998],[62 ,997],[63 ,995],[64 ,1000],[65 ,998],[66 ,999],[67 ,999],[68 ,1000],[69 ,999],[70 ,996],[71 ,999],[72 ,996],[73 ,996],[74 ,997],[75 ,999],[76 ,998],[77 ,998],[78 ,995],[79 ,998],[80 ,997],[81 ,998],[82 ,999],[83 ,998],[84 ,998],[85 ,997],[86 ,999],[87 ,997],[88 ,998],[89 ,999],[90 ,1000],[91 ,996],[92 ,998],[93 ,997],[94 ,996],[95 ,1000],[96 ,998],[97 ,998],[98 ,998],[99 ,999],[100 ,997]];
    var equation2 = [[1 ,460],[2 ,688],[3 ,775],[4 ,850],[5 ,897],[6 ,950],[7 ,945],[8 ,962],[9 ,968],[10 ,975],[11 ,981],[12 ,981],[13 ,981],[14 ,986],[15 ,986],[16 ,986],[17 ,991],[18 ,985],[19 ,983],[20 ,985],[21 ,985],[22 ,985],[23 ,986],[24 ,991],[25 ,992],[26 ,990],[27 ,992],[28 ,996],[29 ,989],[30 ,991],[31 ,991],[32 ,989],[33 ,993],[34 ,992],[35 ,992],[36 ,995],[37 ,994],[38 ,991],[39 ,997],[40 ,996],[41 ,994],[42 ,994],[43 ,994],[44 ,996],[45 ,996],[46 ,995],[47 ,996],[48 ,994],[49 ,997],[50 ,996],[51 ,993],[52 ,997],[53 ,994],[54 ,993],[55 ,997],[56 ,996],[57 ,998],[58 ,996],[59 ,994],[60 ,998],[61 ,997],[62 ,997],[63 ,996],[64 ,998],[65 ,997],[66 ,999],[67 ,997],[68 ,997],[69 ,995],[70 ,995],[71 ,997],[72 ,998],[73 ,996],[74 ,996],[75 ,999],[76 ,997],[77 ,996],[78 ,996],[79 ,1000],[80 ,998],[81 ,995],[82 ,998],[83 ,997],[84 ,998],[85 ,997],[86 ,998],[87 ,999],[88 ,998],[89 ,998],[90 ,994],[91 ,999],[92 ,1000],[93 ,997],[94 ,995],[95 ,999],[96 ,997],[97 ,999],[98 ,999],[99 ,997],[100 ,997]];
    var equation3 = [[1 ,458],[2 ,564],[3 ,671],[4 ,768],[5 ,828],[6 ,877],[7 ,921],[8 ,935],[9 ,957],[10 ,961],[11 ,965],[12 ,974],[13 ,977],[14 ,976],[15 ,972],[16 ,979],[17 ,979],[18 ,978],[19 ,980],[20 ,978],[21 ,981],[22 ,983],[23 ,982],[24 ,984],[25 ,986],[26 ,979],[27 ,989],[28 ,992],[29 ,992],[30 ,993],[31 ,990],[32 ,991],[33 ,992],[34 ,992],[35 ,989],[36 ,993],[37 ,985],[38 ,991],[39 ,995],[40 ,992],[41 ,991],[42 ,992],[43 ,993],[44 ,988],[45 ,991],[46 ,988],[47 ,994],[48 ,994],[49 ,996],[50 ,996],[51 ,998],[52 ,996],[53 ,993],[54 ,996],[55 ,994],[56 ,998],[57 ,998],[58 ,996],[59 ,996],[60 ,993],[61 ,997],[62 ,998],[63 ,993],[64 ,992],[65 ,996],[66 ,998],[67 ,997],[68 ,996],[69 ,994],[70 ,998],[71 ,993],[72 ,995],[73 ,992],[74 ,997],[75 ,995],[76 ,996],[77 ,996],[78 ,993],[79 ,994],[80 ,998],[81 ,998],[82 ,998],[83 ,999],[84 ,996],[85 ,998],[86 ,997],[87 ,998],[88 ,998],[89 ,998],[90 ,998],[91 ,994],[92 ,999],[93 ,996],[94 ,997],[95 ,997],[96 ,997],[97 ,993],[98 ,995],[99 ,996],[100 ,998]];
    var equation4 = [[1 ,472],[2 ,571],[3 ,683],[4 ,754],[5 ,843],[6 ,897],[7 ,932],[8 ,943],[9 ,955],[10 ,969],[11 ,971],[12 ,979],[13 ,982],[14 ,983],[15 ,982],[16 ,977],[17 ,982],[18 ,988],[19 ,986],[20 ,990],[21 ,986],[22 ,982],[23 ,990],[24 ,988],[25 ,992],[26 ,993],[27 ,988],[28 ,993],[29 ,986],[30 ,994],[31 ,995],[32 ,992],[33 ,994],[34 ,993],[35 ,996],[36 ,993],[37 ,993],[38 ,988],[39 ,997],[40 ,996],[41 ,997],[42 ,993],[43 ,993],[44 ,996],[45 ,989],[46 ,996],[47 ,994],[48 ,994],[49 ,998],[50 ,995],[51 ,996],[52 ,997],[53 ,996],[54 ,995],[55 ,994],[56 ,999],[57 ,998],[58 ,998],[59 ,996],[60 ,997],[61 ,997],[62 ,995],[63 ,997],[64 ,993],[65 ,994],[66 ,997],[67 ,998],[68 ,997],[69 ,997],[70 ,996],[71 ,996],[72 ,996],[73 ,994],[74 ,995],[75 ,997],[76 ,997],[77 ,995],[78 ,998],[79 ,998],[80 ,997],[81 ,999],[82 ,998],[83 ,1000],[84 ,998],[85 ,998],[86 ,996],[87 ,998],[88 ,999],[89 ,999],[90 ,998],[91 ,999],[92 ,997],[93 ,999],[94 ,997],[95 ,996],[96 ,999],[97 ,999],[98 ,997],[99 ,997],[100 ,998]];

    Flotr.draw(
        document.getElementById(&quot;dfs-regression&quot;),
        [
            {data: equation1, label: &quot;方程式１&quot;},
            {data: equation2, label: &quot;方程式２&quot;},
            {data: equation3, label: &quot;方程式３&quot;},
            {data: equation4, label: &quot;方程式４&quot;}
        ],
        {
            legend: {position: &quot;se&quot;},
            title: &quot;方程式の違いによる学習効率&quot;,
            subtitle: &quot;対最強プログラムにおける引き分け数推移&quot;,
            HtmlText: false,
            lines:{show: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対最強プログラムにおける引き分け数&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: false,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

window.onload = function() {
    show_rand_allten_int();
    show_rand_allone_int();
    show_rand_linear();
    show_dfs_allten_int();
    show_dfs_allone_int();
    show_dfs_linear();
    show_dfs_regression();
};

&lt;/script&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>三目並べプログラムの強化学習効率を上げる</title>
   <link href="https://happyclam.github.io/software/2016-01-07/correlation"/>
   <updated>2016-01-07T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2016-01-07/correlation</id>
   <content type="html">&lt;h3 id=&quot;気になることがまだ残っている&quot;&gt;気になることがまだ残っている&lt;/h3&gt;
&lt;p&gt;　前回の続きです。手数毎に報酬や罰の値を変更する方法をいろいろ試しましたが、大した成果が上がらなかったので、もとに戻して（全ての局面データに一律に報酬や罰を与える方法、前々回までの状態に戻して）他の切り口から気になっていたことを試してみたいと思います。&lt;br /&gt;
　もしかしたら三目並べに最善の強化方法というものが既に確立されているのかもしれませんが、自分で試してみたいので続けます。&lt;/p&gt;

&lt;h3 id=&quot;強い人ほど短手数で勝つはず&quot;&gt;強い人ほど短手数で勝つはず？&lt;/h3&gt;
&lt;p&gt;　以前から気になっていたのですが、完全読み切りプログラムでは、先手（ X ）の時に以下のような経過を辿って勝つ時があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    初期盤面      １手目      ２手目       ３手目       ４手目       ５手目
    |1|2|3|    |1|2|3|     |1|O|3|     |X|O|3|     |X|O|O|    |X|O|O|
    |4|5|6| -&amp;gt; |4|X|6|  -&amp;gt; |4|X|6|  -&amp;gt; |4|X|6|  -&amp;gt; |4|X|6| -&amp;gt; |4|X|6|
    |7|8|9|    |7|8|9|     |7|8|9|     |7|8|9|     |7|8|9|    |X|8|9|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　４手目で”9”の場所を選べば勝ちなのにそこを選ばずに”7”の場所を選んでダブルリーチをかける時があるのです。完全に読み切っているために”7”の場所も”9”の場所も同じ評価値（どちらを選んでも勝ちであることを読み切っている）なのでこういうことが起きるわけです。事前に勝ちがあるかどうかを判断して、勝ちがある時はその手を優先して選択するように変更するのは容易ですが、機械学習プログラムの場合は先読みするわけでは無いので、こういうケースに対処するために「なるべく短手数で勝負を終える方がいい」と学習させる必要があるのではないかと思ったわけです。機械学習プログラムの場合は先読み関数を使用せず、過去の経験から学習して手を選択するだけなので、勝負が長引けば間違える（悪い手を選択する）可能性も高くなります。短手数で決着したゲームの方が長手数の時より報酬を多めに与えるべきか、本当は手数と強さの相関関係を調べた方がいいのかもしれませんが、実際に試した方が早そうです。将棋などでも必ずしも強い人の総手数が短いとは言えないと思いますが、詰みがある時は逃さないという意味では「強い人は短手数で勝つ」ということが言えるような気もします。&lt;br /&gt;
　ということで、いたずらに勝負を長引かせないために、なるべく短手数で勝った時の方が報酬を多く与えるように学習機能（「強化」の方法）を変更して効果を確認してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#変更前
inc = (@sengo == CROSS) ? 3 : -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　↑こんな感じになっていたコードを以下のように変えただけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#変更後
base = SHORTEST / history.size
inc = (@sengo == CROSS) ? (3.0 * base) : (-1.0 * base)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　SHORTEST定数は最短で勝負がついた場合の手数６（初期盤面を含む）です。総手数を分母にしているので、最短手数の６手で勝った時だけ報酬が＋３されますが、手数が伸びるほどそれ未満の報酬しか受け取れなくなります。また、短手数で負けた時ほど罰が厳しくなります。最短手数で負けた場合は辿ったすべての局面データから、選択した場所の小石（score配列）が−１されていきますが、最長手数１０手（初期盤面を含む）で負けた時は0.6 (&lt;script type=&quot;math/tex&quot;&gt;-1\times\frac{6}{10}&lt;/script&gt; ) ずつしか引かれません&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
　これは手数によって（何手目かによって）報酬や罰を変化させるわけではないので、&lt;a href=&quot;/software/2015-12-25/log-linear&quot;&gt;前回の記事&lt;/a&gt;の方法と似ていますが違います。何手でゲームが終了したかによって y の値が変わる横一直線のグラフになり、前回同様６手で終了した場合を敢えてグラフ化すると、以下のようになります。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/shortest.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/shortest.png&quot; alt=&quot;短手数ほど報酬＆罰を増やす&quot; title=&quot;短手数ほど報酬＆罰を増やす&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　対戦結果は以下です。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;短手数の報酬を多くした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,807敗91,193分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,978勝23,394敗11,628分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　負け数が減って学習効果が上がったようですが、乱数プログラムとの対戦成績は若干勝率が悪くなっています。&lt;/p&gt;

&lt;h3 id=&quot;終盤の一手の価値を上げる&quot;&gt;終盤の一手の価値を上げる？&lt;/h3&gt;
&lt;p&gt;　前回の記事で終盤の手ほど重要視して報酬や罰を増やす方法を試しましたが、今回は報酬や罰は変えずに終盤ほど小石（score配列）の総数を減らすという方法を試してみます。&lt;br /&gt;
　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には以下のように書かれています。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;３目並べのケースでは、すぐに負けにつながるミスを効率的に処分し、罰するべきだ。ゲーム終盤の手で使うビーズの総量が少なければ、より短期間で学習されていくはずだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　強化学習の際に初期盤面や一手目の局面は頻繁に現れますが、組み合わせの数が多い中盤・終盤の局面は出現頻度が低いのでなかなか学習が進まないので学習効果を上げるためにその局面に配置されている小石（score配列）の総数を少なくすればいいというわけです。&lt;br /&gt;
　全局面の多分木データを生成する際（Player.bfsメソッド）に小石の初期値を何手目の局面かによって変えるようにしました。初期盤面は１０個、１手目の局面は９個というように手数の深さによって減らしていきます。それと小石が不足した際に補充する時（Player.learningメソッド）も局面の深さによって補充する小石の数を初期化時と同様に変える（減らす）ようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#Player.bfs
#変更前
          @trees.add(buf, Tree.new(temp, PEBBLES))

#変更後
          @trees.add(buf, Tree.new(temp, PEBBLES - layer + 1))

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#Player.learning
#変更前
    while board
        #石が０個になっていたら置ける箇所全てに追加
        if buf.score[pre_index] &amp;lt;= 0
          buf.score.map!{|v|
            v += PEBBLES if v
          }
        }

#変更後
    pebbles = history.size
    while board
        #石が０個になっていたら置ける箇所全てに追加
        if buf.score[pre_index] &amp;lt;= 0
          buf.score.map!{|v|
            v += pebbles if v
          }
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　報酬や罰に関しては、勝ちは＋３、負けは−１、引き分けは＋１という「従来の強化学習」と全く同じだということです。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;短手数の報酬を多くした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,807敗91,193分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,978勝23,394敗11,628分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;手数によって小石の数を減らした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝7,977敗92,023分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;67,356勝21,444敗11,200分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　&lt;a href=&quot;/software/2015-12-25/log-linear&quot;&gt;前回の記事&lt;/a&gt;を含めて、今までで一番効果が出ました。どうやら報酬や罰の与え方を変えるより、小石の総数を減らすことの方が効果があるようです。&lt;br /&gt;
　ところで「初期状態や補充分の小石の数を手数によって変化させて、報酬や罰は一定量にする」ことと「初期状態や補充分の小石の数は一定にして、報酬や罰を手数に応じて増減させる」のとどう違うのか、&lt;a href=&quot;/software/2015-12-25/log-linear&quot;&gt;前回&lt;/a&gt;のようにグラフの傾きで考えてみると、総手数が６手（初期盤面含む）で終了した場合、小石の総数は初期盤面では９箇所×小石１０個、１手目の局面では８箇所×小石９個、２手目の局面では７箇所×小石８個、となるので数の推移は以下の表の y′ のようになり&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167(1/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.111(10/90)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.333(2/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.125(9/72)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.500(3/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.143(8/56)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.667(4/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167(7/42)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.833(5/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.200(6/30)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.000(6/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.25(5/20)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　グラフにすれば以下のようななだらかな曲線になりますが、&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/log-linear3.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/log-linear3.png&quot; alt=&quot;曲線回帰、初期値のみ&quot; title=&quot;曲線回帰、初期値のみ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　これには途中の補充分が考慮されていないのであまり意味がありません。一応前回のように回帰方程式を使って対戦させてみましたが全然ダメでした。ゲームが終了する度に評価を実施（Player.learningメソッド）し報酬や罰を加算するわけですが、小石が補充される機会というのは毎回ではありません。でも、補充される度に今までより小石の総数が抑えられるのでかなり影響しているはずでが、計算がややこしそうだったので比較は諦めました。&lt;br /&gt;
　とにかく、前回の記事からいろいろと報酬や罰の与え方（グラフの傾き）を弄っていましたが、大事なのはそんなことではなく、如何にして小石の総数を減らすかだということがわかったということです。&lt;br /&gt;
　確認のため、終盤を重視したり短手数の時に報酬を増やしたり余計なことはせず「従来の強化方法」（手数に関係なく一律に全局面の小石の数を増減させる方法）で、小石の初期値と補充分の定数を１０から１にだけ変更して試したところ、以下の表のように断トツで今までで一番良い結果が出ました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;短手数の報酬を多くした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,807敗91,193分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,978勝23,394敗11,628分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;手数によって小石の数を減らした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝7,977敗92,023分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;67,356勝21,444敗11,200分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝3,526敗96,474分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;77,058勝12,829敗10,113分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　勝ちは＋３、負けは−１、引き分けは＋１という報酬や罰の与え方（グラフの傾き）を変えることで学習効果に多少の改善があったとしても、そんなものは小石の総数を減らすことに比べたらわずかな効果しかないということでしょう。&lt;br /&gt;
　今から思えば小石が不足した時に補充するやり方に修正した時点（&lt;a href=&quot;/software/2015-11-27/reinforcement&quot;&gt;前々回の記事&lt;/a&gt;）で、初期値を１０から１にすればよかったです。&lt;/p&gt;

&lt;h3 id=&quot;終盤の手ほど重要視する方法は効果がない&quot;&gt;終盤の手ほど重要視する方法は効果がない？&lt;/h3&gt;
&lt;p&gt;　小石の総数を減らすことが強化学習の効果を上げるのに有効なことはわかりましたが、前回の記事で試していた終盤の手ほど重要視する（終盤ほど報酬や罰を増やす）方法が否定されたわけではありません。それを確認するために、小石の初期値や補充分を１０個から１個に修正した上で、尚且つ前回の方程式１（&lt;script type=&quot;math/tex&quot;&gt;y = \frac{1}{総手数} x&lt;/script&gt;）を適用して確認してみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝3,526敗96,474分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;77,058勝12,829敗10,113分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）Part 2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝2,068敗97,932分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;80,512勝11,417敗8,071分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　予想通り対最強プログラムでは負け数が減り、対乱数プログラムでも勝率が上がっていますので、全部は試しませんが前回の記事で使用した他の方程式を適用しても前回同様の傾向が出るのだと思います。&lt;br /&gt;
　次に、今回の記事で最初に試した「短手数のゲームほど報酬や罰を増やす」方法も試してみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝3,526敗96,474分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;77,058勝12,829敗10,113分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）Part 2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝2,068敗97,932分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;80,512勝11,417敗8,071分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;短手数の報酬を多くした強化学習 Part 2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝2,433敗97,567分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;78,953勝11,249敗9,798分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　やはり、単に小石の総数を減らしただけより、対最強プログラムでは負け数が減り、対乱数プログラムでも勝率が上がっているので、効果が出ています。&lt;br /&gt;
　小石を浮動小数点数で扱うように変更した甲斐がありました&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&quot;人間並みに強くするにはどれぐらい学習が必要か&quot;&gt;人間並みに強くするにはどれぐらい学習が必要か？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;の仕様に沿いながらこの三目並べ機械学習プログラムを&lt;a href=&quot;/software/2015-10-25/machine_learning&quot;&gt;初めて作った時点&lt;/a&gt;では、完全読み切りの最強プログラムとの対戦成績は８割の引き分け率でしたが、いろいろ弄って９割７分まで上げることが出来ました。三目並べを人間同士で対戦すればほぼ１００％引き分けになると思いますが、うっかりミスもあるので、９割７分の引き分け率というのはほぼ人間並みになったと言えるのではないでしょうか？&lt;br /&gt;
　でも、三目並べで１０万回も対戦（学習）させてようやく９割７分になる&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;というのは、機械学習プログラムの出来としてどれほどのものなのかわかりません。学習効率を数値化して競う大会なんかがあっても面白いかなと思いました。ただ、麻雀ソフトなんかでもそうですが、三目並べだとズルをすれば簡単に強く出来るのでチェックが大変かもしれません。&lt;br /&gt;
　結局、ソフトウェアとしての出来の良さを競うのであれば、将棋や囲碁のように完全読み切りが不可能なゲーム（ズルが出来ないゲーム）を題材にして、強さを競うという形が分かり易く現実的なのかもしれません。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;前回の記事やこのテストではscore配列は小数に変更したので、小石という表現が当てはまらなくなっています。無理矢理石に例えるなら、小石を砕いて増やしたり減らしたりしているイメージでしょうか？ &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;乱数を使って指し手を選択させる機能（Tree.apply）を浮動小数点数（小数）に対応させるには少し工夫が必要でした。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;１０万回の対戦と言ってもその大部分は学習が進んでいない、初期の９割以上負けていた分の成績を取り戻すために費やされていて、細かく分けて対戦成績を確認すれば、もっと早い段階で９割７分の引き分け率に到達しているはずです。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>曲線回帰で強化を試みる</title>
   <link href="https://happyclam.github.io/software/2015-12-25/log-linear"/>
   <updated>2015-12-25T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2015-12-25/log-linear</id>
   <content type="html">&lt;h3 id=&quot;闇雲ってこういうことかも&quot;&gt;闇雲ってこういうことかも&lt;/h3&gt;
&lt;p&gt;　次に記事を書く時は別の話題にしようと思っていたのですが、三目並べの強化学習に関して試さずにはいられなかったので、闇雲と言われようが思いつくままにやってみたことを書いておきます。&lt;br /&gt;
　以前、&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;の中で序盤より終盤の手を重視する方法について記述されていることに触れました、そして今まで試した方法は報酬を与えるにしても罰するにしても選択した全ての局面で同じ値を加算したり減算したりしていましたが、今回は手数毎に違う値を加減算する方法を試してみました。&lt;/p&gt;

&lt;h3 id=&quot;終盤の手ほど重要視すべきpart-1&quot;&gt;終盤の手ほど重要視すべき？Part 1&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には以下のように書かれています。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;　動物が学習する手法をまねたい場合、ゲーム終盤近くの手が、ゲーム序盤よりも重大であるようなシステムに調整してもよい。これは行動が適切な時期に近いほど、その行動を強化する効果が最大になるという観察結果を反映することを意図したものだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　現時点の機械学習プログラムは、勝負がついた時点で局面を初期盤面まで遡りながら局面に配置されている小石（score配列）の数を増減させて学習効果を反映させる仕様です。勝った場合は、一つ手前の局面の９個ある配列データ（score配列）の内、選択した手の場所の値を増やして（報酬を与えて）次からもその局面では再度その手を選ぶ確率を上げるようにするわけです。そしてその前の局面、その前の局面と遡りながら同じように数値を加減算していきます。でも、&lt;a href=&quot;/software/2015-10-25/machine_learning&quot;&gt;以前の記事&lt;/a&gt;にも書きましたが、辿った全ての局面のデータを一律に同じ数だけ増やして（あるいは減らして）いくというのは確かに少し疑問を感じます。例えば相手の石が揃うのを防がなかったような場合、その手は大悪手であるにも関わらず、序盤の一手と同様の罰しか受けないわけで、感覚的にはそれでいいの？って感じです。だから、ここに書かれているように、報酬も罰も終盤ほど大きな値になるように調整してみました。&lt;br /&gt;
　まず、最終手が１になるように１を手数で割った値を係数にして、勝ちなら３負けなら−１を掛けた値を反映させるようにしてみました。x 手目の局面の報酬を決めるための係数を y で表します。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;y = \frac{1}{総手数} x \hspace{3.5em}\tag{方程式 1}&lt;/script&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　最短手数６（初期盤面を含む）で勝負がついたとすると、最終手番の局面は x = 6 で y = 1 となり、勝った場合は&lt;script type=&quot;math/tex&quot;&gt;y\times3=3&lt;/script&gt;、負けた場合は&lt;script type=&quot;math/tex&quot;&gt;y\times-1=-1&lt;/script&gt;の値を各局面のデータ（score配列）に加算します。その一つ前の手番のデータはx = 4, y = &lt;script type=&quot;math/tex&quot;&gt;\frac{4}{6}&lt;/script&gt;となり、勝ちなら&lt;script type=&quot;math/tex&quot;&gt;y \times3=2&lt;/script&gt;、負けなら&lt;script type=&quot;math/tex&quot;&gt;y \times -1=-0.6666&lt;/script&gt;が加算されます。&lt;br /&gt;
　例えば１０手（初期盤面を含む）で学習ソフトが勝ったとすると、最終盤面から初期盤面まで順番にソフトの手番の局面データに &lt;script type=&quot;math/tex&quot;&gt;3, 2.4, 1.8, 1.2, 0.6&lt;/script&gt;の値が加算され、終盤の局面ほど大きな報酬が与えられるわけです。&lt;br /&gt;
　総手数６手で終了した場合の係数（求める値 y は、あくまで３や−１に掛ける係数です）は以下の方程式で表され&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;script type=&quot;math/tex; mode=display&quot;&gt;y = \frac{1}{6}x \hspace{3.5em}\tag{方程式 1.1}&lt;/script&gt;

  &lt;table&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
        &lt;th style=&quot;text-align: right&quot;&gt;y&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.333&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.500&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.667&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.833&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;1.000&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;　グラフにすると下のようになります。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/linear.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/linear.png&quot; alt=&quot;回帰直線&quot; title=&quot;回帰直線&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　この状態での対戦結果は以下のようになりました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,334敗91,666分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;61,383勝26,053敗12,564分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　若干ですが最強プログラムとの対戦成績は向上したようですが、乱数プログラムとの対戦成績（＝学習効果）は悪化しました。&lt;/p&gt;

&lt;h3 id=&quot;終盤の手ほど重要視すべきpart-2&quot;&gt;終盤の手ほど重要視すべき？Part 2&lt;/h3&gt;
&lt;p&gt;　１０万回の対戦の途中経過を観察していないのではっきりとは言えませんが、終盤の手ほど重要視するようにはしてみたけど劇的に学習効果が上がるってわけでもなさそうです。でも、終盤を重要視すると言ってもPart 1 のように等間隔の増分でいいのでしょうか？１手目、２手目、３手目と等間隔で手の重要度が変化するとはとても思えません。相手のラインが揃うのを防がない手を選択して負けるケースなんかを考えると最終手は段違いに重要な気がします。&lt;br /&gt;
　ということで、指数関数的に指し手の重要度が増すと仮定して方程式を改造しました。総手数６手（初期盤面を含む）でゲームが終了したとするとPart 1 の方程式の値は以下のように等間隔で推移（ y の値）しますが、&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y (Part1)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.050&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.333&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.500&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.667&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.400&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.833&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.800&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.000&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.050&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　その横に y′ としてこんな感じになるんじゃないかという値を捏造して、その値をLibreOffice（Excelでも可）を使って回帰して得られた方程式が以下のものです&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;　&lt;script type=&quot;math/tex&quot;&gt;y = 0.029 \times 1.882^x \hspace{3.5em}\tag{方程式 2}&lt;/script&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　グラフは以下の青のラインです&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/log-linear1.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/log-linear1.png&quot; alt=&quot;曲線回帰、小&quot; title=&quot;曲線回帰、小&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　対戦結果は以下です。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,334敗91,666分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;61,383勝26,053敗12,564分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、小）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,863敗91,137分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;59,992勝25,810敗14,198分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　報酬や罰が等間隔で配分される線形関数の時より、対最強プログラムも対乱数プログラムも勝率が落ちてしまいました。でも最強プログラムとの対戦成績に関しては「従来の強化学習」よりいい成績なので、この時点では一応効果はあると思っていました。&lt;/p&gt;

&lt;h3 id=&quot;終盤の手ほど重要視すべきpart-3&quot;&gt;終盤の手ほど重要視すべき？Part 3&lt;/h3&gt;
&lt;p&gt;　指数曲線にした方が勝率（というか引き分け率）が落ちてしまったのは回帰曲線が線形関数を下回っているのがよくないのかと思って、もう一度値を弄って重みを掛ける係数の値が線形関数の上にくるようにしてみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y (Part1)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′(Part2)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′′&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.050&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.300&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.333&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.100&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.480&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.500&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.200&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.750&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.667&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.400&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.833&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.800&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.920&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.000&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.050&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.030&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;　&lt;script type=&quot;math/tex&quot;&gt;y = 0.188 \times 1.588^x \hspace{3.5em}\tag{方程式 3}&lt;/script&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　グラフは以下です&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/log-linear2.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/log-linear2.png&quot; alt=&quot;曲線回帰、大&quot; title=&quot;曲線回帰、大&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　対戦結果。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,334敗91,666分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;61,383勝26,053敗12,564分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、小）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,863敗91,137分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;59,992勝25,810敗14,198分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、大）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝11,075敗88,925分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,216勝23,404敗12,380分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　さらに悪化してしまいました(/_;)　でも対乱数プログラムでは改善しています。対乱数プログラムで勝率がアップしたのは係数を大きな値にしたことが素直に反映されたのだと思います。&lt;br /&gt;
　しかし、対最強プログラムの場合では相手は絶対負けないので勝ち点３を得る機会がないので指数関数で係数を大きくしてもあまり恩恵を受けなかったということでしょう。しかも、係数を大きな値にしたために小石（score配列）を補充する際のデフォルト値を１０から２０に増やす必要があったのです（小石の数がマイナスにならないよう）が、それがよくなかったのだと思います。&lt;a href=&quot;/software/2015-10-25/machine_learning&quot;&gt;以前の記事&lt;/a&gt;にも書いたように小石の総数を増やすと学習効果が上がらなくなるのです。&lt;br /&gt;
　もう一つ問題があります。ここでは総手数が６手で終了する場合のデータをもとに作成した回帰方程式を、全ての対戦に使用しています。本来なら総手数毎に動的に計算（LibreOfficeやExcelのgrowth関数のようなものを自作する必要あり？）しなければいけないところを取り敢えず６手の場合で作った方程式を流用して手抜きしているのでよくありません。いい結果に繋がりそうなら追求してみようかと思ってましたが、やってみる価値は無さそうです。&lt;/p&gt;

&lt;h3 id=&quot;終盤の手ほど重要視すべきpart-4&quot;&gt;終盤の手ほど重要視すべき？Part 4&lt;/h3&gt;
&lt;p&gt;　終盤ほど報酬を多くして報酬の総数はなるべく増やさずに曲線で回帰するにはどうすればいいのか考えた結果、対数グラフにしてみました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/logarithm.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/logarithm.png&quot; alt=&quot;対数方程式&quot; title=&quot;対数方程式&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　「一手の重要度が等間隔で変化するはずがない」から「曲線で推移するはずだ」けど「報酬が増え過ぎると学習効果が薄れる」から「対数関数にしてみよう」という、形から入っただけというかなんとも根拠が薄い感じがしますが、もしかしたらいい結果が出るかもしれないと期待しました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y (Part1)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′(Part2)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′′(Part3)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′′′&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.050&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.300&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.333&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.100&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.480&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.553&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.500&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.200&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.750&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.780&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.667&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.400&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.200&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.940&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.833&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.800&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.920&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.065&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.000&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.050&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.030&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.167&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　それに方程式 2 や方程式 3 の指数関数と違ってこの方程式のいいところは、根拠のない数値から回帰したものではないところです。線形関数の方程式 1 と同様に、総手数と何手目かという変数 x だけで値が決まります。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;　&lt;script type=&quot;math/tex&quot;&gt;y = \frac{1}{総手数} + \log{x} 総手数 \hspace{3.5em}\tag{方程式 4}&lt;/script&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　根拠がある、無いの話をしだすと、勝ちの時は３を掛けて引き分けは１を掛けるというのはどういう根拠なの？となりますが、これは&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;に書いていたのと、Jリーグなどの多くのスポーツで勝てば勝ち点３、引き分けで勝ち点１となっているので何か（経験則的な？）根拠があるのだろうと思います。&lt;br /&gt;
　で、対戦結果は以下のようになりました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,334敗91,666分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;61,383勝26,053敗12,564分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、小）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,863敗91,137分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;59,992勝25,810敗14,198分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、大）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝11,075敗88,925分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,216勝23,404敗12,380分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（対数関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,799敗89,221分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,706勝22,489敗10,805分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　なぜか乱数プログラムに対する勝率はさらに向上しましたが、最強プログラムとの対戦成績は直前の指数関数よりはちょっとましになっただけで、全体として「従来の強化学習」と似たような結果に終わっているので期待はずれでした。この「従来の強化学習」をあらためて説明すると、勝ちは＋３、引き分けは＋１、負けは−１の値を序盤、終盤関係なく全ての辿った局面データに一律に加減算する強化方法です。いろいろ弄ってみて結局「元の木阿弥」という感じですが、最強プログラムとの対戦成績に関しては終盤に重きを置くことの意味はありそうです。でも、なんで報酬を等間隔に配分した線形方程式（直線）の方が良い成績になるのかは未だに疑問です。&lt;br /&gt;
　つづく&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;intercept関数とslope関数を使って x と y の表の範囲を指定すれば係数と切片（定数項）が得られます。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>強化学習の修正</title>
   <link href="https://happyclam.github.io/software/2015-11-27/reinforcement"/>
   <updated>2015-11-27T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2015-11-27/reinforcement</id>
   <content type="html">&lt;h3 id=&quot;学習型三目並べプログラムの補足&quot;&gt;学習型三目並べプログラムの補足&lt;/h3&gt;
&lt;p&gt;　３回に渡って学習機能を持った三目並べプログラムに関する記事を書きましたが、２つの事柄について補足しておこうと思います。一つは&lt;a href=&quot;/software/2015-10-19/multi_branched_tree&quot;&gt;前々回の記事&lt;/a&gt;で触れた多分木データに格納する局面の数をどれぐらいまで絞れるのかという点と、&lt;a href=&quot;/software/2015-10-25/machine_learning&quot;&gt;前回の記事&lt;/a&gt;で負けても罰を与えない仕様にしたことについてです。&lt;/p&gt;

&lt;h3 id=&quot;287個の根拠は不明&quot;&gt;287個の根拠は不明&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;マッチ箱２８７個&lt;/strong&gt;&lt;br /&gt;
　各マッチ箱には、小さい引き出しがあり、開けることができる。Michieは、各マッチ箱にラベルを貼った。このラベルには、３目並べで考えられる２８７の異なる盤面が描かれている。実際はもっと多くのパターンがあることになるが、３行×３列構成の標準的な３目並べのレイアウトは上下左右を入れ替えても同じ内容なので、４つの異なるパターンを１つに集約できる。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には上記のように書かれているので多分木データとして保持する必要がある局面の数は回転・対称形をとことん省いていけば6,046から287に絞れるのかと思って縦・横・斜めの対称形とそれぞれの局面を90度ずつ回転させた局面を省いてみても626局面までにしか絞れませんでした。どうすればいいのか見当がつかなかったのでネットで検索してみたところ&lt;a href=&quot;https://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;「数学パズルにトドメをさす？！」&lt;/a&gt;と称するサイトを見つけました。そのサイトからダウンロードできる「三目並べの局面一覧」というファイルを確認してみると、すべての局面の数は447になるとのことです。私が計算した数とどこで食い違うのかを確認してみたのですが、どうやらこのデータはお互いに最善手を打つことを前提にしているようです。このサイトの注意書きに「自分や相手のリーチを見逃さない」と書いてありますが、局面を数えるときに先手・後手のお互いが最善手を選択することを前提にして（おそらく&lt;a href=&quot;/software/2014-09-16/ab_method&quot;&gt;MIN−MAX法&lt;/a&gt;を使った深さ優先探索を使って）数えているのでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |X|O|3|
 |X|O|6|
 |7|8|9|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　例えば上のような局面は相手のリーチ（あと一手で駒が揃う状態）を防がなかった時にしか発生しません。お互いが最善手を選択することを前提にすると、絶対現れない局面として省いているようです。&lt;br /&gt;
　でも機械学習プログラムの多分木データとして用意する局面データは発生し得るすべての局面を用意しておく必要があります。例えば乱数プログラムと対戦するときなどは、あと一手で一列揃うような時でも見逃すことはよくあるので、そういう時に最善手を打つことを前提にした局面しか用意していないと、まさに打つ手が無くなってしまいます。&lt;br /&gt;
　だから本に書いてある２８７個の局面というのは、おそらく&lt;a href=&quot;https://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;上記サイト&lt;/a&gt;のように局面の先読みすることを考慮すれば２８７個にまで省略出来るということだと思います。&lt;a href=&quot;https://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;上記サイト&lt;/a&gt;では特に局面の数を減らすことを目的にしていないと思いますが、探せば「ここまで局面が進行すれば、相手がどう応じても引き分けに持ち込める」という感じの局面が相当数存在するのだと思います。例えば「自分がダブルリーチをかけたら勝ちが確定する」からそれ以後の局面は用意しなくてもいいというのも一つの例として挙げることができます。そういった手法で先読みを考慮してとことん局面を絞ればまだまだ省略可能な局面が存在するということでしょう。でも、そこまで考慮して事前に用意する局面を絞って学習プログラムを作ると前述したように指し手が選択できないケースが生じてしまいます。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;に例え話で書かれているように、無人島で人間が判断して局面を省略する分には問題ありませんが…。&lt;br /&gt;
　と、いうことで苦労して多分木データに格納する局面数を絞っても学習プログラムには使えないので追求するのはここまでにしました。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;この本&lt;/a&gt;は結構根拠を示さずに結論を書いているところがあるので、２８７という数字が、ちゃんと裏を取った根拠のある数字じゃない可能性もありますが私には何とも言えません。&lt;br /&gt;
　根拠がある数字と言えば、&lt;a href=&quot;/project/2015-10-10/tictactoe_bfs&quot;&gt;以前の記事&lt;/a&gt;で、３手目までを重みによる評価関数を使いそれ以降はDFSによる読み切り関数を使ったことを書きましたが、３手目までなら重みによる評価関数を使用しても負けないことを確認したからそうしたわけですが、４手目まで重みによる評価関数を使えば負けてしまうことがあるが、３手目までなら負けないようにすることが出来ることを、根拠を示して証明するのは結構大変です。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;件の本&lt;/a&gt;も、いちいち根拠を示していたら紙面が足りなくなるという事情があるのかもしれません。たかが三目並べでも突き詰めていくと奥が深いということでしょう。&lt;br /&gt;
　&lt;a href=&quot;https://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;件のサイト&lt;/a&gt;では「３目並べず&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;」のデータとして最善手を選択することを前提としていないデータも用意してあって、そのファイルでは私が数えた626に近い数になっています（以下に比較表を用意しました）。でも私が数えたときの前提条件は「既に勝負がついた局面は省く」というものなので、微妙に数値が異なっています。私は機械学習プログラムで使用する多分木データに必要なデータということで考えているので、例えば９箇所すべてが埋まっている局面のデータはすでに勝ちか負けか引き分けかの勝負がついた局面なので、必要がないため９手目の局面は０になっています。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;手数 \ 前提条件と局面の数&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　三目並べるために最善を尽くす&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　三目並べたら負け&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;ゲームが終了していない全局面&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;54&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;108&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;108&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;88&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;153&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;153&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;109&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;183&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;183&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;96&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;102&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;95&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;47&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;34&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;計　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;447&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;661&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;626&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;/pdf/aspects.txt&quot;&gt;三目並べのすべての局面データ（ X が先手、回転・対称形は同一局面と見做して除く）&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;信賞必罰が基本だけど目的を間違えてはいけない&quot;&gt;信賞必罰が基本だけど、目的を間違えてはいけない&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2015-10-25/machine_learning&quot;&gt;前回の記事&lt;/a&gt;で石の数が足りなくなるのを防ぐために負けても罰を与えない（石を減らさない）仕様にしたところで終わりました（勝ちが＋３、引き分けが＋１、負けが±０）が、やはりこれはよくないと思い直しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |X|X|3|
 |4|O|6|
 |7|8|9|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　例えば上記の局面で O の手番だとすると、負けないためには”3”の場所に打つしかありません。この局面のscore配列は以下のように”3”の場所以外は 0 になっている状態が理想です&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
 [nil, nil, 15, 0, nil, 0, 0, 0, 0] 
&lt;/div&gt;

&lt;p&gt;　でも負けても石を減らさない仕様だと、初期値でセットした石は永遠に残り続けるので理想の状態には絶対になりません。長い期間学習が強化され続けて、最善手（相手の石が揃うのを防ぐ手）を選ぶ確率がどんどん高くなっていっても石が残っている限り絶対１００％にはならないわけで、これは良くないと考えたわけです。&lt;br /&gt;
　しかし、よくよく考えてみると「この局面ではこの一手」というような手を指させたいのならその局面のscore配列を最初から上記のようにセットしておけばよい話で、なぜ学習させる必要があるのだろうという話になってきます。多分木データを生成する段階で、「次の一手で相手が石を揃えることが出来る」局面ではその箇所だけ１以上の値をセットしてそれ以外の箇所は０をセットしておけばいい話です。&lt;br /&gt;
　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には以下のように書かれています。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;　明確な改善は、間違った手を許さないことで、コンピュータを賢くする。つまり、ココナッツの中に、すぐに負けにつながるような小石を入れないことだ。この方法は、使用開始当初のコンピュータの弱さを改善できるが、実際は動物の学習方法を反映していない。よって、この方法で強い対戦相手が生まれても、教授は、このコンピュータの開発者が科学的な精密さを欠くことに失望するだろう。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　つまり、予め打たせたい手の場所にだけ小石（score配列）をセットしておくことは、いくらプログラムが強くなるとしても「学習プログラム」としての意味がなくなるということだと思います。プログラムを強くしたいだけなら「次の一手で相手の石が揃う」局面の他にも「次の一手で自分がラインを揃えることが出来る」局面ではそこしか選ばないように小石をセットしておけばいいし、先読み機能を付加して「ダブルリーチを狙える局面」では必ずその手を選ぶように小石をセットする方法も考えられます。でもこれらの方法は学習機能が無いプログラムがやっていることと同じで、本末転倒になっています。こういう方法は将棋プログラムで言えば定跡データを登録する作業に似ていると思います。学習しながら定跡データを更新してるからこそ「学習プログラム」と言えるわけで、予め定跡データをセットしておいて変更しないのなら「学習プログラム」とは言えません。&lt;/p&gt;

&lt;p&gt;　ということで、とりあえず負けたら石を一つ減らして、もし減らすべき石が足りなくなったらその都度石を補充する仕様に変更しました。補充するときは足りなくなった箇所の石だけでなく９箇所全てに同数（１０個）ずつ補充します。そうしないと１箇所だけ補充してしまうと勝った時の報酬を受け取った形になってしまうので当然こうすべきところです。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;対戦成績　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面の石の数&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[38, 36072, 11, 118, 10969, 56, 5, 527, 2]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[15050, 661, 4994, 5244, 52116, 2807, 9438, 3320, 15726]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　前回同様に最強プログラムと乱数プログラムとそれぞれ１０万回ずつ対局させた結果も前回の結果よりよくなったのでとりあえずこれで良しとします&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。足りなくなれば小石を補充する仕様なので、結局いつまで経っても最初に言った理想の状態にはならないわけですが、前述の通り「学習プログラム」としてはこれで良しってことです。&lt;/p&gt;

&lt;h3 id=&quot;まとめ&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　三目並べの「学習プログラム」を強くしようとすればするほど、本末転倒な作業に帰結してしまうのは、ひとえに三目並べというゲームが既に正解がわかってしまっているゲームだからだと思います。一般に機械学習機能を使って学習させたいものは未知のものであるからこそプログラムに学習させて何らかの答えを導き出したいわけで、既に答えがわかっているのならそれを選ばせればいいだけです。だから三目並べの機械学習プログラムの題材としての役割は、かなり限定的だということでしょう。&lt;br /&gt;
　ということで次作るとすれば「オセロ」か「ミニ将棋」辺りを対象にして機械学習プログラムを作ってみようと思います。将棋であれば学習すべき特徴量（「玉の固さ」、「駒の働き」、「駒の損得」等）も多いので三目並べより工夫しがいがありそうですし、三目並べでもまだまだ学習効果を上げる工夫の余地があるのは分かっていますが、完全読み切りが可能なゲームだとやり甲斐もあまりありませんので実験はもう充分って感じです。&lt;br /&gt;
　でも、何かを試すときにその前段階としてまたこの三目並べプログラムを弄ることがあるかもしれません。そうしているうちにこの三目並べプログラムが「三目並べ」の新たな特徴量を発見することは無いと思いますが…。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;「三目並べず」とは一体何のことか分からなかったのですが、&lt;a href=&quot;https://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;このサイト&lt;/a&gt;では、三目並べたら勝ちとなる（従って三目並べるために最善を尽くす）ゲームを「三目並べ」、相手に三目並べさせたら勝ちとなるゲームを「三目並べず」としているようです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/software/2015-10-25/machine_learning&quot;&gt;前回の記事&lt;/a&gt;で駒が打てない場所は 0 にしていましたが、今回から nil に変更しています。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/software/2015-10-25/machine_learning&quot;&gt;前回の記事&lt;/a&gt;の結果と同様に、最強プログラムとの対戦後のscore配列の状態は、初期盤面で真ん中（”5”）より”2”の位置の値が大きくなっていますが、これは対戦に使用した最強プログラムが一切乱数を使用していないため、特徴的な指し手（毎回同じ勝ち手順）を選んでいるのが原因だと思います。完全読み切り必勝プログラムでもいろいろな勝ち手順をランダムに選択するようにすればいいのですがそこまではやってません。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>算数で作る機械学習プログラム</title>
   <link href="https://happyclam.github.io/software/2015-10-25/machine_learning"/>
   <updated>2015-10-25T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2015-10-25/machine_learning</id>
   <content type="html">&lt;h3 id=&quot;新たに必要になった機能&quot;&gt;新たに必要になった機能&lt;/h3&gt;
&lt;p&gt;　前回の続きです。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;の内容に沿って機械学習機能を付加した三目並べプログラムを作成したのですが、元々あった三目並べ対戦プログラムに対してどんな作業が必要だったのか、新たに付加した機能を列挙してみます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;多分木データ&lt;/strong&gt;（Player.trees）&lt;br /&gt;
　&lt;a href=&quot;/software/2015-10-19/multi_branched_tree&quot;&gt;前回の記事&lt;/a&gt;で用意した全局面分のデータです。学習データを利用して手を決めることになるので評価関数は不要になりました。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;学習機能&lt;/strong&gt;（Player.learning）&lt;br /&gt;
　勝った時は報酬を与えて（石の数を増やす）負けたら罰を与える（石の数を減らす）ことで学習効果を上げていくわけですが、&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には勝ちと引き分けに差をつけて、勝ちは＋３、引き分けは＋１がいいと書いてありますのでその通りにしています。そして、そこには負けた場合どうすればいいのか書いてありませんが、負けたら石を海に投げ込むという描写もあるので−１でいいだろうと思い負けは−１にしています。もしかしたら±０でいいのかもしれませんし、逆に負けを−３にする方法もありそうですがこの辺りは評価関数の調整と同じでキリがないのでとりあえずの値です。&lt;br /&gt;
　それと、実際に着手した局面の一手前の石の数（score配列）を操作するということに注意が必要です。&lt;br /&gt;
&lt;img src=&quot;/images/battle_ex1.png&quot; alt=&quot;例１&quot; /&gt;&lt;br /&gt;
　各局面が持っている石の数（score配列）はその局面で打てる場所に存在し次の手を決めるためにあるので、ソフト側が先手（X）で上記のような経過を辿って負けた場合、５手目の局面でOが揃うのを防がなかったのが悪かったということで、一つ前の４手目の局面の石（score配列）を−１します。４手目の局面で先手（X）が”2”（配列の添え字は1）を選ばずに”6”を選んだことが負けの原因なので”6”の位置のscore配列の値を−１します。score配列の初期値は[10,10,10,10,10,10,10,10,10]なので、４手目の局面のscore配列を[10,10,10,10,10,9,10,10,10]にするということです。同様に２手目で”7”を選んだことが悪かった、０手目（初期盤面）で”5”を選んだことが悪かったと評価して２手目のscore配列を[10,10,10,10,10,10,9,10,10]、０手目のscore配列を[10,10,10,10,9,10,10,10,10]にして次回からその局面でその手が選ばれにくくなるようにします。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ファイル入出力機能&lt;/strong&gt;（Player.prepare、Tree::read、Tree::save）&lt;br /&gt;
　&lt;a href=&quot;/software/2015-10-19/multi_branched_tree&quot;&gt;前回の記事&lt;/a&gt;のスクリプトの例でinitメソッドとしていましたが、他でも使用しているのでprepareメソッドに名前を変えました。起動時にTreeオブジェクトのシリアライズデータ（trees.dump）がカレントディレクトリにあればそれを読み込み、無ければBFS探索で重複局面を省いた三目並べの全局面のツリーデータを生成します。オブジェクト指向言語には必ず用意されているシリアライズ機能はオブジェクトを丸ごと保存できるので便利です。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;指し手選択機能&lt;/strong&gt;（Tree.apply）&lt;br /&gt;
　指定された局面を探し出して、その局面で選択可能な手毎に用意されている石ころの数（score配列の値）によって指し手を選ぶわけですが、いつも一番石ころが多い手を選ぶわけではありません。&lt;br /&gt;
　「その箇所にある石の数（score配列の値）／その局面の石の総数（score配列の合計値）」&lt;br /&gt;
の頻度で指し手が選ばれるようにします。石ころの数が増えればその手が選ばれる頻度が上がる仕掛けです。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;指し手の履歴&lt;/strong&gt;（Game.history）&lt;br /&gt;
　ゲーム終了後に指し手の評価をするために必要になりました。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;直近の指し手&lt;/strong&gt;（Board.move）&lt;br /&gt;
　これもゲーム終了後に指し手の評価をするために必要になりました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;指し手選択機能について&quot;&gt;指し手選択機能について&lt;/h3&gt;
&lt;p&gt;　指し手の選択機能は、指し手を無作為に選択するわけですが、石ころの報酬を受け取る（score配列の値が増加）ことによって学習し、徐々に良い手（score配列の数値が大きい手）を選択する確率を上げていくという仕様です。石ころの総数から乱数を生成して、その値から指し手（９箇所のマス目）の配列の添え字をダイレクトに導くデータ構造はどうすればいいのか、そして選んだ添え字の場所が打てる場所なのかどうかも判断しなければなりません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def idx(score)
    ret = nil
    index = rand(score.inject{|sum, n| sum + n})
    start = 0
    score.each_with_index{|v, i|
      start += v
      if start &amp;gt; index
        ret = i
        break
      end
    }
    return ret
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　最初は９箇所にそれぞれ石を持っているのだから２次元配列を使うのかとかMatrixを使えば変換できるかとか難しく考えたのですが、一番シンプルな一次元配列のまま、コンストラクタで打てる場所かどうか（打てない場所は０をセットしておく）を判断し、指し手選択時にscore配列分の９回ループするだけで添え字を求められることに気がついてこれはいい！と思いました。９箇所のマス目の内、打てない場所（既に駒がある場所）のscore配列の値を０にしておくことで、インクリメントに影響を与えないのがミソです。だから石の数（score配列）がマイナスになると動きがおかしくなります。&lt;/p&gt;

&lt;h3 id=&quot;学習効果&quot;&gt;学習効果&lt;/h3&gt;
&lt;p&gt;　以前RubyとShoesでGUIの将棋ソフトを作った時は&lt;a href=&quot;https://morizyun.github.io/blog/ruby-design-pattern-03-Observer/&quot;&gt;Observerパターン&lt;/a&gt;を使ってソフト同士の対戦を眺めて楽しめるように作った&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;のですが、三目並べは一瞬で勝負がつくし見学しても楽しくないのでCUIでループで回してソフト同士対戦させて学習効果がどの程度出るのか確認してみました。&lt;br /&gt;
　乱数で手を選択する弱いプログラムと、これまでに&lt;a href=&quot;/project/2014-08-05/tictactoe&quot;&gt;記事で紹介していたDFS探索アルゴリズム（αβ法）を使った最強プログラム&lt;/a&gt;（絶対負けることがない）との対戦結果です。１００回の対戦を１回として１０回戦までの結果が以下の通りです。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;回 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝91敗 9分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;42勝44敗14分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝88敗12分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;51勝35敗14分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝83敗17分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;41勝42敗17分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝74敗26分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;41勝49敗10分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝62敗38分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;44勝49敗 7分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝60敗40分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;51勝41敗 8分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;36勝53敗11分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;44勝42敗14分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;42勝40敗18分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;48勝43敗 9分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　まず表の右側の乱数プログラムとの対戦結果を見ると、それほど勝率は上がってなさそうですが、上記１０００回の対戦後に初期盤面のscore配列の値を確認すると&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
 [94, 32, 137, 98, 160, 95, 98, 84, 97] 
&lt;/div&gt;

&lt;p&gt;になっていました。９箇所のマス目の真ん中の値が160と最大になっていて、初期盤面で真ん中を選べば有利なことを学習しているように見えます。それでも勝率が伸びていないのは弱い相手と戦ってもあまり学習効果が得られないということでしょうか？&lt;br /&gt;
　それに対して左側の最強プログラムとの対戦ではどんどん負け数が減って強くなっている（三目並べはお互いに最善手を差し続ければ引き分けになるゲームなので、最強プログラムに対して０勝なのは仕方ありません）のがわかります。でも６回戦の途中から出現頻度の高い局面の石の数（score配列の値）が足りなくなっていたようで、動きがおかしくなったので中断しました。&lt;br /&gt;
　石の初期値が１０個で足りなくなるのなら増やせばいいじゃないかという話ですが、石の数を増やすと分母が大きくなるわけですから学習効果が薄くなります。初期値を１０個にしていたからこそ早く学習効果が出たとも言えるわけなので、この辺りはどうするのが一番いいのかわからなかったのですが、これについては後で書きます。&lt;br /&gt;
　ちなみに石の数（score配列）のどれかが０になるのがよくないわけではありません。[0,0,200,0,0,0,0,0,0]のような一箇所に石が集中した状態でも、その局面で唯一絶対の手だと学習したということなので問題ありません。極端な話、一箇所だけに一個しか石がない状態[0,0,1,0,0,0,0,0,0]でもそれが学習した結果であればいいのですが、すべてが0だと手の選びようがなくなるのでよくありません。&lt;br /&gt;
　とりあえずTreeクラスのコンストラクタに石の個数の引数を加えて、出現頻度が高い局面（初期盤面と一手目の局面）だけは石の初期値を５０にして、石が足りなくならないようにして、学習データを削除（trees.dumpファイルを削除）してからあらためて今度は２０００回対戦させてみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;回 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝88敗12分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;41勝50敗9分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝86敗14分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;44勝44敗12分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝90敗10分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42勝40敗18分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝83敗17分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;40勝38敗22分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝87敗13分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42勝43敗15分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝89敗11分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;47勝41敗12分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝81敗19分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;47勝46敗7分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝79敗21分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;45勝42敗13分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝88敗17分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;45勝45敗10分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝75敗25分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;45勝44敗11分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝68敗32分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42勝45敗13分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝64敗36分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;41勝45敗14分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝70敗30分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;51勝37敗12分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝64敗36分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;49勝45敗6分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝68敗32分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;51勝30敗19分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝70敗30分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;41勝50敗9分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝54敗46分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42勝41敗17分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝63敗37分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;53勝41敗6分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝57敗43分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;41勝44敗15分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝55敗45分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;50勝34敗16分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　最強プログラムとの対戦ではやはり良好な学習効果が得られているように見えます。&lt;br /&gt;
ちなみにこの２０００回対戦後の初期盤面の石の数（score配列の値）は、乱数プログラムの方は&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
[282, 135, 219, 252, 357, 132, 270, 96, 277]  
&lt;/div&gt;
&lt;p&gt;で、やはり真ん中が最大値になっていました。&lt;br /&gt;
　最強プログラムの方は&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
[14, 165, 8, 22, 81, 20, 5, 92, 1]  
&lt;/div&gt;
&lt;p&gt;で真ん中は３番目で、なぜか上辺（２の位置）が一番大きな値になっていたのですが、理由はよくわかりません。&lt;/p&gt;

&lt;h3 id=&quot;最後に&quot;&gt;最後に&lt;/h3&gt;
&lt;p&gt;　石が無くならないようにするために、出現頻度の高い初期盤面（１局面）と一手目の局面（９局面）の石の数を５０にしたわけですが、５０という値には根拠がないですし、なんとなくすっきりしないので、負けたら−１という仕様を変更して、&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;本&lt;/a&gt;の主張とは少し違ってきますが、負けても罰しない仕様（勝ちは＋３、引き分けは＋１、負けたら±０）で試してみました。これなら石が無くなる心配もないしマジックナンバーが減ります。初期値は一応１０で試しましたが、石が無くなる心配がないので１以上ならなんでもいいと思います。デスクトップPCで一晩かけて１０万回対戦させてみました（もちろんtrees.dumpファイルを削除してから開始しています）。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;対戦成績　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝18,234敗81,766分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;58,971勝30,103敗10,926分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面の石の数&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[537, 27512, 55, 4045, 9444, 297, 50, 3927, 37]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[10779, 2666, 16245, 11403, 22578, 7644, 25519, 6646, 5529]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　最強プログラムとの対戦成績は８割以上引き分けるようになりました。負けを−１しなくても学習効果は今までのプログラムと同様の効果が出ているように見えます。乱数プログラムとの対戦成績も６割近くに伸びているのでもっと回数を増やせばいいのかもしれません。&lt;br /&gt;
　学習機能の説明のところで勝負に負けたからといって一律に全ての局面から減点（石を減らす）していくという仕様に違和感を感じた人もいると思いますが、私も&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;本&lt;/a&gt;に書いていたから最初はそうしてみたけど勝負に負けたからといって初手にどれほどの影響力があるのか疑問です。その意味でも負けた時は±０というのは理にかなっていると思います。但し、直接負けに繋がった一手は罰するべきかもしれません。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;本&lt;/a&gt;にも序盤より終盤の手を重視する方法が紹介されています。まだまだ学習効果を上げる方法も学習機能の仕様を変える余地も大きく、検証方法もいろいろ考えられるので、また何かアイデアを思いつけばこのプログラムを使って記事を書くかもしれません。&lt;br /&gt;
　今回のソースは別ブランチ（machinelearning）を作りました。以下のコマンドでブランチ指定してソースを取得することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone -b machinelearning https://github.com/happyclam/tictactoe_ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;本来の使い方とは違うかもしれませんが、一方が一手指したらその通知を受け取ってもう一方が一手指すというような作りにしていました。またもう一箇所、双方が手を指した通知を受け取って棋譜を更新する部分もObserverを使用していました、これは本来の使い方と言えるでしょう。一つのプログラムで２種類のオブザーバーが問題なく動きました。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>対戦型ソフトでの幅優先探索（BFS）の使い途</title>
   <link href="https://happyclam.github.io/software/2015-10-19/multi_branched_tree"/>
   <updated>2015-10-19T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2015-10-19/multi_branched_tree</id>
   <content type="html">&lt;h3 id=&quot;無作為選択を人工知能に&quot;&gt;無作為選択を人工知能に&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「Statistics Hacks」&lt;/a&gt;という本の中でココナッツの殻と石ころを使って、学習機能を持つ三目並べプログラムが作れるという話が書かれていました。無人島に漂流して何もすることがない人の暇つぶしのためにどうぞという感じで、非常に砕けた調子で書かれているのです（この本全体がそんな感じです）が、一応裏を取った根拠のある話が書かれている真面目な本だと思います。そして&lt;a href=&quot;/project/2015-10-10/tictactoe_bfs&quot;&gt;前回の記事&lt;/a&gt;で書いたようにBFSアルゴリズムの使い途を考えていた私は「これは使える」と思いました。この本で三目並べについてに書かれている部分はほんの数ページだけなのですが、難しい数式を使っていないので、書かれている内容（アイデア）だけでプログラム作成に必要な情報は十分にあると自分には思われました。但し、その結果強いプログラムが完成するかどうかはやってみないとわからないし、強くなるとしてもどの程度強くなるのか興味が湧いてきたので試してみることにしました。&lt;/p&gt;

&lt;h3 id=&quot;多分木構造に全局面データを格納&quot;&gt;多分木構造に全局面データを格納&lt;/h3&gt;
&lt;p&gt;　とりあえずBFSで全局面を探索しながら多分木構造のデータを生成し、DBは使わずそのデータをシリアライズして保存（RubyのMarshal.dump）して利用するという方針だけ決めて作業にかかりました。&lt;br /&gt;
　以下のようなTreeクラスを用意して既に使っているBoardオブジェクト（１局面分のデータ）を格納していきます。メンバー変数valueにデータ（今回はBoardオブジェクト）を格納して、分岐する局面をメンバー変数childに格納していきます。メンバー変数scoreというのは手の良し悪しを評価する得点のことで、&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;上記の本&lt;/a&gt;に書いてある石ころの報酬にあたります。それぞれの局面で三目並べの９個のマスに得点（石ころの数）をつけて初期値としてとりあえず１０をセットしています。そして勝ち負けに応じて数（石ころの数）を増やしたり減らしたりして良い手悪い手を学習させるつもりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;class Tree
  attr_reader :value, :child, :score
  def initialize(v, c=[])
    @value = v
    @child = c
    @score = v.clone
    @score.map!{|v|
      unless v
        v = 10
      else
        v = 0
      end
    }
  end

  #一つ目のパラメータで指定された局面データ（親）を探して、その子ノードとしてオブジェクトを追加する
  def add(target, obj)
    ret = nil
    @child.each_with_index { |c, i|
      if c.value == target
        ret = c.child.push(obj)
      else
        ret = c.add(target, obj)
      end
      break if ret
    }
    return ret
  end
  #指定された局面のノードを返す
  def search(v)
    ret = nil
    @child.each { |c|
      if c.value == v
        ret = c.value
      else
        ret = c.search(v)
      end
      break if ret
    }
    return ret
  end
  #動作確認用
  def parent(v)
    ret = nil
    @child.each { |c|
      if c.value == v
        ret = @value
      else
        ret = c.parent(v)
      end
      break if ret
    }
    return ret
  end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　データを作る段階で９箇所のうち駒が打てない場所（すでに駒が存在する場所）のscoreは０をセット（石ころを置かない）しておいて、プラス評価（石ころを増やす）の上限は無いが、マイナス評価（石ころを海に向かって投げる）するときは０未満のマイナス値にはならないように作ります。こうした方が石ころをマイナス個置くなんて現実にはあり得ないということで、本の物語にも沿っていて理解しやすいかもしれません。&lt;br /&gt;
　データを操作するのは常に木構造の根（ルート,root）から再帰関数を呼び出す形になるので特徴的でシンプルなコードになります。今回はscoreという特殊な要素も付加したのでこのTreeクラスは汎用的なものではなくなってますが、使用するメソッドは多分木を使う時は常に似たような感じ（再帰関数ばかり）になるんじゃ無いでしょうか。&lt;/p&gt;

&lt;h3 id=&quot;いい加減な数値検証&quot;&gt;いい加減な数値検証&lt;/h3&gt;
&lt;p&gt;　手始めに&lt;a href=&quot;/project/2015-10-10/tictactoe_bfs&quot;&gt;前回の記事&lt;/a&gt;で作成したbfsメソッドと上記Treeクラスを使って三目並べの局面がどれほどの数になるのか数えようと思い重複チェック（check_dupメソッド）を外して試してみたところ、いつまで経っても処理が終わりません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;    board = Board.new([nil, nil, nil, nil, nil, nil, nil, nil, nil])
    trees = Tree.new(board)
    while queue != [] do
      buf = queue.shift
      layer = 9 - buf.select{|b| !b}.size
      buf.each_with_index {|b, i|
        next if b
        temp = buf.clone
        temp[i] = buf.teban
#        next if check_dup(temp)
        case layer
        when 0
          trees.child.push(Tree.new(temp))
        else
          trees.add(buf, Tree.new(temp))
        end
        temp.teban = (buf.teban == CROSS) ? NOUGHT : CROSS
        set_dup(temp); queue.push(temp)
      }
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　仕方なくオブジェクトの作成（newするところ）をコメントにしてカウンターだけ回してみたところ局面の数はなんと986,409となりました。なんとなく最大でも9!（=362,880）で収まると思っていたのですが、この986409という数はどうやら&lt;script type=&quot;math/tex&quot;&gt;{}_9 P _1 + {}_9 P _2 + {}_9 P _3 \\&lt;/script&gt;…&lt;script type=&quot;math/tex&quot;&gt;{}_9 P _9 \\&lt;/script&gt;＝（9 + 72 + 504 + 3024 + 15120 + 60480 + 181440 + 362880 + 362880）ということのようです。三目並べ程度のゲームなら静的な配列でもいいかなと思っていたのですがとんでもなかったです。&lt;br /&gt;
　重複局面を省いて（check_dupメソッドを有効にして）ツリーを生成したところ、局面の総数は初期局面を含めて6,046個になりました。詳細は以下の通りです。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;手数 \ 重複チェック&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　有り　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　無し　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;252&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;504&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;756&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3,024&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15,120&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,680&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;60,480&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;181,440&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;630&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;362,880&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;126&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;362,880&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;計　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6,046&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;986,410&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;それにしても986,410から6,046に減るというのもかなりの差で、かなり歪な形のツリー構造になっている感じです。それと下膨れのピラミッド型にならずに手数が増えると空いているマス目が減って重複局面が増えるので、中膨れ状態になるのもやってみなければわからないなぁって感じでした。&lt;br /&gt;
　世界中で調べ尽くされているであろうゲームなので、いろんなケースの数値を導き出しているサイト&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;と同じ数値が出せれば検証終了ってことにしようと思ったのですが、なかなかピッタリくるサイトがありませんでした。でも上の表の数値と「tictactoe」という単語で検索するとかなりの数のサイトが引っかかるのでおそらく問題ないでしょう^^;&lt;br /&gt;
　それと&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;上記の本&lt;/a&gt;には２８７個のココナッツを用意すれば足りると書いてあり、上下左右の対称形を省けばゲームの局面の数は６０４６ではなくその数にまで絞れるのかもしれませんが、そこまでやるとプログラムが追いにくくなると思ったのでやってません。但し、その数字を出すためにはどうすればいいのか、どうやればその数字で収まることを検証できるか興味はあるので、気が向けば挑戦するかもしれませんが、とりあえず今はまず学習機能作成を進めていこうと思います。&lt;/p&gt;

&lt;h3 id=&quot;局面を遡るメソッド&quot;&gt;局面を遡るメソッド&lt;/h3&gt;
&lt;p&gt;　本来のBFSの使い途というか迷路の解法の際には、出口に到達した時に入り口まで遡る方法を用意しておかなくてはいけないので、この三目並べのツリーでも最終局面から初手まで遡れるように自分の親を辿るparentメソッドを用意しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#verify.rb

require &quot;./constant.rb&quot;
require &quot;./game.rb&quot;
sente_player = Player.new(CROSS, false)
sente_player.init

target = Board.new([-1, 1, 1, -1, -1, -1, 1, nil, 1])
target.display

buf = target
begin
  buf = trees.parent(buf)
  buf.display
end until buf == nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　上のようにサンプル局面を作ってparentメソッドを呼び出すと下の画面のように手の経過を初手まで辿ることができます。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/goback.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/goback.png&quot; alt=&quot;スクリプト実行結果&quot; title=&quot;スクリプト実行結果&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　自分でも作ってから気がついたのですが、迷路の場合なら解答の表示に使えそうなこのメソッドですが、上にも書いてきたように、この多分木データは局面を省略してかなり歪なツリー構造になっているので、parentメソッドを呼び出して自分の局面の一つ前の局面（親データ）に戻ることが出来るといっても、この局面に至った一例を示しているにすぎないということに気をつけなければいけません。三目並べで出現する可能性があるすべての局面データをツリー状態で保持していることは間違いないのですが、その局面に至る手順は本当は幾通りもあるけどデータとして持っているのは一通りだけということです。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;img src=&quot;/images/terminal_ex1.png&quot; alt=&quot;例１&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;/images/terminal_ex2.png&quot; alt=&quot;例２&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　１も２も右端の局面は同じで重複データなので一つしか持ってません。だから、１の経過を辿ったのか２の経過を辿ったのか多分木データだけでは知りようがないのですが、それは別途実際に打った手を一つの配列で保持することにします。とにかく出来上がった多分木データはこの例のような子ノードを省いた状態の親ノードが非常に多いということです。&lt;br /&gt;
　ということで必要になるだろうと思って用意したメソッドですが、parentメソッドは三目並べ機械学習プログラムでは使う必要がなさそうです。ここでも前回同様に迷路の解法と三目並べプログラム作成の違いが出ました。&lt;br /&gt;
　次の記事で機械学習機能を付けるに当たって新たに必要となった機能について書いていきます。完成したら&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;githubのソース&lt;/a&gt;を更新するつもりです。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.se16.info/hgb/tictactoe.htm&quot;&gt;How many Tic-Tac-Toe (noughts and crosses) games are possible?&lt;/a&gt;、&lt;a href=&quot;https://www.jesperjuul.net/ludologist/255168-ways-of-playing-tic-tac-toe&quot;&gt;The Ludologist&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Tic-tac-toe&quot;&gt;Wikipedia Tic-tac-toe&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>幅優先探索(BFS)で対戦型ソフトを強くできるのか？</title>
   <link href="https://happyclam.github.io/project/2015-10-10/tictactoe_bfs"/>
   <updated>2015-10-10T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2015-10-10/tictactoe_bfs</id>
   <content type="html">&lt;p&gt;Project: &lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;幅優先探索のメリット&quot;&gt;幅優先探索のメリット&lt;/h3&gt;
&lt;p&gt;　アルゴリズムに関する本なんかを読んでいると、オセロゲーム、三目並べ、将棋などのいわゆる&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E4%BA%8C%E4%BA%BA%E9%9B%B6%E5%92%8C%E6%9C%89%E9%99%90%E7%A2%BA%E5%AE%9A%E5%AE%8C%E5%85%A8%E6%83%85%E5%A0%B1%E3%82%B2%E3%83%BC%E3%83%A0&quot;&gt;二人零和有限確定完全情報ゲーム&lt;/a&gt;のソフトを作る時によく使用される「深さ優先探索（Depth First Search, DFS）」アルゴリズムとの対比で、「幅優先探索（Breadth First Search, BFS）」というアルゴリズムが紹介されていることが多いですが、かなり昔に読んだ本の中で強い対戦型ソフトを作るために幅優先探索（BFS）を使うと以下のようなメリットがあると書いてあった記憶があります。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;思考時間に制限があるような場合は、深さ優先探索（DFS）だと偏った候補手しか読めないので時間に追われて悪手を選ぶことがあるが、幅優先探索（BFS）を使えばいつ読みを中断されてもそれなりに有効な一手を選ぶことが出来る。&lt;/li&gt;
  &lt;li&gt;序盤はBFSを使って広く浅く読み、終盤はDFSを使ってゲームの終局（詰み）まで読み切るように作れば強いソフトが作れる&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　なるほどそういうものかと納得し、今までずっと気にはなっていながらも、試してみる機会がありませんでした。また、自分が見てきた限りでは、書籍で紹介されているオセロや将棋のソフトでは、深さ優先探索（DFS）を紹介しているものばかり（いきなりαβ法とNEGMAX法を用いた最適解を紹介しているものがほとんど）で幅優先探索（BFS）を紹介しているものは見かけなかったので、今回自分で試してみることにしました。オセロや将棋ではなく例によって以前作った三目並べプログラムを題材にして試してみます。&lt;/p&gt;

&lt;h3 id=&quot;対戦型ソフトと迷路は違う&quot;&gt;対戦型ソフトと迷路は違う？&lt;/h3&gt;
&lt;p&gt;　よく「最短経路の発見」、「迷路の解法」などを題材にしてBFSを使った解法とDFSを使った解法２つを比較しながら紹介している本を見かけるので、まずは現在DFSを使って動作している三目並べプログラムをBFSに置き換えただけのものを作ることにしました。一般にDFSとBFSの違いはデータ構造の違い（スタックを使うかキューを使うか）だけだと言われています。再帰関数を使って次々と局面をスタック（stack）に積み上げて先読みしていた部分を、同一局面を間引きながらキュー（queue）に追加＆取得を繰り返すように変更することで実現できると巷の本には書いてあります。そして以下のような感じで、幅優先探索を使って全局面を辿っていく手順は実現出来た（実際に動作確認したい人は&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;github&lt;/a&gt;からソースコードを取得してください）のですが、局面を評価して手を選ぶ処理を書こうと思った時にちょっとおかしいと気がつきました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def bfs(board, turn)
    init_dup
    queue = Array.new
    board.teban = turn
    set_dup(board); queue.push(board)

    locate = nil
    while queue != [] do
      buf = queue.shift
      #キューから一局面を取り出して一手ずつ打つ
      buf.each_with_index {|b, i|
        #既に駒があれば次の場所へ
        next if b
        temp = buf.clone
        temp[i] = buf.teban
        #同一局面があれば次の局面へ
        next if check_dup(temp)
        temp.teban = (buf.teban == CROSS) ? NOUGHT : CROSS
        #DFSならここで評価関数を呼んで手を選択する
        ??????
        set_dup(temp); queue.push(temp)
      }
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　DFSの場合なら、勝ちか負けか引分けかの３値のうちどれかを返す読み切り用の評価関数を呼び出して、先手なら評価値が大きい方後手なら小さい方を選ぶという処理を書くだけで、先手番の局面・後手番の局面と実際に人間がゲームを進める時のように交互に局面を評価しながら辿っていくのに対して、BFSで同じようにコードを書くと、一手目に現われ得る全局面を評価＆比較し、それが終わったら二手目の全局面を評価＆比較するという順序で局面を辿っていくため、お互いに最善手を打つという&lt;a href=&quot;/software/2014-09-16/ab_method&quot;&gt;MIN-MAX法&lt;/a&gt;のロジックが働いていません。とりあえずBFSで書き換えたものを実際に動かしてみても非常に弱いプログラムになります。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFSの先読み順序&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:600px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/dfs_tree.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/dfs_tree.png&quot; alt=&quot;DFSの先読み順序&quot; title=&quot;DFSの先読み順序&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;BFSの先読み順序&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:600px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/bfs_tree.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/bfs_tree.png&quot; alt=&quot;BFSの先読み順序&quot; title=&quot;BFSの先読み順序&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　なぜBFSだと弱いのか考えてみると、まず一手目、二手目という勝負がつかないところの評価はDFSもBFSも同じですが、勝負がついた時の評価がDFSだと局面を評価した後に一手前に戻った時（スタックからpopupした時）に評価値を比較して相手に有利だった場合にその手を避けることが出来るのに対して、BFSだと勝ちなら勝ち、負けなら負けの評価のまま上書き（比較する時に等号があれば上書き、無ければ無視）し続けることになります。それに一手前に戻って選択した手を変えることがないということは、BFSで勝ちの評価を得た局面に至ったとしても、それは相手が自分にとって有利な手を打ってくれたからこそその局面になった可能性が高いわけです。この点が迷路を解くのと違うところだと思いますが、迷路の場合は普通は正解が一つでその正解手順を発見した時点で先読みを打ち切ればいいわけですが、三目並べ等の対戦ゲームの場合は勝ち局面に至る手順が一通りではなくかなりの数になリ、勝ち局面に至ったといっても相手がお手伝いしてくれている場合が多いのです。将棋で「二人掛かりで玉を詰める」などとヘボ将棋を揶揄することがありますが、まさにそういう状態で勝ち局面を発見して「自分の勝ちだ」と評価して手を選んでいる状態がBFSの手順になります。&lt;br /&gt;
　また、上の図の先読み順序の違いを見れば、時間制限があるような時にBFSだと確かに思考をいきなり中断された時に安定した評価を得られそうですが、その評価が独りよがりの評価になっているのでは意味がありません。仕方がないので、使用する評価関数を勝ち、負け、引分けの３値を返すものから、重み（真ん中が２点、角が１点、辺が０点）による評価関数に変えて序盤（３手目まで）をBFSで読み、３手目以降はDFSで読んで手を決定するようにしました。でもこれは重みによる評価関数を使用すればBFSによる先読みが有効に働くというわけではなく、BFSを使用している限り独りよがりの読みになっている点は同じなのですが、以前&lt;a href=&quot;/project/2014-08-05/tictactoe&quot;&gt;記事&lt;/a&gt;に書いたように初手からDFSで読み切ると勝つことを諦めてしまって、勝つ可能性が高くなるにもかかわらず初手に真ん中を選んでくれないので、重みによる評価関数を使って初手に真ん中を選ぶようにしているだけです。でも初手に真ん中を選ぶようにするだけなら評価関数だけを変えればいいことで、先読みアルゴリズムをDFSからBFSに変更する必要はありません。つまり今&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;github&lt;/a&gt;にアップされているソースはせっかく作ったからBFSのロジックを組み込んでいるだけと言えます&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&quot;まとめ&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　結局、冒頭に書いた幅優先探索のメリット１も２も一見正しいように思えるけど、BFSだけでこのメリットを実現することは無理そうです。もう昔のことでこのメリットについてどこで読んだのかも覚えていないのですが、まずBFSで局面を絞った後で、その絞った局面から&lt;a href=&quot;/software/2014-09-16/ab_method&quot;&gt;MIN-MAX法&lt;/a&gt;を使って先読みを続けて手を決めるというような趣旨だったかもしれません。でもまぁ今回実際にプログラムを書くことによって、迷路を解くのとは違う問題があることを知ることが出来ました。&lt;br /&gt;
　ネットで検索してみると幅優先探索を使用していて尚且つ強い（であろう）オセロプログラムについての記述を見つけることができました&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;が、どのように強くしているか詳細はわかりません。でも「定石」と「学習」という単語が出てきているのでBFSで形成したツリー構造に定跡データを格納して利用するということかもしれません。単に定跡データを格納しておくだけなら起動時にデータとして読み込めばよく動的にツリー構造を辿る必要はないので、学習しながら保存するということなのでしょう。確かにそういう使い方なら納得できます。&lt;/p&gt;

&lt;h3 id=&quot;もう一つのまとめ&quot;&gt;もう一つのまとめ&lt;/h3&gt;
&lt;p&gt;　アルゴリズムに関する本には「DFSとBFSは使用するデータ構造が違うだけ」なんて書いてあるからDFSで出来ることは当然BFSでも同様に出来るはずだと私が思い込んでいたせいもありますが、そもそもBFSは探索アルゴリズムなので勝ち局面に至る最短の手順を探索出来ていると考えるべきかもしれないと、ここまで書いてから思い始めました。BFSだと独りよがりの評価しか出来ないなんて言われる筋合いのものではなく、双方が協力した場合の最短の経路（勝ち手順）を探すことが出来ていると考えるべきなのでしょう。確かにBFSだけで対戦ゲームプログラムを強くするのは難しそうですが、逆にDFSアルゴリズムを使ってBFS同様の独りよがりの評価をする弱い状態（「二人掛かりで玉を詰める」状態）に変更するのは簡単です。&lt;br /&gt;
　そう考えると、DFSという単なる探索アルゴリズムを使って人間が考えるような「相手が有利になる手を避ける」、「双方が最善手を打つ」というロジックを簡単に実現出来ることの方が例外的なことなのかもしれません。単なる探索アルゴリズムでしかないはずなのにあたかも人間が思考しているようなプログラムの振る舞いを実現できるからこそ、DFSを使ったプログラムがAI（人工知能）と称される&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;のかもしれません。&lt;br /&gt;
　私は学者じゃないので詳しくはわかりませんが、ちょっと穿った見方をすれば、人工知能という単語を使った方が予算が獲得し易いとか本を売り易いとかいう事情があって、少々大げさなのは承知の上で積極的に「人工知能」という単語が使われてきたのかもしれません。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;実は序盤をBFSで読むように変更することで、JavaScriptのブラウザアプリに置き換えた時にスタックオーバーフローを避けることが出来るという意味があったのですが、最近のブラウザだと三目並べの全局面探索をした程度ではオーバーフローを起こさないようです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://uguisu.skr.jp/othello/5-3.html&quot;&gt;オセロ（リバーシ）の作り方&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;経験上、タイトルに「人工知能」「ＡＩ」という単語が含まれる本の多くが、単にDFSアルゴリズムの説明しかしていないものが多かったです。但し最近は事情が違ってきているようで&lt;a href=&quot;https://www.amazon.co.jp/gp/product/B00UAAK07S?psc=1&amp;amp;redirect=true&amp;amp;ref_=oh_aui_d_detailpage_o02_&quot;&gt;この本&lt;/a&gt;は参考になりました。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>WithingsのAPIで遊ぶ</title>
   <link href="https://happyclam.github.io/project/2015-09-19/activite"/>
   <updated>2015-09-19T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2015-09-19/activite</id>
   <content type="html">&lt;p&gt;Project: 「&lt;a href=&quot;https://nocturia.herokuapp.com&quot;&gt;&lt;strong&gt;夜間頻尿診断&lt;/strong&gt;&lt;/a&gt;」: &lt;a href=&quot;https://github.com/happyclam/nocturia&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;何か作ってみたい&quot;&gt;何か作ってみたい&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/hardware/2015-08-16/withings/&quot;&gt;前回の記事&lt;/a&gt;の続きでWithingsのAPIを使って何か作るものはないかと無理やり考えてみた結果、&lt;a href=&quot;https://nocturia.herokuapp.com&quot;&gt;夜間頻尿判定サイト&lt;/a&gt;を作ってみました。睡眠中の「目覚め」回数をトイレに起きた回数と考えて、夜間頻尿状態かどうかを判断するサイトです。Withingsのサイトで表示される睡眠トラッキングのグラフには「目覚め」回数は数字で表示されていますが、グラフ化されていないので睡眠トラッキングと同じグラフ上に描画しようという魂胆です。Withingsの週単位のグラフは、縦軸に時間、横軸に曜日（日付）となっていますが、睡眠時間を小数表示にして「目覚め」の回数を同じグラフ上にプロットしています。無理やりなんて書きましたが、Withingsのグラフは週単位でしか表示できなくて、もっと長い期間のグラフをまとめて表示したいという不満があったので、その不満を解消する目的もあります。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Withingsのグラフ&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/withings_screenshot.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/withings_screenshot.png&quot; alt=&quot;Withingsのグラフ&quot; title=&quot;Withingsのグラフ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;今回作成したグラフ&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/nocturia_screenshot.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/nocturia_screenshot.png&quot; alt=&quot;夜間頻尿診断グラフ&quot; title=&quot;夜間頻尿診断グラフ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;開発時に気になったこと&quot;&gt;開発時に気になったこと&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;アクセストークン／シークレットの保存先&lt;br /&gt;
　昔からbot作ったりしてTwitterでOAuth認証（認証ではない？）やRails2時代にgoogleのOpenIDによる認証を使ったりしたことはありますが、そういう認証方式を取るのは、ユーザー登録という手間を省きたい、ユーザー情報を管理したくない、使いたい人は自己責任で勝手に使ってください、個人情報を入力させたりして余計な責任負いたくないという理由があるわけですが、今回のアプリの場合扱うデータが結構秘匿性が高いというか、人によっては知られたくないデータだと思うのでちょっといろいろ考えさせられました&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。というのも&lt;a href=&quot;/hardware/2015-08-16/withings/&quot;&gt;前回の記事&lt;/a&gt;でoauth_signatureを作成する方法をネットで調べていた際に、一度取得したアクセストークン／シークレットはDBに保存すればいいという書き込みをよく見かけたからです。でも、自社サーバーでコストかけて運用している企業ならいざ知らず、そんなことをして何かの原因で全ユーザーのIDとセットで漏洩したらマズイと思ったので、DBには保存せずセッションに保存することにしました。「クライアントにデータが渡る方が危険」、「盗聴されたら同じ」、「セッションが残ったままになる可能性が有る」とかいろいろ意見はありそうですが、無料枠のherokuで適当に運用する以上DBに保存するよりセッション（cookieに保存）の方が安全だと思いました。WithingsのUserIDはDB内で管理し、クライアントに渡るのはRailsが付加するUserIDとアクセストークン（暗号化済み）という感じで、Withings社のUserIDとアクセストークン／シークレットが別々に格納されているほうが安全でしょう。&lt;br /&gt;
　結局、DBに保存するかセッションに保存するかはサイトのポリシー次第と言えると思いますが、私の場合ソースも公開するから心配ならローカルで動かして使ってくださいっていうポリシーでいきます。&lt;br /&gt;
　と、長々と書きましたが実際には利用する人なんてほとんどいないと思われるので、心配する必要もないのですが苦労性な性格なんです。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ユーザー情報が入っていない&lt;br /&gt;
　Twitterの場合認証を済ませてアクセストークンを取得する時にユーザー名などのユーザー情報（infoデータ）を返してくれます（Facebookもそのようです）が、Withings社のAPIの場合ユーザー情報が何も返ってきません。そのためユーザー認証を済ませた直後にいきなりユーザー情報を取得するためのAPIを発行するという重たい処理をしてWelcome表示しています。&lt;a href=&quot;/hardware/2015-08-16/withings/&quot;&gt;前回の記事&lt;/a&gt;でも愚痴っぽいことを書きましたが、ネットを検索している最中にもWithings社のAPIの仕様に文句を言っている海外の書き込みを見かけました。自社のWebAPIを公開する企業の姿勢というのは開発者としてもユーザーとしても応援したいのですが、そのことで企業のイメージを悪くするのであれば状況が変わってくる可能性もありそうです。日本でも自社サービスのAPIを公開している企業があると思いますが、どうなのでしょう、あまり利用されてないのかもしれませんが。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div id=&quot;notice&quot;&gt;&lt;/div&gt;

&lt;h3 id=&quot;その他withings-activitéを使ってみて気づいたこと&quot;&gt;その他、Withings Activitéを使ってみて気づいたこと&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;毎日スマホと同期しないとデータが抜け落ちる&lt;br /&gt;
　時計本体に保存しておけるのは1日分のデータだけのようです。言われてみれば活動量計の針も深夜０時になると０（ゼロ）の位置にリセットされるので当然かもしれませんが、Withingsのグラフでデータが抜けている日を見つけてはじめて気がつきました。CSVファイルでアップロードすることは可能なようですが試していません。&lt;/li&gt;
  &lt;li&gt;睡眠中の一時的な「目覚め」か、もう起きたのか？&lt;br /&gt;
　基本的には「目覚め」回数とは睡眠中に一時的に起きた回数で、本当に起きた回数は数えないようです&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;が、朝起きて布団の中でウダウダしていると「目覚め」回数に数えられるようです。朝起きてすぐに活動を開始した日は「目覚め」回数は０になるようですが、私の場合サイレントアラームで目覚めてももう一つの時計のアラームが鳴るまで起きないためか、夜中にトイレに起きたわけでも無いのにほとんどの日が「目覚め」回数が１回以上になっています。&lt;/li&gt;
  &lt;li&gt;サイレントアラームの止め方&lt;br /&gt;
　ネットの情報によるとWithings Activitéのサイレントアラームは「１２回の振動が終わるまで待たないといけない&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;」とか「There’s no way of stopping the ‘silent alarm’ which is a series of 12 vibrations.&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;」なんて書いてあるのですが、ダブルタップ（アラーム時刻の設定確認をする時と同様のはず）で私は振動を止めることが出来ています。製造時期によるのでしょうか？ネットでそれらしき書き込みを見かけないので私が持っているものが壊れている可能性もありますね^^;でもその止め方のコツはなかなか掴めず、うまくいけば１、２回振動させたところで止められるのですが、未だにポンポン叩いて結局１２回振動させる日があります。確かに時計自身が起こす振動とタップによる振動を区別するのは仕様に無理があるのかも。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.sakimura.org/2011/05/1087/&quot; title=&quot;非技術者のためのOAuth認証(?)とOpenIDの違い入門&quot;&gt;非技術者のためのOAuth認証(?)とOpenIDの違い入門&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;立位・伏臥状態等の姿勢を判定しているのか、仕様がどうなっているのかわかりませんが、技術的には可能なようです→&lt;a href=&quot;http://www.dreamnews.jp/press/0000096134/&quot; title=&quot;睡眠を測る！スリープモニターFS-760販売開始&quot;&gt;睡眠を測る！スリープモニターFS-760販売開始&lt;/a&gt;、&lt;a href=&quot;http://www.kicnet.co.jp/medical/biosignal/posturevisualizer/spec.html&quot; title=&quot;姿勢判定プログラム：PostureVisualizer&quot;&gt;姿勢判定プログラム：PostureVisualizer&lt;/a&gt;、&lt;a href=&quot;http://sakidori.co/article/11599&quot; title=&quot;オムロン？それともタニタ？おすすめの睡眠計7選！リストバンドタイプから目覚まし機能付きまで睡眠計測器特集&quot;&gt;オムロン？それともタニタ？おすすめの睡眠計7選！リストバンドタイプから目覚まし機能付きまで睡眠計測器特集&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.leesfitness.com/jp/withings-activite-pop-review.html&quot; title=&quot;フランスメーカーWithingsのお洒落な活動量Activité Popのレビュー&quot;&gt;フランスメーカーWithingsのお洒落な活動量Activité Popのレビュー&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.pcadvisor.co.uk/review/activity-trackers/withings-activite-watch-review-uk-3596819/&quot; title=&quot;Withings Activité watch review&quot;&gt;Withings Activité watch review&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Withings Activité購入</title>
   <link href="https://happyclam.github.io/hardware/2015-08-16/withings"/>
   <updated>2015-08-16T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/hardware/2015-08-16/withings</id>
   <content type="html">&lt;h3 id=&quot;普通の腕時計を買うつもりがスマートウォッチになったわけ&quot;&gt;普通の腕時計を買うつもりが、スマートウォッチになったわけ&lt;/h3&gt;
&lt;p&gt;　もう１０年以上前から腕時計をする習慣が無くなっていたのですが、携帯電話からスマホに変わってからは胸ポケットに入れられないスマホを鞄から取り出すのが面倒なため腕時計をする機会が多くなっていました。でも今はロードバイク用に買ったアウトドア用のソーラー電波時計しか無いので、一つビジネスにも使えるようなものを買ってみようかと思って&lt;a href=&quot;https://www.facebook.com/powerwatch.fan/posts/840855109296593&quot;&gt;「予算１０万円台までで購入できる　最強スポーツウオッチ選手権」&lt;/a&gt;と銘打った時計雑誌を購入しました。&lt;br /&gt;
　雑誌の中ではいろいろ欲しくなる時計は紹介されていたのですが、小さく紹介されていた「Withings Activité」のデザインが気に入ってネットで調べてみるとスマートウォッチというカテゴリーに分類される時計のようです。Apple Watchにもほとんど興味が湧かなかった自分にとっては、すでに世の中にいろいろなスマートウォッチと呼ばれる時計が出回っていることを知って驚きでした。&lt;br /&gt;
　そして、&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;サイレントアラーム（音ではなく振動で目覚まし）を体験したい&lt;/li&gt;
  &lt;li&gt;せっかく身に付けるものが増えるなら万歩計の機能も欲しい&lt;/li&gt;
  &lt;li&gt;ちょうど体重計を買い換えようと思っていたので、&lt;a href=&quot;http://www.amazon.co.jp/【日本正規代理店品】-Withings-ネットワーク対応-Bluetooth-70046001/dp/B00V35HEIC/ref=pd_cp_23_4?ie=UTF8&amp;amp;refRID=1ZPPMCN7P96YPJKSNHAP&quot;&gt;Withing製品&lt;/a&gt;で揃えよう&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　というビジネス時計を買うという当初の目的に無かった余計な欲が出てきて、スマホと連携して遊べそうな「Withings Activité」が欲しくなってきました。昔ロードバイクを初めて購入した時に&lt;a href=&quot;http://www.amazon.co.jp/Holux-M-241-HOLUX-ワイヤレスGPSロガー/dp/B00C85RH8S&quot;&gt;HOLUXのGPSロガー&lt;/a&gt;を購入しロードバイクで彼方此方走った記録を後からニヤニヤしながら地図上で記録をなぞっていくのを楽しんでいた時期がありましたが、それに近いものがあるような気がします。自転車乗るのも好きだけど、後からGPSデータを眺めるのも好き。腕時計も好きだけど、付加された遊び機能も好き、みたいな。それに何と言っても「Withings Activité」のデザインやサファイアガラスを使っている点などは時計としての魅力もたっぷりで、スマートウォッチの機能に飽きたとしても長く使っていけそうだと思ったことが購入を決めた大きな理由です（電池を自分で交換できる点もいい）。&lt;br /&gt;
　ちなみにGPSロガーはすぐに飽きて使わなくなったのですが、初めて買ったロードバイクは今でもお気に入りで乗り続けています。&lt;/p&gt;

&lt;div style=&quot;width:160px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/activite_setup.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/activite_setup.png&quot; alt=&quot;セットアップ完了&quot; title=&quot;セットアップ完了&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　それにしても購入を決めた当初は、自分のように時計を物色していてこの機種を購入するに至った人は珍しいんじゃないかと思っていたのですが、その後もスマートウォッチの情報をネットで漁っているとApple Watchのような如何にも今までの腕時計とは異質のものではなく、見た目は本格的な腕時計のままスマホとの連携機能を持つスタイルのスマートウォッチのほうが主流になる可能性があることを知りました&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。時計雑誌で紹介されていたスマートウォッチはこの機種だけだったので、浮いている感じを受けましたが、今後は普通の時計雑誌でスマートウォッチが紹介される機会が増えてくるのかもしれません。&lt;br /&gt;
　セットアップは&lt;a href=&quot;https://uxlayman.hatenablog.com/entry/2015/04/28/073100&quot;&gt;こちらのサイト&lt;/a&gt;を参考にしました。&lt;/p&gt;

&lt;div style=&quot;width:160px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/activite_sleeping.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/activite_sleeping.png&quot; alt=&quot;日毎の睡眠パターン&quot; title=&quot;日毎の睡眠パターン&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　上のグラフのように浅い眠りと深い眠りを判別出来るようです。寝起きに「あ〜よく寝た」と感じた時は濃い青のグラフの帯が大きかったので結構正確かもしれません。それと当たり前かもしれませんが朝方トイレに起きた履歴もちゃんと残っていて、いつか自分の記憶にない記録が残っていたりしないかと密かに期待しています（夢遊病か!?）。&lt;/p&gt;

&lt;h3 id=&quot;web-apiを使ってみる&quot;&gt;Web APIを使ってみる&lt;/h3&gt;
&lt;p&gt;　APIが公開されていたので少し触ってみました。&lt;a href=&quot;https://blog.hopkins.io/2013/07/25/withings-api/&quot;&gt;Withings API Quickstart Guide&lt;/a&gt;と銘打ったサイトの通りwithings用のgemを使えばすぐに自分が登録したデータを取得することが出来ましたが、最新のAPIに対応しているか分からなかったし使い方もよくわからないし、アクセストークンを取得した後は&lt;a href=&quot;https://oauth.withings.com/api&quot;&gt;WithingsのAPIドキュメント&lt;/a&gt;を見ながら自分でパラメータをセットしていろんなデータの取得を試してみたかったので、特別なgemを使用せずにjsonデータを取得するスクリプトを書いてみました。&lt;br /&gt;
　このスクリプトを実行するにはTwitterアプリを作る時なんかと同様に&lt;a href=&quot;https://oauth.withings.com/en/partner/add&quot;&gt;Withingsにアプリを登録&lt;/a&gt;してAPI Key、API Secretを取得する必要があります。そしてWithings API のページの&lt;a href=&quot;https://oauth.withings.com/api&quot;&gt;FIRST STEP&lt;/a&gt;に従って操作し、OAuth認証完了後userid、oauth_token、oauth_token_secretの値を取得してスクリプトにセットしておく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#sleep.rb
require 'pp'
require 'openssl'
require 'time'
require 'json'
require 'net/http'
require 'cgi'
require 'base64'

BASE_URI='https://wbsapi.withings.net'
WITHINGS_OAUTH_CONSUMER_KEY='xxxxx'
WITHINGS_OAUTH_CONSUMER_SECRET='yyyyy'

user_id = 1234567
oauth_token = &quot;aiueo&quot;
oauth_token_secret = &quot;iroha&quot;

params = {:action =&amp;gt; :get, :userid =&amp;gt; 1234567}
#params = {:action =&amp;gt; :getworkouts, :userid =&amp;gt; 1234567}
#params = {:action =&amp;gt; :getsummary, :userid =&amp;gt; 1234567}
#params = {:action =&amp;gt; :getactivity, :userid =&amp;gt; 1234567}
#params = {:action =&amp;gt; :getbyuserid, :userid =&amp;gt; 1234567}

url = BASE_URI + '/v2/sleep'
#url = BASE_URI + '/v2/measure'
#url = BASE_URI + '/user'
#url = BASE_URI + '/v2/user'

params.merge!({
                :oauth_consumer_key =&amp;gt; WITHINGS_OAUTH_CONSUMER_KEY,
                :startdate =&amp;gt; Time.parse(&quot;2015-08-07 12:00:00&quot;).to_i,
                :enddate =&amp;gt; Time.parse(&quot;2015-08-08 12:00:00&quot;).to_i,
#                :startdateymd =&amp;gt; '2015-08-09',
#                :enddateymd =&amp;gt; '2015-08-09',
#                :startdateymd =&amp;gt; Time.parse(&quot;2015-08-03 12:00:00&quot;).to_i,
#                :enddateymd =&amp;gt; Time.parse(&quot;2015-08-09 12:00:00&quot;).to_i,
#                :lastupdate =&amp;gt; Time.parse(&quot;2015-08-08 12:00:00&quot;).to_i,
                :oauth_nonce =&amp;gt; rand(10 ** 30).to_s(16),
                :oauth_signature_method =&amp;gt; 'HMAC-SHA1',
                :oauth_timestamp =&amp;gt; Time.now.to_i,
                :oauth_version =&amp;gt; '1.0',
                :oauth_token =&amp;gt; oauth_token
              })
params = params.to_a.map() do |item|
  [item.first.to_s, CGI.escape(item.last.to_s)]
end.sort
param_string = params.map() {|key, value| &quot;#{key}=#{value}&quot;}.join('&amp;amp;')
base_string = ['GET', CGI.escape(url), CGI.escape(param_string)].join('&amp;amp;')
secret = [WITHINGS_OAUTH_CONSUMER_SECRET, oauth_token_secret].join('&amp;amp;')
digest = OpenSSL::HMAC.digest('sha1', secret, base_string)
signature = Base64.encode64(digest).chomp.gsub( /\n/, '' )
uri_string = url + '?' + param_string + '&amp;amp;oauth_signature=' + CGI.escape(signature)
#p uri_string

Net::HTTP.version_1_2
uri = URI.parse(uri_string)
json = Net::HTTP.get(uri)
result = JSON.parse(json)
pp result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　要するにリクエスト毎に変わるOAuth1.0の署名（oauth_signature）の生成を自動化するためのスクリプトです。&lt;a href=&quot;https://blog.hopkins.io/2013/07/25/withings-api/&quot;&gt;gem のソースコード&lt;/a&gt;と&lt;a href=&quot;https://syncer.jp/how-to-make-signature-of-oauth-1&quot;&gt;このサイト&lt;/a&gt;を参考にしました。RailsでTwitterのAPI使う時はgemが勝手にやってくれるので今までこの作業を自前でやったことはなかったため、サーバーからのエラーが無くなるまで結構手間取りました。サーバーがステータスコード「342 : The signature (using Oauth) is invalid」を返してくるわけですが、必ずしも署名の作成の仕方が悪いわけではないようです&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。サーバー側でもう少しパラメータのチェックを優先して、それに沿ったエラーを返して欲しいところですがどうなのでしょう。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/activite_screenshot.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/activite_screenshot.png&quot; alt=&quot;スクリプト実行結果&quot; title=&quot;スクリプト実行結果&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　とにかくこれで準備はできたので後はアイデアだけ。気が向けばこのWithings APIを使ったアプリを作ってみようと思ってます。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.dream-seed.com/weblog/archives/2015/02/55372/&quot;&gt;複数のスイス時計メーカーがスマートウォッチを発表&lt;/a&gt;、&lt;a href=&quot;https://weekly.ascii.jp/elem/000/000/328/328470/&quot;&gt;腕時計好きもグッとくる絶品スマートウォッチ特選編&lt;/a&gt;、&lt;a href=&quot;https://matome.naver.jp/odai/2142691305853056801&quot;&gt;グッチも！？有名ブランドが続々発売するスマートウォッチ市場が熱い！！&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;例として上記スクリプトのstartdateパラメータをセットしている行で.to_iを削除すると{“status” =&amp;gt; 342}が返ってきます。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>kobo aura購入</title>
   <link href="https://happyclam.github.io/hardware/2015-06-12/kobo_aura"/>
   <updated>2015-06-12T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/hardware/2015-06-12/kobo_aura</id>
   <content type="html">&lt;h3 id=&quot;今更だけどkobo購入&quot;&gt;今更だけどkobo購入&lt;/h3&gt;
&lt;p&gt;　前々から試してみたかった E-Ink端末を買ってみました。Kindleではなく&lt;a href=&quot;https://books.rakuten.co.jp/event/e-book/ereaders/koboaura/&quot;&gt;Kobo&lt;/a&gt;を買ったのは、日用品や書籍の購入は昔からAmazonばかり利用しているので少しAmazonに偏りすぎている気がしていたのと、koboはKindleと違ってSDカードが使えることや個人出版する場合Amazonのkindle direct publishing（KDP）から出版するより&lt;a href=&quot;https://books.rakuten.co.jp/e-book/rakutenkwl/&quot;&gt;koboライティングライフ(KWL)&lt;/a&gt;から出版した方が&lt;a href=&quot;https://internet.watch.impress.co.jp/docs/news/20150430_700205.html&quot;&gt;ロイヤルティが高い&lt;/a&gt;と聞いたので、楽天のことも少しは使って知っておこうと思ったのが動機です。まぁ電子出版に関して今後どうするか決めていませんが、とりあえずkobo auraを使ってみた感想を書いてみたいと思います。&lt;/p&gt;

&lt;h3 id=&quot;セットアップ&quot;&gt;セットアップ&lt;/h3&gt;
&lt;p&gt;　本体を取り出してWi-Fiでセットアップしようと思いましたが、自宅のフレッツ光のルーターはMACアドレスフィルタリングを設定しているので、まずはkoboのMACアドレスを知りたいのですが取説にシールが貼ってある気配もないし、外箱にもそれらしい値は書いてありません。セットアップの途中でキャンセルして設定を見ることが出来るかもと思いながらメニューを進めたり戻ったりしましたがどうもセットアップを完了するまで何も操作できないようになっているようで、MACアドレスを確認することはできませんでした。仕方がないのでUSBで接続してセットアップを完了させましたが、先々月購入したMacBookは外箱にちゃんとMACアドレスが記載されていたことを思うと、さすがAppleは抜かりないなって感じです。&lt;br /&gt;
　ちなみにUSB接続してセットアップ完了後は、koboの設定メニューからMACアドレスを確認することは出来たので問題なくWi-Fi接続も出来ました。&lt;/p&gt;

&lt;h3 id=&quot;自分で作成したepubファイルをkoboで読んでみる&quot;&gt;自分で作成したepubファイルをkoboで読んでみる&lt;/h3&gt;
&lt;p&gt;　DVDや音楽データと違ってAmazonで購入した電子書籍のDRMを解除してkoboで読むことに現時点では法的な問題はないもののAmazonとの契約上は問題があるようです&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
　ということで、まず自分で作成したepubファイルをkoboにコピーして動作確認してみました。USBで接続したらkoboがストレージとして認識されるので、そこに自作のepubファイルをコピーするだけでkoboで読むことができました。コピー後初めて開いた時は日本語が文字化けしていたのですが&lt;a href=&quot;https://iphone.f-tools.net/Book-Reader/EPUB-MojiBake.html&quot;&gt;このサイト&lt;/a&gt;に書いてある通り「ドキュメントデフォルト」となっているフォントを別のものに指定し直せば問題なく表示されました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;table rules=&quot;groups&quot;&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;a href=&quot;/images/defaultfont_img.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/defaultfont_img.png&quot; alt=&quot;ドキュメントデフォルト&quot; title=&quot;ドキュメントデフォルトの文字化け状態&quot; /&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;&lt;a href=&quot;/images/fixedfont_img.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/fixedfont_img.png&quot; alt=&quot;モリサワゴシック&quot; title=&quot;モリサワゴシックフォント選択後&quot; /&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;　epub上のリンクをクリックするとブラウザが起動してWebサイトも見れるようですし、思ったより動作も速いし、E-Ink端末初体験の自分にとってはこんなものかと納得していましたが、ネットで検索してみると他のE-Ink端末の方がいいという意見もいろいろあるようで、特に文字の表示が薄い&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;という指摘は確かにその通りだと思うし残念です。&lt;br /&gt;
　一つ気になったのが、自作のepub内でWikipediaへのリンクを記述している部分があるのですが、タップすると「指定されたページ名が無効な文字を含んでいます」とエラーページに飛ばされました。PC上でこのepubファイルを開いてクリックすれば正常に表示されるのにkoboで操作するとダメです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/encoding_error.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/encoding_error.png&quot; alt=&quot;Wikipediaのエラーページ&quot; title=&quot;koboで表示されたWikipediaのエラーページ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　メッセージに「無効な文字”%E4”を含んでいます」と書かれています。&lt;br /&gt;
　元のリンクのソースは&lt;code&gt;&amp;lt;a href=&quot;http://ja.wikipedia.org/wiki/二人零和有限確定完全情報ゲーム&quot;&amp;gt;Wikipedia&amp;lt;/a&amp;gt;&lt;/code&gt;なのですが、”%E4”ってのはこれをURLエスケープ（&lt;a href=&quot;http://ja.wikipedia.org/wiki/パーセントエンコーディング&quot;&gt;パーセントエンコーディング&lt;/a&gt;、URLエンコード）した後の日本語部分の最初の文字です。ブラウザを起動する前の、koboでリンクをタップした時に出るダイアログは以下のように既にエスケープされています。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/browser_launch.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/browser_launch.png&quot; alt=&quot;リンクをタップした時のダイアログ&quot; title=&quot;koboでリンクをタップした時のダイアログ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　つまりkoboのepubリーダーでURLエスケープした後、koboのブラウザでもさらに二重にエスケープしてWikipediaにリクエストしたものだから、Wikipediaサーバー側でunescapeしても”%”が入ってきちゃってるよ、オイオイってことです。&lt;br /&gt;
　ちなみに元のURL文字列を手動で二重にエスケープしてPCで試してみたところ、koboと同じ画面をPCでも出すことが出来ました。&lt;br /&gt;
&lt;a href=&quot;https://ja.wikipedia.org/wiki/%25E4%25BA%258C%25E4%25BA%25BA%25E9%259B%25B6%25E5%2592%258C%25E6%259C%2589%25E9%2599%2590%25E7%25A2%25BA%25E5%25AE%259A%25E5%25AE%258C%25E5%2585%25A8%25E6%2583%2585%25E5%25A0%25B1%25E3%2582%25B2%25E3%2583%25BC%25E3%2583%25A0&quot; target=&quot;_blank&quot;&gt;このリンク&lt;/a&gt;です。&lt;br /&gt;
　これって問題になっていないのでしょうか？URLに２バイト文字を使っているところは少ないかもしれませんが、Wikipediaを参照するepub本って結構あると思うのですがそうでも無いのでしょうか？&lt;br /&gt;
　ちなみにもともとエンコードしてaタグに書いていたのものをエラーになったから日本語直書きで試したわけですが、FirefoxでもiBooksでもフリーのandroidアプリ数種類でも、そしてaタグは日本語直書きでもエンコード済みでも正常にリンク出来ました。おまけに楽天koboのandroidアプリでも問題なくリンクが動作しました。koboのepubリーダーソフトの方はブラウザを起動する際に表示するダイアログを見る限り二重にエンコードするわけでは無いようなので、koboのブラウザがエンコード済みかどうかに関わらずURLエンコードしてサーバーにリクエストするようになっているのが問題のようです。&lt;br /&gt;
　う〜む、発売から一年以上経っているのでこのバグが知られていないとは思えないのですが、ネットで検索してもそれらしい書き込みは見当たりませんでした。不具合を指摘しているこちらが不安になるぐらいです。とりあえず自作のepub本以外で日本語URLを参照しているepub本を見つけたらkoboで動作確認をしてみようと思います。たとえ自作epub本じゃなくても、kobo側が対応してくれないとどうしようも無いと思うので、私のepubの作成の仕方が悪いってことでは無いと思いますが、電子書籍の世界は思っていたより奥が深そうなので私が知らない仕掛け（ルール）があるのかも知れません。あっ一応epubcheckでもエラーは出ていません。&lt;br /&gt;
　それとフリーのepubリーダーを何種類か試した時、リーダーソフトによってこれほど本の表示のされ方が違うのかって驚いてその混沌とした世界を垣間見た気がしたので、もしかしたらepubリーダーの世界ではこれぐらいの不具合は小さなことって感じかも知れません。&lt;/p&gt;

&lt;h3 id=&quot;まとめ&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　購入後ちょっと弄っただけで複数のブログネタを提供してくれるあたりポテンシャルを感じます&lt;img class=&quot;emoji&quot; title=&quot;grin&quot; alt=&quot;grin&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/grin.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;ネットでkoboの情報を漁っているとユーザの不満の声をあちこちで見かけるので、Amazonに偏り過ぎているなんて考えずに今後も楽天とは関わらない方が幸せになれるのかもとか考えてしまいました。&lt;br /&gt;
　それと、技術書のリファレンスとしても使おうとか思っていましたが、検索等の操作は遅いし調べ物はやっぱりPCの大画面で参照する方が効率的だし、本のサンプルコードを見ながらプログラミングとかするときもPCの大画面の方が便利で、やっぱり読書専用というかじっくり集中して本を読むための道具かなって感じです。本当は目に優しいE-Ink端末でいろんなことをしたいのですが、動作が遅いので用途が限られます（これでも速くなったそうなので、発売当時に手を出さなくてよかったと思います）。&lt;br /&gt;
　購入前は専門書はkoboのSDにまとめていこうかとか考えていましたが、新書や小説や、専門書でもプログラムコードが載っていない本の読書専用端末になりそうです。というか私が遅れて体験しただけで、世間ではすでにそういう評価になっているのかも知れませんが。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://herooftheday.net/backup-and-epub-converting-on-kindle-for-mac&quot;&gt;「Kindle for Mac日本語版が出たのでePub変換とかバックアップとかイロイロ試してみた」&lt;/a&gt;に詳しく書かれています。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.livedoor.jp/harpsichord1980/archives/51900585.html&quot;&gt;Kobo AuraのWebブラウザを触ってきたよ！&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>markdownファイルを元に電子出版</title>
   <link href="https://happyclam.github.io/miscellaneous/2015-06-09/pandoc_epub"/>
   <updated>2015-06-09T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/miscellaneous/2015-06-09/pandoc_epub</id>
   <content type="html">&lt;h3 id=&quot;無料で出版してもダウンロードさえして貰えないと聞くけど&quot;&gt;無料で出版してもダウンロードさえして貰えないと聞くけど&lt;/h3&gt;
&lt;p&gt;　最近自分が購入する本に占める電子書籍の割合が高くなってきました。単に購入する電子書籍の数が増えてきているだけでなく、昔は購入する電子書籍といえばマンガや雑誌のようなどうでもいいと思える本が多かったのに、最近は何度も読み返すようなお気に入りの技術系の本の中に電子書籍が混じっています。そして、電子書籍に触れる機会が増えてきたのと出版へのハードルが下がってきたこともあって、電子書籍を作るほう（出版）にも興味が湧いてきました。でも、原稿用紙に鉛筆で文章を書いて出版したいわけじゃなく、今このブログを書いているスタイル（markdownで書く）のまま書いたものを流用したいという拘りがあります。&lt;br /&gt;
　だから、書きたいことはあるけど、わざわざMacのpagesを使ったりWindowsの一太郎を使ったりネット上のサービス&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;を利用してepubファイルを作成して出版したいわけじゃないってことです。こういう方法論に拘るタイプは作家としては大成できないことは分かっていますが、あくまでmarkdownファイルを元にして電子書籍出版するにはどうすればいいのか、最近試行錯誤したことを書いてみたいと思います。&lt;/p&gt;

&lt;h3 id=&quot;markdownから電子書籍ファイルに変換する色々な方法&quot;&gt;markdownから電子書籍ファイルに変換する色々な方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;markdown-pdfコマンドで変換しPDF出力&lt;br /&gt;
markdown-pdfコマンドを使用してPDFファイルに変換します。CSSも使えるし改ページ処理も可能です、リンクが有効に出来ないようなので目次が使えません。でも、左サイドにサムネイル表示すれば不要な気もするので、PCで読むことだけを考えるのならこれでいいような気もします。&lt;br /&gt;
例.&lt;br /&gt;
&lt;code&gt;npm install -g markdown-pdf&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;markdown-pdf -f 'A4' -s github.css hoge.md -o hoge.pdf&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pandocで変換、PDF出力&lt;br /&gt;
ややこしいLaTeXのclsファイルを弄りながらpandocでPDFを出力してみましたが、文字化けしたりよくわからないトラブルに見舞われましたので自分としてはお勧めしません。&lt;br /&gt;
例1.&lt;br /&gt;
&lt;code&gt;pandoc hoge.md -o hoge.pdf -V documentclass=myltjsarticle --latex-engine=lualatex&lt;/code&gt;&lt;br /&gt;
例2（一度TeXに変換してからPDFに変換）&lt;br /&gt;
&lt;code&gt;pandoc hoge.md -f markdown_github -o hoge.tex&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;pandoc hoge.tex -o hoge.pdf -V documentclass=myltjsarticle --latex-engine=lualatex&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pandocで変換、epub出力&lt;br /&gt;
ほぼ満足のいく出来でしたが強制改ページの方法がわからないのと、epubcheckでエラーが出て原因がわからないので使うのを止めました。&lt;br /&gt;
例1.&lt;br /&gt;
&lt;code&gt;pandoc -t epub3 -o hoge.epub title.txt hoge.md -s --mathjax --epub-cover-image=images/title.png --epub-stylesheet=github.css --epub-metadata=metadata.xml&lt;/code&gt;&lt;br /&gt;
例2.（一度TeXに変換してからPDFに変換）&lt;br /&gt;
&lt;code&gt;pandoc hoge.md -f markdown_github -o hoge.tex&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;pandoc -s hoge.tex -o hoge.epub&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;epubの仕様に沿って定義ファイルを自前で用意してコンパイル（zip化）してepub出力。&lt;br /&gt;
他の変換ツールを使った方法と違って、変換ツールの制限を受けないので調べながらやれば出来上がりに不満が出ることは無いと思うのですが手間がかかります。&lt;br /&gt;
例.&lt;br /&gt;
&lt;code&gt;zip -q0X hoge.zip mimetype&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;zip -qXr9D hoge.zip *&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;cp hoge.zip hoge.epub&lt;/code&gt;&lt;br /&gt;
用意するディレクトリとファイルの例&lt;br /&gt;
&lt;a href=&quot;https://epubcafe.googlecode.com/svn/trunk/tutorial/OEBPS/Text/Chapter020201.xhtml&quot;&gt;参考サイト&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;Packeage/
├── META-INF
│   └── container.xml
├── mimetype
├── hoge
│   ├── cover.xhtml
│   ├── css
│   │   └── stylesheet.css
│   ├── images
│   │   └── title.png
│   ├── main01.xhtml
│   ├── main02.xhtml
│   ├── main03.xhtml
│   ├── nav.ncx
│   ├── nav.xhtml
│   └── hoge.opf
├── hoge.epub
└── hoge.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pdfかepubか&quot;&gt;PDFかepubか&lt;/h3&gt;
&lt;p&gt;　出版するための形態をどちらにするか一般的にはepubの方が正式な出版物という扱いだと思いますが、自分としては最初&lt;a href=&quot;https://gumroad.com&quot;&gt;Gumroad&lt;/a&gt;にPDFで公開するのが一番簡単そうだったのでそうしようと思っていたのです。でもpandocを使ってmarkdownからPDFに出力すると色々と不満が出てきたのでepubにも手を出してみたという経緯があります。pandocを使えばPDFにもepubにも出力出来るはずですが、一部の文字が化けたり、細かなトラブルに見舞われたのでPDF出力するならmarkdown-pdfを使った方が良さそうだとか、epub出力するならこのオプションが良さそうだとかいうノウハウが色々試行錯誤しているうちにわかってきました。そして、最終的には1.markdown-pdfを使ってPDF出力する、2.pandocを使ってepub出力する、3.epubの仕様に沿って自前で定義ファイルを書きepubを作成する、の３つの方法に絞りました。以下にそれぞれのメリットデメリットを書きます（不満点に書いている内容は、あくまで自分がうまく出来なかっただけで、よく理解している人がやれば可能なのかもしれません）。&lt;/p&gt;

&lt;table rules=&quot;groups&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;メリット&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;不満点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;markdown-pdf&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;簡単。PCで読むことだけを考えればこれで十分かも&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・脚注が使えない&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・数式が出せない？&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・リンクが効かない？&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pandoc&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;多くの電子書籍リーダーで利用できるepub形式&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・epubcheck（後述）エラーの検証で手も足も出せなくなる&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;自力epub&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;変換ツールの仕様やバグの制限を受けない&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・markdownから直接ではなく、一度HTMLに変換する必要がある&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　上記のようなファイル出力が思うように出来るか出来ないかという観点とは別に、PDFならDRMとしての簡易透かし機能が使えるとか、epubだとISBNのような識別IDをどうするのかとか手続き面のメリット・デメリット、epubだと大きな市場に投入出来るけどPDFだと電子書籍市場で不利だとかビジネス面でのメリット・デメリットもあると思います。&lt;/p&gt;

&lt;h3 id=&quot;epubcheckとは&quot;&gt;epubcheckとは&lt;/h3&gt;
&lt;p&gt;　実はpandocで自分にとってはほぼ満足いくepub形式のファイルに変換できてcalibre等で動作確認も出来たのですが、AppleのiBooksだと&lt;a href=&quot;https://github.com/idpf/epubcheck&quot;&gt;epubcheck&lt;/a&gt;というepub検証ツールを通過しないと出版できないという話を聞いたので試したところ原因不明のエラーが出ました。そしてエラーメッセージだけからでは原因がわからず、いろいろ推測しながら編集してエラーの原因を探ることに疲れたので、一から自前で定義ファイルを書く（自力epub）ことにしたのです。その結果epubcheckでエラーも出ないし自分で満足のいくepubファイルが作れることはわかったのですが、markdownファイルから直接epubファイルに変換しているわけではないので不満もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar ~/Downloads/epubcheck-4.0.0-alpha11/epubcheck.jar ./hoge.epub
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;まとめ&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　結局現時点での自分なりの結論はpandocに頼らずepubの仕様に沿って自前で定義ファイルを書いてコンパイルする（自力epub）のが一番良さそうだと思います。でもこの方法はmarkdownファイルから直接変換しているわけではなく、jekyll等でmarkdownからHTMLを生成し、それを定義にあわせて編集しているので一手間かかるのでまだ不満が残ります。ただこのやり方はepubで出力することを考慮しながらmarkdownの書き方を工夫するという余地もあるので、まだまだ試行錯誤が続きそうです。&lt;br /&gt;
　こんなことに時間を費やしているより出版したい文章を仕上げることを優先すべきなのですが、pandocの機能アップに期待しながら出版するのはもう少し先になりそうです。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;markdownに拘らなければAmazonやAppleや楽天ブックス以外にも&lt;a href=&quot;https://bccks.jp&quot;&gt;個人出版を助けるネットサービス&lt;/a&gt;があるようですし、&lt;a href=&quot;https://www7b.biglobe.ne.jp/~yama88/make.html&quot;&gt;変換ツール&lt;/a&gt;も色々あります。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>ハイブリッド開発（HTML5 + JavaScript）でハマったこと</title>
   <link href="https://happyclam.github.io/programming/2015-05-29/android_app1"/>
   <updated>2015-05-29T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2015-05-29/android_app1</id>
   <content type="html">&lt;h3 id=&quot;やはりそんなにうまい話はなかった&quot;&gt;やはりそんなにうまい話はなかった&lt;/h3&gt;
&lt;p&gt;　ObjectiveC++も使わずJavaのコードも一切書かずにiOSとandroidのアプリが一つのソースコードで作成できるというハイブリッドアプリ開発ですが、&lt;a href=&quot;/programming/2015-04-25/mongo_upsert/&quot;&gt;前回の記事&lt;/a&gt;で書いた通りとりあえず&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;androidアプリ&lt;/a&gt;をリリースしたのはいいけど、いろいろなトラブルに遭遇しました。そこでcordovaを使ったandroidアプリ開発に関してネット上に出回っている一般的なトラブルは除いて、特に自分だけかもしれない嵌り方をした点について書いてみようと思います。&lt;/p&gt;

&lt;p&gt;　開発環境：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jquery-1.11.2&lt;/li&gt;
  &lt;li&gt;jquery.mobile-1.4.5&lt;/li&gt;
  &lt;li&gt;cordova 5.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;android23ginger-breadでclickイベントが発火しない&quot;&gt;android2.3(ginger bread)でclickイベントが発火しない&lt;/h3&gt;
&lt;p&gt;　これは定番のトラブルであんただけではなくネット上によく出回ってる話じゃないかと思われた方も多いと思います、そしてclickイベントは使わないってのが基本だと仰る方も多いでしょうが、clickイベントに関するネット上で見かけるトラブルはその動作が重いから避けろというものだと思います。私は先人の教えの通りfastclick.jsを最初から使用していたので特に重いと感じることもなく普通に動いているから問題無いと思っていたのですが、エミュレータも含めてandroid4.1だと問題なくclickイベントが発生するけど、android2.3（おそらくそれ以前も）だとclickイベントが発生しないというトラブルに出くわしました。&lt;br /&gt;
　&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;私のアプリ&lt;/a&gt;はダイアログを表示する箇所が２箇所あるのですが、cordovaのプラグインを使っている方は問題ないのですが、もう一方の自前のwindow（SinglePageApplicationなのでdata-role=”page”を付加したページ）を呼ぶ出す部分のclickイベントが発火しないという現象でした。エミュレータ上でマウスでクリックしようが、実機にインストールして指でタップしようがうんともすんともいいません。なんでこんなことが起こるのか分からなかったのですが、JQueryMobile(JQM)を使用しているのが原因（jQueryは問題ない）のようで、試しにJQMの読み込みをコメントにするとレイアウトは崩れますが正常に動きました。でも、JQMを使わずにレイアウトを定義し直すのは面倒だし、JQMの中まで追って行って原因を追究するのも大変そうなのでネットで検索しながらいろいろ試してみた（vclickイベント、touchイベント等に置き換える）のですが効果はなく、tappable.jsというものを見つけてそれを使ってclickイベントをtappable.jsで置き換えてみてエミュレータで動いた時は喜んだのですが、エミュレータと同じandroid-10（ginger bread）の実機（IS05）で試すと相変わらずイベントが発生しないというおかしな状況になりました。どうも複数の原因が関わっているようでエミュレータで動いたのは偶々だったようです。イベントの発生順序にも関係してそうだったのでclickイベント（というかtapイベント）のcallback設定をいろんな場所（deviceready, DOMContentLoaded, load, pageinit, $document.ready）に書いて確認したのですが動いたり動かなかったりという泥沼に陥りました。しつこいようですがandroid2.3の場合だけです。&lt;br /&gt;
　いくつか&lt;a href=&quot;https://forum.jquery.com/topic/javascript-function-not-called-on-button-click-event-android-app-using-jquery-mobile&quot;&gt;ヒントになるサイト&lt;/a&gt;はあったのですがJQMがやっている処理をandroidのバージョンによって切り分ける作業が必要そうで、それは大変なので結局ダイアログの表示内容を簡素化してpluginのダイアログ（navigator.notification）を使うことで回避しました。&lt;br /&gt;
　ネットや本ではjQueryMobileは重いのでzepto.jsを使いましょう、という助言はよく見かけていたのですが、PCサイトから作り始めた私は特に問題なく動いているしパフォーマンスを気にするようなものでもなく試しに作ってみたようなシンプルなテーブルゲームアプリなのでそのままJQMを使っていたのですが、古いandroid機でも動作させるつもりなら今でもzeptoを使ったほうがいいのかもしれません。私の場合はginger breadのシェアも落ちてきているのでJQMのままで良しとしました。&lt;/p&gt;

&lt;h3 id=&quot;android41jellybeanでadmobを使うと広告表示のタイミングで落ちる&quot;&gt;android4.1(JellyBean)でadmobを使うと広告表示のタイミングで落ちる&lt;/h3&gt;
&lt;p&gt;　エミュレータを作成して試している限りでは正常に広告が表示されるのですが、実機で試すと広告が表示されるタイミングでアプリが落ちるという現象に悩まされました。android4.1.xだけで発生するバグのよう（私の持っている実機が4.1.2です!?）で、onAdFailedToLoadイベント等でも拾うことも出来ずにいきなりアプリ毎終了します。&lt;a href=&quot;https://github.com/floatinghotpot/cordova-plugin-admob/issues/92&quot;&gt;admobのオプションでoverlap:trueにするとこのバグを回避できる&lt;/a&gt;ようなのでとりあえずそうしましたが時間を取られました。リンク先にも書かれているようにandroidのバージョンによって処理を分けるのが良さそうです。&lt;/p&gt;

&lt;h3 id=&quot;android23ginger-breadだとjsonpでデータが取得できない&quot;&gt;android2.3(ginger bread)だとJSONPでデータが取得できない？？？&lt;/h3&gt;
&lt;p&gt;　これもまた古いandroidの場合だけでしたが、ランキング表示ダイアログを別のhtmlファイルで作成していたものをSPA(SinglePageApplication)にするために、同じhtmlファイル内にJQMのページ（data-role=”page”）に変更したら、ダイアログ表示時にサーバーにアクセスに行かないようになってしまいました。別ファイルを読み込んだ時にscriptタグ内のJavaScriptでサーバーからデータを取得するようにしていた処理を、JQMの場合はpageinitかpageshowイベントでやるように変更しなければいけないのかと思ってpageshowイベント内に書いてみてもpageshowイベントが発生しません。android4.1の場合は何も書き換えなくてもデータ取得できるにも拘らずです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;        function cb(u){
            //省略
        }
        function ranking_regist(username){
            location.href = &quot;#win_show_ranking&quot;;

            //以下JSONPデータ取得処理
            var s = document.createElement('script');
            s.src = URL;  // http://hogehoge?callback=cb&amp;amp;…省略
            document.getElementsByTagName(&quot;head&quot;)[0].appendChild(s);
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　
　上記コードで&lt;code&gt;location.href = &quot;#win_show_ranking&quot;&lt;/code&gt;とやっているところは非同期で実行され、ページ遷移の完了を待たずにその後のコードが実行されるわけですが、その後のコードが実行される間にページ遷移の処理が何処かでキャンセルされてしまってページが表示されずサーバーへのアクセス自体も発生しなくなりました。JSONPレスポンスを受け取るのにandroidのバージョンが関係あるわけないと思いながらも、古いandroidだと何か理由があるのか？と思い、データ取得の部分をajaxに書き換えてpageshowイベントに書いて試したりしましたが、android2.3では相変わらず動きませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;            $.ajax({
                type: 'GET',
                url: URL,
                dataType: &quot;jsonp&quot;,
                jsonpCallback: &quot;callback&quot;,
                async : true,
                success: function(u) {
                    cb(u);
                }
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　android4.1では動くというのが混乱の元のような気がしますが、問題は&lt;code&gt;location.href = &quot;#win_show_ranking&quot;&lt;/code&gt;の部分でした。&lt;a href=&quot;https://www.buildinsider.net/web/jquerymobileref/34&quot;&gt;このサイト&lt;/a&gt;に書いてあるようにjavascriptを使って画面遷移するのではなく、JQMのchangeメソッドを使って画面遷移しなければいけないようです。&lt;code&gt;location.href = &quot;#win_show_ranking&quot;&lt;/code&gt;と書いている部分を&lt;code&gt;pagecontainer('change', '#win_show_ranking', {allowSamePageTransition: false});&lt;/code&gt;と書き換えれば問題なく動作しました。&lt;br /&gt;
　逆に何で新しいandroidだと動くのかについてはよくわかりませんが、JQMはajaxを無効にして使うことも出来るようなので、古いandroidについては面倒を見るのを止めてサポートを切り捨てたけど、新し目のバージョンに関してはどちらでも動くようになっているということでしょうか？それとも偶々動いただけかもしれません。&lt;br /&gt;
　JQMのことをよく調べずに使い始めたのがよくなかったみたいです。それに現在はJQMを使っているといってもほとんど画面レイアウトにしか使っていない状態なのでJQMの機能をもう少し取り込んで行こうと思っているのですが、そうするとまた新たな問題が出て来るのでしょう。&lt;/p&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>HerokuでNodeとMongoDBを使う</title>
   <link href="https://happyclam.github.io/programming/2015-04-25/mongo_upsert"/>
   <updated>2015-04-25T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2015-04-25/mongo_upsert</id>
   <content type="html">&lt;h3 id=&quot;スマホアプリからサーバに接続してデータ取得&quot;&gt;スマホアプリからサーバに接続してデータ取得&lt;/h3&gt;
&lt;p&gt;　以前から記事に書いている三目並べプログラムをとりあえず&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;androidアプリ&lt;/a&gt;にしてみたのですが、単なる三目並べだとつまらないので一手の時間制限を設けて連続無敗記録を保存するように変更しました。そして今度はその記録をユーザ間で競ってもらおうと思い、サーバーを用意してスマホ上でランキング表示する機能をつけることにしました。&lt;br /&gt;
　ユーザ認証などの機能をつけると利用者側にとって敷居が高くなるので、適当なハンドルネームを登録してランキング表示するだけの機能です。単純な機能（スマホからハンドルネームを登録し、JSONPでランキングデータを取得する）なのでどうせなら今までやったことない方法でと思いNode.jsとMongoDBを使うことにしました。いろいろ印象に残ったことを書いてみます。&lt;/p&gt;

&lt;h3 id=&quot;今までにもあっても良さそうなのに無かったupsert&quot;&gt;今までにもあっても良さそうなのに無かったupsert&lt;/h3&gt;
&lt;p&gt;　いや、昔からどこかで使われていた機能かもしれませんが私は知りませんでした。InsertとUpdateを合わせてUpsert。document（recordとは言わないらしい）が存在していれば更新し、なければ新規登録する機能です。私の経験ではOracleにもSybaseにもSQL Serverにもなかったはずです。さすがNoSQLです。&lt;br /&gt;
　で、使ってみると新規にInsertした場合のid値をどうやって取得するのか悩みましたが、先にid値を生成してからUpsertを呼び出すようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      //uidで検索する例
      //新規とわかっている場合はuidにnullを入れてid生成
      var doc = {uid:null, name:username, score:unbeaten, date: null};
      var collection = db.collection(&quot;tictactoe&quot;);
      temp_id = new ObjectID(uid);
      collection.update({_id: temp_id}, {name:username, score:unbeaten, date: new Date()}, {upsert:true, w: 1}, function(err, result) {
        if (err) { throw err; }
        collection.findOne({_id: temp_id}, function(err, item) {
          if (err) { throw err; }
          if (item) {
            doc._id = item._id;
            doc.date = item.date;
          }
        });
      });
         
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;出来るだけ新しいバージョンで開発環境を作る&quot;&gt;出来るだけ新しいバージョンで開発環境を作る&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://www.oreilly.co.jp/books/9784873116068/&quot;&gt;Nodeクックブック&lt;/a&gt;という本を参考にしていたのですが、ネット上に転がっていた古いコードから書き始めたのが間違いの元で、本のサンプルコードが動かない環境で一通り作った後に何度も同じ箇所を書き換えなければいけない羽目に陥りました。古いバージョンのままでも動けばいいのですが、何かトラブルに見舞われた時に「もしかしてバージョンが古いせいか？新しくしてみよう」となって直接トラブルとは関係ないのに書き直す羽目に陥ったということです。皆さんも気をつけて下さい。特にExpressはバージョンによって書式（構文）の変化が激しくて、バージョンが変わるともうそれは必要がなくなったというコードが多かったです。依存関係で深刻なものは無かったのですが、自分が使っているパッケージのバージョンは把握しておいた方が右往左往しなくて済みそうです。以下が現時点で使っているパッケージ（package.json）ファイルの一部です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  , &quot;dependencies&quot;: {
      &quot;express&quot;: &quot;4.12.1&quot;
    , &quot;jade&quot;: &quot;&amp;gt;= 0.0.1&quot;
    , &quot;mongodb&quot;: &quot;2.0.27&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;0.10.20&quot;,
    &quot;npm&quot;: &quot;2.8.3&quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　Expressで悩まされた一例として、本に記載されている通り以下のようにlessファイルを指定したのですが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//app.js
app.use(require('less-middleware')({
   src: __dirname + '/views',
   dest: __dirname + '/public',
   compress: true
}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　上手くいかなくて、&lt;a href=&quot;https://stackoverflow.com/questions/22274832/public-static-directory-typeerror-arguments-to-path-join-must-be-strings&quot;&gt;ここ&lt;/a&gt;に書いてある通り以下のように修正すれば動きました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//app.js
app.use(require('less-middleware')(__dirname + '/public'));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　src:とdest:を分けて指定するのではなく、一つ（/public）だけ指定すればそこにあるlessファイルを読み込んで同じディレクトリにcssファイルを出力するという形で上手く機能しています。よく調べればオプションがあるのかも知れません。&lt;br /&gt;
　あと、Rubyのrvm環境同様にNodeも最初からnvmを使って複数のバージョンを切り替えられるようにしておいたほうがよさそうです。&lt;/p&gt;

&lt;h3 id=&quot;ローカルで動くのにheroku上で動かない&quot;&gt;ローカルで動くのにHeroku上で動かない&lt;/h3&gt;
&lt;p&gt;　herokuで動かないのはMongoDBへの接続が出来ていないようだということはすぐわかったのですが、&lt;a href=&quot;https://d.hatena.ne.jp/koda_hd28v/20120512/1336799056&quot;&gt;この記事&lt;/a&gt;を見つけるまで理由がわかりませんでした。ローカルではDBオブジェクトをnewしてServer.open、herokuではconnectを使うということのようです。ローカル環境にデータベースが存在しているわけじゃないんだからopen出来ると考える方がおかしいと言われそうですが、herokuもMongoDBもどこまで私の面倒を見てくれるのかわからないんだから、ローカルで動くんだからそのまま動くと考えてしまっても仕方がないと思います。&lt;br /&gt;
　で、記事の中で説明してくれているように、以下のようにDB接続モジュールだけ分割して&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// lib/MongoBuilder.js
var mongo = require('mongodb');

module.exports.ready = function(db_name, callback){
  if ( process.env.MONGOLAB_URI ){
    mongo.connect(process.env.MONGOLAB_URI, {}, function(err, db){
      callback(db);
    });
  }else{
    new mongo.Db('tictactoe', new mongo.Server('localhost', 27017), {safe: false}).open(function(err,db){
      callback(db);
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　以下のように使用すれば、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// routes/index.js
var MB = require(&quot;../lib/MongoBuilder&quot;);
var users = new Array();
exports.mypage = function(req, res){
  MB.ready('tictactoe', function(db){
    var collection = db.collection(&quot;tictactoe&quot;);
    collection.find().sort({score: -1}).limit(100).toArray(function(err, users){
      res.render('index', {title: 'Tictactoe Unbeaten', users: users});
    });
  });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　ローカル環境でもheroku環境でも動くように出来ました。&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>新Macbook購入</title>
   <link href="https://happyclam.github.io/hardware/2015-04-14/macbook"/>
   <updated>2015-04-14T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/hardware/2015-04-14/macbook</id>
   <content type="html">&lt;h3 id=&quot;発売日翌日にゲット&quot;&gt;発売日翌日にゲット&lt;/h3&gt;
&lt;p&gt;　発売日（４月１０日）にはアップルストアでも入手できた人はいなかったようなので、ダメモトで梅田のヨドバシに朝一番で行ってみると幸運なことに買うことができました。開店早々Appleのブースに行くと男ばかり１４、５人がたむろしていて３台の展示機に何人か並んでいました。自分は既に買うことは決めていたので試用する気もなくすぐに店員に「買えるんですか？欲しいんですけどっ」と伝えると「はい、今在庫を確認しているところです」と他の客からも質問されているらしく慌てている感じで、どういう風に対応すべきか迷っている感じでした。結局、他からも店員がワラワラと集まってきて、客たちが希望する機種を個別に聞いて在庫確認のために消えていくって感じで店に来た順番とかは関係ない感じで進んでいました。確かに購入を決めている客ばかりでも無さそうだったので順番に並んでくださいと誘導するわけにもいかなかったのでしょう。目の前で購入できている人がいるのに目当ての機種が買えなかったら辛いなぁと思いながらもラッキーなことにほどなく購入（MacBookスペースグレイ512GB）することが出来ました。自分が購入できた後はすぐに店を出たのでわかりませんが、購入できた人とできなかった人で揉めたりしたのでは無いかとちょっと心配になりました。ヨドバシとしては新MacBookに人が集まるのが意外だったのかもしれません。店に着いたとき外に行列（確認してみたところ妖怪メダル目当ての行列だったそうです）が出来ていて店員が誘導して整列させていたんですが、ヨドバシ全体の取扱商品から考えたら新MacBookなんてものはかなりマイナーなものでしかないんでしょう。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/macbook_samp0.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/macbook_samp0.png&quot; alt=&quot;MacBook 12-inch Space Gray 512GB&quot; title=&quot;MacBook 12-inch Space Gray 512GB&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/macbook_samp1.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/macbook_samp1.png&quot; alt=&quot;MacBook 12-inch Space Gray 512GB&quot; title=&quot;MacBook 12-inch Space Gray 512GB&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;vaio-type-pは今までで一番気に入ったモバイルpc&quot;&gt;Vaio type Pは今までで一番気に入ったモバイルPC&lt;/h3&gt;
&lt;p&gt;　2009年に発売されたソニーのVAIO type P（&lt;a href=&quot;https://www.vaio.sony.co.jp/Products/P1/&quot;&gt;VGN-P90S&lt;/a&gt;）を今でも使用している人はかなり少数派だと思いますが、サードパーティから購入した中国製の予備のバッテリーを駆使しながら今まで使ってきました。キーボードは打ち易いし解像度はUWXGA（1600×768）というMacBookAirより広い環境でRailsを使ったWebアプリ開発機としてもドキュメント作成用としても結構満足して使っていましたが、CPUが非力なのでEclipseを使ったりandroidアプリ開発（エミュレータが重い）には使えないなと感じていました。&lt;br /&gt;
　私の場合Vaioは購入当初からUbuntuやLinuxMintやlubuntuに入れ替えて使っていたので、Windowsの新作モバイルPCが出る度に気は進まないけどまた購入してすぐにWindowsを削除して使おうかなんてことも考えていましたが、そこまでするほどVaioよりいいと思えるモバイルPCはなかったしiPhoneアプリの開発もやってみたいって理由もあってMacBookAirの高解像度版が出れば乗り換えようと思いながら今まで使ってきました。MacBookAir買えばいいじゃないかという人がいると思いますが、過去の経験からMacBookAir11の解像度では開発は出来ないと思っていたし、MacBookAir13は持ち歩く気はしないというか、正確に言うと持ち歩くのはまだいいんですが出先で使うときの占有面積が広いのでちょっと邪魔だなって感じです。以上のような結果として自分にとってVaioPは今までで一番長期にわたって使い尽くしたモバイルPCになりました。&lt;br /&gt;
　そこであまり他の人の役には立たないと思いますがあくまで自分目線でVaioPとの勝敗表を作ってみました。上の項目ほど自分が重視する点です。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MacBook&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;解像度&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;○&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;キーボード&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;◎&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CPU・SSD&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;◎&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バッテリーの持ち&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;◎&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ポインティングデバイス&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;○&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;重さ&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;邪魔さ&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;熱（ファンレス）&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;△&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;周辺機器・アクセサリー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;◎…大差で勝ち、◯…勝ち、△…引き分け、×…負け&lt;/p&gt;

&lt;p&gt;USB機器やアクセサリー類は今後時間とともに解決していくことでしょう。まずはVaioPで使っていたような&lt;a href=&quot;https://www.sony.jp/vaio/products/VGP-CKP1/&quot;&gt;革製のケース&lt;/a&gt;が欲しいです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/comp_vaio.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/comp_vaio.png&quot; alt=&quot;MacBook 12-inch and Vaio P&quot; title=&quot;VaioPとの比較&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;新macbookの使用感&quot;&gt;新MacBookの使用感&lt;/h3&gt;
&lt;dl&gt;
  &lt;dt&gt;解像度&lt;/dt&gt;
  &lt;dd&gt;ハードウェアに関しては詳しく無いのですがRetinaディスプレイになればもっと高解像度になると思っていたので1440x900は少々残念です。これならVaioP（1600x768）と大差ありません。&lt;/dd&gt;
  &lt;dt&gt;キーボード&lt;/dt&gt;
  &lt;dd&gt;新開発のバラフライキーボードは快適です。ストロークが浅いなんて聞いていたけどまさかDELLのXPS11（型番は知りませんがフィルムタイプ？のストローク無しのキーボード）ほど酷いものでは無いだろうと思っていた通り、自分にとっては十分すぎる打ち易さです。言われてみれば確かにちょっと浅いかなって感じで、違和感はありませんでした。VaioPも小さな筐体の割には良く出来た打ち易いキーボードだと思いますが、やはりMacBookを触った後にVaioPのキーボードを打つとその違いを痛感します。あと、キーストローク音がVaioPがペチッペチッって感じなのですが、MacBookはコトコトコトって感じで高級感があります。&lt;/dd&gt;
  &lt;dt&gt;CPU・SSDスペック&lt;/dt&gt;
  &lt;dd&gt;VaioPでそこそこ満足していた自分にとっては十分過ぎる速さです。比較する意味も無いのですが、同じandroidアプリをビルドしてエミュレータ画面に起動するまでVaioPだと１５分!?（エミュレータは実機より遅いんです）かかる処理がMacBookだと２分で済みました。&lt;/dd&gt;
  &lt;dt&gt;バッテリー&lt;/dt&gt;
  &lt;dd&gt;今までは電源を確保するために仕方なくスタバを選択することも多かったので今回の買い替えでようやく電源の確保から解放されると思っていますがいつまで持つか不安です。今のところまだ出先での通常の使い方をしていないのでチェックしきれてませんが、新品の今でも動画を見るとすごい勢いでバッテリーが減っていきますので1年後には出先で電源を気にしなくていけなくなるような気がします。&lt;br /&gt;
　発熱に関してはもっとCPUを酷使してもいいのではないかと思うほどPC底面の温度は低いです。VaioPと比べても断然低くてまったく熱くなりません。冷たいといってもいいぐらいです。&lt;/dd&gt;
  &lt;dt&gt;トラックパッド&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/dt&gt;
  &lt;dd&gt;今までタッチパッドと言われる入力デバイス付きのノートPCを所有していた時期もありますが、ほとんどパッドを使ったことはなくマウスを外付して使っていました。モバイルPCを買うときにThinkPad,Libretto,C1R,VaioPと選択してきたのもトラックポイント（メーカーによって呼び名が違うようですが）が使えることが大きな要因でもありました。トラックポイントのほうが使いやすい面もありますがMacのトラックパッドは機能が豊富でこれなら外付けマウスを付けなくてもよさそうです。&lt;/dd&gt;
&lt;/dl&gt;

&lt;h3 id=&quot;まとめ&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　レビューというより日記なので皆さんの役には立たなかったかもしれませんが、今のところVaioP以上に使い続けたくなるモバイルPCになるような気がしています。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;トラックパッドについてとVaioPとの比較写真を追加しました &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>HTML5でアニメーション</title>
   <link href="https://happyclam.github.io/programming/2015-03-26/html5_anim"/>
   <updated>2015-03-26T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2015-03-26/html5_anim</id>
   <content type="html">&lt;h3 id=&quot;タイマーを使わない&quot;&gt;タイマーを使わない&lt;/h3&gt;
&lt;p&gt;　HTML5でアニメーションを実現する方法を調べてみたら、タイマーを使う必要が無くなったらしい（タイマー間隔をブラウザ任せに出来る）のでやってみました。それぞれのブラウザ用にAPIが分かれているようで今後どうなるかわかりません（HTML5自体がまだまだ流動的だと思いますが）が、結構以前（HTML5リリース当初）からこのやり方は定着しているらしいです。手元のAndroid4.1.2の端末（GL07S）でも問題なく動きました。IEでHTML5を利用するにはIE9以上が必要です。&lt;/p&gt;

&lt;h3 id=&quot;二点の座標をクリックして直線を引くサンプル&quot;&gt;二点の座標をクリックして直線を引くサンプル&lt;/h3&gt;
&lt;p&gt;　要するにRequestAnimationFrameというAPIを使えばいいという話なのですがネットでandroidの対応状況は4.1以上でも全滅という書き込みをちらほら見かけます。でも、実際にやってみると以下のCoffeeScriptをコンパイルしたanimation.jsとanimation.htmlをandroid端末（GL07s）にコピーしてURL指定すれば標準ブラウザでふつうに動作しました。ネットではjQueryといっしょに使用することで問題が出るという書き込みも見かけましたが無視することにしました。知らないうちに解決されたのでしょう&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;img class=&quot;emoji&quot; title=&quot;grin&quot; alt=&quot;grin&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/grin.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;br /&gt;
　実際にアニメーションを駆使するスマホアプリを作るときは、既存のいろんなライブラリを使うことが多いのかもしれませんがHTML5だけで出来るほうがシンプルでいいですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CoffeeScript&quot;&gt;#animation.coffee
$ -&amp;gt;

    return new Animation()
    
class Animation
    constructor: -&amp;gt;
        @canvas = document.getElementById(&quot;canvasMain&quot;)
        @areaStartX = document.getElementById(&quot;spanStartX&quot;)
        @areaStartY = document.getElementById(&quot;spanStartY&quot;)
        @areaEndX = document.getElementById(&quot;spanEndX&quot;)
        @areaEndY = document.getElementById(&quot;spanEndY&quot;)
        @start = {x:0, y:0}
        @end = {x:100, y:100}
        @request = null
        @amount = 0
        @startflg = true
        @setEventListener()
        @touch(@start.x, @start.y)
        @touch(@end.x, @end.y)

    touch: (clientX, clientY) =&amp;gt;
        if @startflg
            @startflg = false
            @start.x = clientX; @areaStartX.innerHTML = clientX
            @start.y = clientY; @areaStartY.innerHTML = clientY
        else
            @startflg = true
            @end.x = clientX; @areaEndX.innerHTML = clientX
            @end.y = clientY; @areaEndY.innerHTML = clientY
        
    setEventListener: =&amp;gt;
        $('#canvasMain').on 'click', (e) =&amp;gt;
            @touch(e.clientX, e.clientY)

        $('#btnStart').on 'click', (e) =&amp;gt;
            @animate()
        
    animate: =&amp;gt;
        @request = requestAnimFrame(@animate, @canvas)
        @drawanimation()

    drawanimation: =&amp;gt;
        @context = @canvas.getContext('2d')
        @context.clearRect(0, 0, @canvas.width, @canvas.height)
        @amount += 0.02
        @amount = 1 if @amount &amp;gt; 1
        @context.beginPath()
        @context.moveTo @start.x, @start.y
        @context.strokeStyle = 'rgba(255, 105, 180, 0.7)'
        @context.lineWidth = 12
        newX = @start.x + (@end.x - @start.x) * @amount
        newY = @start.y + (@end.y - @start.y) * @amount
        @context.lineTo newX, newY
        @context.stroke()
        if newX is @end.x and newY is @end.y
            cancelRequestAnimFrame @request
            @request = null
            @amount = 0

window.Animation = window.Animation || Animation

window.requestAnimFrame = (-&amp;gt;
  window.requestAnimationFrame or window.webkitRequestAnimationFrame or window.mozRequestAnimationFrame or window.oRequestAnimationFrame or window.msRequestAnimationFrame or (callback, element) -&amp;gt;
    window.setTimeout callback, 1000 / 60
)()
window.cancelRequestAnimFrame = (-&amp;gt;
  window.cancelAnimationFrame or window.webkitCancelRequestAnimationFrame or window.mozCancelRequestAnimationFrame or window.oCancelRequestAnimationFrame or window.msCancelRequestAnimationFrame or clearTimeout
)()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-HTML&quot;&gt;&amp;lt;!-- animation.html --&amp;gt;

&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.2.min.js&quot;&amp;gt; &amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;animation.js&quot;&amp;gt; &amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;アニメーションのテスト&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;canvas id=&quot;canvasMain&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;background-color: #2f4f4f;&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
    &amp;lt;form&amp;gt;
      &amp;lt;p&amp;gt;
      開始点　X=&amp;lt;span id=&quot;spanStartX&quot;&amp;gt;&amp;lt;/span&amp;gt;:
      Y=&amp;lt;span id=&quot;spanStartY&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;br /&amp;gt;
      終了点　X=&amp;lt;span id=&quot;spanEndX&quot;&amp;gt;&amp;lt;/span&amp;gt;:
      Y=&amp;lt;span id=&quot;spanEndY&quot;&amp;gt;&amp;lt;/span&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;input id=&quot;btnStart&quot; type=&quot;button&quot; value=&quot;描画&quot;&amp;gt;
      &amp;lt;/p&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;黒板に赤チョークのイメージです（赤チョークって確かこういうピンクっぽい色だった記憶があります）&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/animation.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/animation.png&quot; alt=&quot;実機画面&quot; title=&quot;実機（gl07s）で動作確認&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/project/2015-02-01/first_cordova/&quot;&gt;前回記事&lt;/a&gt;で作成した&lt;a href=&quot;https://tictactoe-cf.herokuapp.com&quot;&gt;サイト&lt;/a&gt;にも適用。白線もチョークっぽく掠れた感じにしようかと思いましたが暗くなるので止めました&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/3mokunarabe.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/3mokunarabe.png&quot; alt=&quot;三目並べアプリ画面&quot; title=&quot;実機（gl07s）で三目並べアプリ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;RequestAnimationFrame APIの対応状況は&lt;a href=&quot;https://caniuse.com/#feat=requestanimationframe&quot;&gt;ここ&lt;/a&gt;です。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>iOS/Androidハイブリッドアプリ開発</title>
   <link href="https://happyclam.github.io/project/2015-02-01/first_cordova"/>
   <updated>2015-02-01T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2015-02-01/first_cordova</id>
   <content type="html">&lt;p&gt;Project: 「&lt;a href=&quot;https://tictactoe-cf.herokuapp.com&quot;&gt;&lt;strong&gt;CoffeeScript版三目並べ&lt;/strong&gt;&lt;/a&gt;」: &lt;a href=&quot;https://github.com/happyclam/tictactoe-cf&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;まずは通常のwebサイトを作成&quot;&gt;まずは通常のWebサイトを作成&lt;/h3&gt;
&lt;p&gt;　ハイブリッド開発と言っても私は現時点ではiPhoneを持っていないのでAndroidでしか確認できませんが、HTML5とJavaScript（CoffeeScript）でPC上で開発しそれをAndroidとiPhoneで利用出来るなんて虫のいい話があるのなら是非やってみたくなります。HTML5のローカルストレージなんかもいろいろ可能性が広がる気がしますがとりあえず以前作ったRuby製コンソールアプリを使ってHTML5のCanvas機能を試してみたいと思います。&lt;br /&gt;
　まずは&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;以前の記事&lt;/a&gt;で作成した&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;Ruby製のコンソールプログラム&lt;/a&gt;をCoffeeScriptに書き換えていきます。&lt;a href=&quot;/programming/2015-01-25/ruby_to_js&quot;&gt;前回の記事&lt;/a&gt;以降特に苦労は無かったのですがRubyからCoffeeScriptへのコンバート作業に関しては触れずに、今回はAndroidアプリ化に関して書きます。&lt;/p&gt;

&lt;h3 id=&quot;cordovaphonegapプロジェクトの作成&quot;&gt;cordova（PhoneGap）プロジェクトの作成&lt;/h3&gt;
&lt;p&gt;　作成したCoffeeScriptをコンパイル（&lt;code&gt;coffee -c tictactoe.coffee&lt;/code&gt;）したjsファイルとindex.htmlだけのサイトですが、Androidアプリ化するためにした作業は以下の通りです。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通常のWebサイトとして動作確認&lt;/li&gt;
  &lt;li&gt;cordovaコマンドを使ってプロジェクト作成&lt;/li&gt;
  &lt;li&gt;作成したプロジェクトのwwwディレクトリ内のindex.htmlファイル内のbodyタグの中身をPCサイトのindex.htmlの内容に置き換える＆作成したJavaScriptファイルを読み込むscriptタグを追記。&lt;/li&gt;
  &lt;li&gt;エミュレータ上で動作確認&lt;/li&gt;
  &lt;li&gt;実機で動作確認&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;tree
.
├── index.html
├── js
│   └── jquery-1.11.1.min.js
├── tictactoe.coffee
└── tictactoe.js

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;cordova create Tictactoe com.herokuapp.tictactoe Tictactoe -d
cd Tictactoe
cordova platform add android
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　cordovaコマンドで生成したindex.htmlの雛形にPCサイト用のindex.htmlの中身をコピペ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#index.html
#header部は省略
    &amp;lt;body&amp;gt;
      &amp;lt;p id=&quot;title&quot;&amp;gt;三目並べ（TicTacToe）&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;canvas id=&quot;canvasMain&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;div id=&quot;orders&quot;&amp;gt;
          &amp;lt;input type=&quot;radio&quot; name=&quot;optOrders&quot; id=&quot;optOrder1&quot; value=&quot;-1&quot; checked=&quot;checked&quot;&amp;gt;First
          &amp;lt;input type=&quot;radio&quot; name=&quot;optOrders&quot; id=&quot;optOrder2&quot; value=&quot;1&quot;&amp;gt;Second
        &amp;lt;/div&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;input id=&quot;btnStart&quot; type=&quot;button&quot; value=&quot;Start!&quot;&amp;gt;
        &amp;lt;span id=&quot;spanStatus&quot;&amp;gt;&amp;lt;/span&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script src=&quot;js/jquery-1.11.1.min.js&quot;&amp;gt; &amp;lt;/script&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot; src=&quot;tictactoe.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cordova emulate android -d
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/tictactoe_emulator.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/tictactoe_emulator.png&quot; alt=&quot;エミュレータ画面&quot; title=&quot;エミュレータで動作確認&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;cordova run android
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/tictactoe_gl07s.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/tictactoe_gl07s.png&quot; alt=&quot;実機画面&quot; title=&quot;実機（gl07s）で動作確認&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　cordovaプロジェクト下のwww内のファイルを修正してcordovaコマンドを実行すると、platforms/android/以下にAndroid用のファイルが出力されるようです。ビルドしてエミュレータや実機にインストールして実行するまで一気に行うので上記のようにあっという間に完成しました。このビルド作業を行う環境構築の方が時間がかかるかもしれません。環境構築については&lt;a href=&quot;https://www.amazon.co.jp/Android%E5%AF%BE%E5%BF%9C-HTML5-%E3%83%8F%E3%82%A4%E3%83%96%E3%83%AA%E3%83%83%E3%83%89%E3%82%A2%E3%83%97%E3%83%AA%E9%96%8B%E7%99%BA-Software-Design/dp/4774162116/ref=tmm_pap_title_0?ie=UTF8&amp;amp;qid=1421726606&amp;amp;sr=1-1&quot;&gt;この本&lt;/a&gt;を参考にしましたが、個人的にはRubyの開発環境と同じく、ユーザ領域に構築（sudoを使わない）する方がいいのではないかと思ってます。&lt;br /&gt;
　それにしても以前droidgapコマンド（cordovaの前身？）の時はeclipseを使わなければいけなかったり、いろいろトラブルに見舞われた記憶があるのですが、思った以上に簡単でした。でも、このままだと見た目もUIも貧弱過ぎるのでjquery mobileを使って追加・修正していくことになると思いますが、そうするとPCサイト用とは別物になっていくのでしょう。そのあたりも今後確認していこうと思います。&lt;/p&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>Ruby製プログラムをCoffeeScript（JavaScript）に書き換える</title>
   <link href="https://happyclam.github.io/programming/2015-01-25/ruby_to_js"/>
   <updated>2015-01-25T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2015-01-25/ruby_to_js</id>
   <content type="html">&lt;h3 id=&quot;クライアントサイドの入力チェック用だったjavascriptが今は主役&quot;&gt;クライアントサイドの入力チェック用だったJavaScriptが今は主役&lt;/h3&gt;
&lt;p&gt;　以前Titaniumを弄ったときはどうしてもJavaScriptに積極的に取り組む気にはなれなかったのですが、cordova（PhoneGap）の存在を知り&lt;a href=&quot;https://www.amazon.co.jp/Android%E5%AF%BE%E5%BF%9C-HTML5-%E3%83%8F%E3%82%A4%E3%83%96%E3%83%AA%E3%83%83%E3%83%89%E3%82%A2%E3%83%97%E3%83%AA%E9%96%8B%E7%99%BA-Software-Design/dp/4774162116/ref=tmm_pap_title_0?ie=UTF8&amp;amp;qid=1421726606&amp;amp;sr=1-1&quot;&gt;[iOS/Android対応] HTML5 ハイブリッドアプリ開発[実践]入門&lt;/a&gt;という本を読んで、またJavaScriptを使ったandroidアプリ開発への興味が戻って来ました。Titaniumを弄ったときと違って自分にとってはCoffeeScriptの存在が大きい、JavaScriptは嫌いだけどCoffeeScriptならやる気が湧きます。なので試しに以前記事を書いたRuby製の三目並べのプログラムをCoffeeScript（最終的にはJavaScriptを使ったandroidアプリ）に移植して見ようと思い取り組み始めたらいきなり問題に遭遇したのでTips的に記事を書いてみます。&lt;br /&gt;
　それにしても昔のWebシステムはブラウザのJavaScript機能がOffでも使えることを要求されたものなのに、リッチなUIを要求するユーザーの声がどんどん大きくなり、最近ではJavaScript（jQuery,Ajax）無しは考えられない感じですね。そしてどうせJavaScriptを避けることが出来ないのなら、どうにかしてJavaScriptを楽に生成しようという流れが続いてます。&lt;/p&gt;

&lt;h3 id=&quot;arrayクラスを継承したrubyのクラスをjavascriptに&quot;&gt;Arrayクラスを継承したRubyのクラスをJavaScriptに&lt;/h3&gt;
&lt;p&gt;　三目並べの盤を表現するArrayクラスを継承した以下のコードを&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#tictactoe.rb
class Board &amp;lt; Array
  def initialize(*args, &amp;amp;block)
    super(*args, &amp;amp;block)
  end
end

b = Board.new([1, 2, 3, 4, 5, 6, 7, 8, 9])
p b[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のようにCoffeeScriptに書き換えて実行したところ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;#tictactoe.coffee
class Board extends Array
    constructor: (args) -&amp;gt;
        super(args)

b = new Board([1, 2, 3, 4, 5, 6, 7, 8, 9])
console.log b[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画面には&lt;code&gt;undefined&lt;/code&gt;と表示されました。エラーにもなりません。コンストラクタに渡されたargsパラメータはどこに行ったのでしょうか？&lt;code&gt;super(args)&lt;/code&gt;の行を&lt;code&gt;@ = args&lt;/code&gt;とやったらエラーになります&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;br /&gt;
　以下のようにパラメータを可変個引数にして、配列要素をバラバラのパラメータにして渡しても同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#tictactoe.coffee
class Board extends Array
    constructor: (args...) -&amp;gt;
        super(args...)

b = new Board(1, 2, 3, 4, 5, 6, 7, 8, 9)
console.log b[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　試しにArrayクラスに新しいプロパティを追加してあげるとそちらの方はちゃんと代入出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;#tictactoe.coffee
Array::data = []
class Board extends Array
    constructor: (args) -&amp;gt;
        super(args)
        @.data = args

b = new Board([1, 2, 3, 4, 5, 6, 7, 8, 9])
console.log b[3]
console.log b.data[3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;まず、JavaScriptでもクラスの拡張（オープンクラス？）が簡単に出来ることに驚きました。Rubyと同様にオブジェクト指向出来るんですね。でもこのCoffeeScriptをJavaScriptに変換した中身を見てみると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$coffee -c tictactoe.coffee
$cat tictactoe.js
// Generated by CoffeeScript 1.6.3
(function() {
  var Board, b,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Array.prototype.data = [];
  Board = (function(_super) {
    __extends(Board, _super);
    function Board(args) {
      Board.__super__.constructor.call(this, args);
      this.data = args;
    }
    return Board;
  })(Array);
  b = new Board([1, 2, 3, 4, 5, 6, 7, 8, 9]);
  console.log(b.data[3]);
  console.log(b[3]);
}).call(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんじゃこりゃ〜。CoffeeScriptを介さずに元のRubyのコードからこのJavaScriptのコードを書ける気がしない。慣れの問題もあるでしょうが、CoffeeScriptが見事に抽象化してくれているのがわかります。&lt;br /&gt;
　で、問題のコンストラクタに渡された引数の部分ですが、&lt;code&gt;Board.__super__.constructor.call(this, args);&lt;/code&gt;こうなっていて値を置き換えてくれても良さそうですが入りません。追加したdataプロパティの方は&lt;code&gt;Array.prototype.data = [];&lt;/code&gt;と定義されていて、JavaScriptではprototypeプロパティを介してデータを参照しているようです。なので&lt;code&gt;@.prototype = args&lt;/code&gt;とやったりしましたが値はセットされませんしエラーにもなりません。&lt;code&gt;@ = args&lt;/code&gt;はエラーになりますがpushメソッドは呼べるので、結局コンストラクタで&lt;code&gt;@.push(args[i]) for i in [0...args.length]&lt;/code&gt;とすることでRubyからCoffeeScriptを介してJavaScriptに移植することが出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;#tictactoe.coffee
class Board extends Array
    constructor: (args) -&amp;gt;
        @.push(args[i]) for i in [0...args.length]

b = new Board([1, 2, 3, 4, 5, 6, 7, 8, 9])
console.log b[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　配列の大括弧（[]、bracket）さえもメソッドとして実装しているRubyとの違いかもしれませんが、とりあえず移植できてなによりです。今までJavaScriptに関して真剣に取り組んだことが無かったのですが、&lt;a href=&quot;https://www.amazon.co.jp/%E9%96%8B%E7%9C%BC-JavaScript-%E2%80%95%E8%A8%80%E8%AA%9E%E4%BB%95%E6%A7%98%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B6JavaScript%E3%81%AE%E6%9C%AC%E8%B3%AA-Cody-Lindley/dp/487311621X/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1421851059&amp;amp;sr=1-1&amp;amp;keywords=%E9%96%8B%E7%9C%BC%EF%BC%81javascript&quot;&gt;買ってきた本&lt;/a&gt;を見ながら移植を進めて、また何か問題が発生すれば記事を書いてみます。&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;CoffeeScriptでは@はthisの別名、::はprototypeの別名）。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>checkboxでAjaxで更新（PATCH）処理</title>
   <link href="https://happyclam.github.io/programming/2014-12-26/csrf"/>
   <updated>2014-12-26T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2014-12-26/csrf</id>
   <content type="html">&lt;h3 id=&quot;jqueryajaxcoffeescript覚えること多過ぎ&quot;&gt;jQuery,Ajax,CoffeeScript覚えること多過ぎ&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://my-posi.herokuapp.com/&quot;&gt;先物・オプションのシミュレーションサイト&lt;/a&gt;のポジション編集画面で、チェックボックスをクリックすることでグラフのタイプを切り替える処理（データ更新後リダイレクトしている）をしているのですが、これをAjaxで実現しようとしたところ思わぬエラーに遭遇したので、新規サンプルプロジェクトを作って改めて動作を確認することにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rails _4.1.6_ new chkbox                ←バージョンを指定して新規プロジェクト作成
cd chkbox
rails g scaffold memo body:string chk:boolean
bundle install
rake db:migrate
rails s
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/scaffold_edit.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/scaffold_edit.png&quot; alt=&quot;scaffold 編集画面&quot; title=&quot;scaffold 編集画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　あと、turbolinksを有効にしているとAjaxの動作状況が分かりにくいので&lt;a href=&quot;https://qiita.com/kazz187/items/12737363d62b9c91993c&quot;&gt;このサイト&lt;/a&gt;を参考にしてturbolinksを無効にしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/views/memos/_form.html.erb
 &amp;lt;%= form_for(@memo, remote: true) do |f| %&amp;gt;
   &amp;lt;div class=&quot;field&quot;&amp;gt;
     &amp;lt;%= f.label :body %&amp;gt;&amp;lt;br&amp;gt;
     &amp;lt;%= f.text_field :body %&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div class=&quot;field&quot;&amp;gt;
     &amp;lt;%= f.label :chk %&amp;gt;&amp;lt;br&amp;gt;
     &amp;lt;%= f.check_box :chk %&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div class=&quot;actions&quot;&amp;gt;
     &amp;lt;%= f.submit %&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div id=&quot;status&quot;&amp;gt;&amp;lt;/div&amp;gt;
 &amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/controllers/memos_controller.rb
  def update
    if @memo.update(memo_params)
      @status = &quot;O.K.&quot;
    else
      @status = &quot;N.G.&quot;
    end
    render
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/views/memos/update.js.erb
$('#status').html(&quot;&amp;lt;%= j(@status) %&amp;gt;&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　scaffoldで生成された状態からformに&lt;code&gt;remote: true&lt;/code&gt;を追加してcontrollerをすこし弄ってupdate.js.erbを新規作成しただけですが、フォームのボタンをクリックするとAjax通信でデータの更新処理が完了し、コントローラから渡された文字列をビューに表示出来ます。フレームワークが用意してくれた仕組みを素直に使えば非常に簡単にAjax更新処理が実現できました。&lt;br /&gt;
　そこで今度はフォームのsubmitボタンではなく、チェックボックスをクリックすることで同じことをやろうとしてフォームのcheck_boxの行を&lt;code&gt;&amp;lt;%= f.check_box(:chk, {:onchange =&amp;gt; &quot;this.form.submit();&quot;}, &quot;t&quot;, &quot;f&quot;) %&amp;gt;&lt;/code&gt;と書き換えて、チェックボックスをクリックするとInvalidAuthenticityTokenエラーが出ました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/invalidauthenticitytoken.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/invalidauthenticitytoken.png&quot; alt=&quot;InvalidAuthenticityTokenエラー画面&quot; title=&quot;InvalidAuthenticityTokenエラー画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　javascriptでsubmitしてしまうとcsrf-tokenが送られないということでしょう。ユーザ認証（ログイン処理）していなくてもPOST（この場合PATCH）リクエストを送る場合は必要なのか？と思いながらフォーム内に&lt;code&gt; &amp;lt;%= hidden_field_tag(:authenticity_token, form_authenticity_token) %&amp;gt;&lt;/code&gt;を記述して再度チェックボックスをクリックすると今度はTemplate is missingエラー。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/templatemissing.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/templatemissing.png&quot; alt=&quot;Template Missing エラー画面&quot; title=&quot;Template Missing エラー画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　フォームのPATH指定時にformatを指定してこのように&lt;code&gt;&amp;lt;%= form_for(@memo, url: memo_path(@memo, format: :js), remote: true) do |f| %&amp;gt;&lt;/code&gt;書き換えて、再度チェックボックスをクリックすると、ブラウザにupdate.js.erbファイルの中身が文字として表示されました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/browser_disp.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/browser_disp.png&quot; alt=&quot;Text Response 画面&quot; title=&quot;Text Response 画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　ここまで来てもすぐには自分の間違いに気が付きませんでした。上でも自分で書いているけど、javascriptで普通にsubmitしているのだからAjax通信出来ていないようです。remote: true を書くことでフォームがAjax用になっているからform.submit()でAjax通信が出来るような錯覚をしていました。冒頭で思わぬエラーに遭遇したと書いたのはこのことです^^;&lt;br /&gt;
　HTMLのソースを見てみるとフォームには&lt;code&gt;data-remote=&quot;true&quot;&lt;/code&gt;の属性が付加されていたので、onchangeでthis.form.submit()するのではなくjavascriptの関数を作ってその中で&lt;code&gt;form.setAttribute('data-remote', true);&lt;/code&gt;とやってcheckboxに無理やり&lt;code&gt;data-remote=&quot;true&quot;&lt;/code&gt;の属性を付加してみましたが効果ありませんでした^^; Railsがどういう仕組みでAjaxを実現しているのかよくわかってませんが、Railsで予定していない使い方であることは確かなようです。 &lt;br /&gt;
　で、form.submit()ではダメだとわかったので次のようにcheckboxのonchange=のイベントを削除して、jQueryでイベントを登録してそのイベント内でAjax通信するようにしました。Ajax送信後のCallback処理もそこに記述したのでjs.erbは使いません。&lt;code&gt;render :text =&amp;gt; @status&lt;/code&gt;とすれば.doneイベント（コールバック関数）のdata引数に@statusの内容が入って来るので。&lt;code&gt;$('#status').html(data);&lt;/code&gt;として画面に表示します。これで一応UnobtrusiveなJavascriptというかHTMLとスクリプトの分離が出来たのは目出度いことです。&lt;br /&gt;
　それと、先ほどエラー回避のためにフォーム内のPATHを変更しましたが、_form.html.erbはupdateのときだけでなくcreateのときも使用しているので元に戻しておきます。そうすればチェックボックスでの更新処理はあくまで追加の機能として作成できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/views/memos/_form.html.erb
&amp;lt;%= javascript_tag do %&amp;gt;
jQuery(function ($){
    $(&quot;#memo_chk&quot;).on('change', function(){
        body = $(&quot;#memo_body&quot;).val();
        authenticity_token = $(&quot;#authenticity_token&quot;).val();
        $.ajax({
            url: '&amp;lt;%= memo_path(id: @memo.id, format: :js) %&amp;gt;',
            type: 'PATCH',
            dataType: 'html',
            data: {
                id: '&amp;lt;%= @memo.id %&amp;gt;',
                authenticity_token: authenticity_token,
                memo: {
                    body: body,
                    chk: (this.checked) ? 't' : 'f'
                    }
            }
        }).done(function(data, status, xhr) {
            $('#status').html(data);
        }).fail(function(xhr, status, error) {
            alert('Error Occured(' + error + ')');
        });
     });
});
&amp;lt;% end %&amp;gt;

&amp;lt;%= form_for(@memo, remote: true, html:{name: &quot;frm_chkbox&quot;}) do |f| %&amp;gt;
  &amp;lt;%= hidden_field_tag(:authenticity_token, form_authenticity_token) %&amp;gt;
  &amp;lt;div class=&quot;field&quot;&amp;gt;
    &amp;lt;%= f.label :body %&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;%= f.text_field :body %&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;field&quot;&amp;gt;
    &amp;lt;%= f.label :chk %&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;%= f.check_box(:chk) %&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;actions&quot;&amp;gt;
    &amp;lt;%= f.submit %&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div id=&quot;status&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/controllers/memos_controller.rb
  render :text =&amp;gt; @status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　これで一応checkboxのクリック時は動くのですが、render部分を変更したために更新ボタンをクリックした場合に何も表示されません。はじめはcheckboxイベント用の別メソッドをコントローラに追加したのですが、更新処理自体は同じものなので既存のupdateメソッドをそのまま使って表示の際に分岐するようにします。&lt;br /&gt;
　それからテンプレートとjavascriptは分けておこうと思ってjavascript部分をapp/asset/javascript/ディレクトリに別ファイル（chkbox.js）として移動したのですが、ajax呼び出し時のurl:パラメータが上手く展開されませんでした。拡張子に「erb」を追加すればRailsがちゃんと展開してくれるとどこかに書かれていたので.jsからerb.jsに拡張子を変えてみましたが上手くいきませんでした。&lt;br /&gt;
　それとRails4から新規プロジェクトを作成すると勝手にコントローラ毎のjs.coffeeファイルが作られるので、どうせならそちらに移動しようと思いcoffeescriptに書き換えて&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;最終的には以下のようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;#app/assets/javascripts/memos.js.coffee
jQuery ($) -&amp;gt;
    $(&quot;#memo_chk&quot;).on &quot;change&quot;, -&amp;gt;
        id = $(&quot;#memo_id&quot;).val()
        body = $(&quot;#memo_body&quot;).val()
        chk = $(this).is(&quot;:checked&quot;) ? &quot;t&quot; : &quot;f&quot;
        authenticity_token = $(&quot;#authenticity_token&quot;).val()
        $.ajax(
            url: &quot;/memos/&quot; + id + &quot;.js&quot;
            type: &quot;PATCH&quot;
            dataType: &quot;text&quot;
            data:
                id: id
                authenticity_token: authenticity_token
                memo:
                    body: body
                    chk: (if chk then &quot;t&quot; else &quot;f&quot;)
        ).done((data, status, xhr) -&amp;gt;
            $(&quot;#status&quot;).html data
            return
        ).fail (xhr, status, error) -&amp;gt;
            alert &quot;Error Occured(&quot; + error + &quot;)&quot;
            return

        return

    return
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/views/memos/_form.html.erb
&amp;lt;%= form_for(@memo, remote: true, html:{name: &quot;frm_memo&quot;}) do |f| %&amp;gt;↓
  &amp;lt;%= hidden_field_tag(:memo_id, @memo.id) %&amp;gt;↓
  &amp;lt;%= hidden_field_tag(:authenticity_token, form_authenticity_token) %&amp;gt;
  &amp;lt;div class=&quot;field&quot;&amp;gt;↓
    &amp;lt;%= f.label :body %&amp;gt;&amp;lt;br&amp;gt;↓
    &amp;lt;%= f.text_field :body %↓
  &amp;lt;/div&amp;gt;↓
  &amp;lt;div class=&quot;field&quot;&amp;gt;↓
    &amp;lt;%= f.label :chk %&amp;gt;&amp;lt;br&amp;gt;↓
    &amp;lt;%= f.check_box(:chk) %&amp;gt;↓
  &amp;lt;/div&amp;gt;↓
  &amp;lt;div class=&quot;actions&quot;&amp;gt;↓
    &amp;lt;%= f.submit %&amp;gt;↓
  &amp;lt;/div&amp;gt;↓
  &amp;lt;div id=&quot;status&quot;&amp;gt;&amp;lt;/div&amp;gt;↓
&amp;lt;% end %&amp;gt;↓
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/controllers/memos_controller.rb
  def update
    if @memo.update(memo_params)
      @status = &quot;O.K.&quot;
    else
      @status = &quot;N.G.&quot;
    end
    if request.method == &quot;PATCH&quot;
      render :text =&amp;gt; @status
    else
      render template: &quot;memos/update.js.erb&quot;
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;urlパラメータはRailsの_PATH表記から文字列に変更&lt;/li&gt;
  &lt;li&gt;memo.idをview内のhiddenフィールドに保存して、jQueryでその値を取得するように変更&lt;/li&gt;
  &lt;li&gt;Railsのフォームから呼ばれた場合とjQueryから呼ばれた場合でrenderするものを変更する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　これで一応checkboxでの更新＆表示処理が完成しましたが、Railsで生成したフォームからupdateメソッドを呼び出す場合とjQueryからupdateメソッドを呼び出す場合で、画面出力処理が２種類（js.erbと.doneイベント）に分かれています。このサンプルの場合@status変数に格納した文字列を画面に表示するだけの処理ですが、それでも同じ処理をするコードが２ヶ所に存在しているのはよくないでしょう。Javascript側からAjax通信を開始（request.send、$.ajax）するときにコールバック関数としてjs.erbを指定することが出来たり（もしかして出来る？）、RailsのフォームからAjax通信するときにcoffeescript（Javascript、jQuery）のコールバック関数を指定出来たりしたら出力関数を統一出来そうですがそれはそれでややこしそうです。&lt;br /&gt;
　あと、request.methodで分岐していますが、これでいいのかどうか分かりませんしこういうコードは見かけたことが無いような気がします。&lt;br /&gt;
　ということで結局実際に使用するアプリではformから更新ボタンを無くしてjs.erbは使わないやり方に統一することにしました。こんなことになるなら最初からjs.erbは使わずにjQueryとCoffeeScriptで作ることに決めておけばよかったような気がします。&lt;br /&gt;
　それと実際に使用するサイトでやりたかったことはlazy_high_chartsを使ったグラフ表示なのでdataTypeはtextでなくjsonでやりとりしています。とてつもなく&lt;a href=&quot;https://github.com/happyclam/my-posi&quot;&gt;汚いソース&lt;/a&gt;ですが興味のある方はそちらで確認出来ます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;修正前（左）と修正後（右）&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; height:240px; float: left;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/my-posi-update-old.png&quot; alt=&quot;修正前グラフ編集画面&quot; title=&quot;修正前グラフ編集画面&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;width:20px; height:240px; float: left;&quot;&gt;&lt;/div&gt;

&lt;div style=&quot;width:320px; height:240px; float: left;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/my-posi-update-new.png&quot; alt=&quot;修正後グラフ編集画面&quot; title=&quot;修正後グラフ編集画面&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;width:320px; height:280px; margin: 0 auto;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　注意点としてこのアプリの場合、編集画面と新規登録画面が別々なのでよかったのですが、説明に使用したサンプルプロジェクトでは編集画面と新規登録画面で同じフォームを利用しているので新規登録画面でcheckboxをクリックしたときはjQueryイベントが発動しないようにするかフォームを分ける必要があると思います。&lt;br /&gt;
　そもそもcheckboxクリックで更新処理というのが特殊なUIなのかもしれませんが…。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;javascriptをcoffeescriptに書き換えるのは&lt;a href=&quot;https://js2coffee.org/&quot;&gt;こちらのサイト&lt;/a&gt;を利用しました &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>自動でコードレビュー</title>
   <link href="https://happyclam.github.io/programming/2014-11-05/sideci_review"/>
   <updated>2014-11-05T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2014-11-05/sideci_review</id>
   <content type="html">&lt;h3 id=&quot;当面は無料で提供されるらしいのでやってみて損はないかな&quot;&gt;当面は無料で提供されるらしいのでやってみて損はないかな？&lt;/h3&gt;
&lt;p&gt;　セキュリティホールをふせぐという謳い文句に惹かれて&lt;a href=&quot;https://jp.techcrunch.com/2014/04/30/%E3%82%A2%E3%82%AF%E3%83%88%E3%82%AD%E3%83%A3%E3%83%83%E3%83%88%E3%81%AE%E3%80%8Csideci%E3%80%8D%E3%81%AF%E3%80%81%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E3%82%92%E8%87%AA/&quot;&gt;「SideCI」&lt;/a&gt;使ってみました。レビューの対象に使ったプロジェクトは&lt;a href=&quot;/programming/2014-10-27/my-posi-chart/&quot;&gt;前回の記事&lt;/a&gt;でRails4にバージョンアップしたばかりの&lt;a href=&quot;https://github.com/happyclam/my-posi&quot;&gt;これ&lt;/a&gt;です。&lt;br /&gt;
　使っている人の感想とか探せばもっと見つかると思いますが自分が参考にしたのは&lt;a href=&quot;https://blog.mah-lab.com/2014/05/14/rails-side-ci/&quot;&gt;ここ&lt;/a&gt;です。中身は&lt;a href=&quot;https://brakemanscanner.org/&quot;&gt;Brakeman&lt;/a&gt;や&lt;a href=&quot;https://github.com/railsbp/rails_best_practices&quot;&gt;Rails Best Practice&lt;/a&gt;などのツールを組み合わせたものらしいけど、統合メニューで操作できるのは確かに有難いかも。色々メニュー項目がありますが自分が使ってみたものについて感想と、指摘された改善点についてざっと書きます。&lt;br /&gt;
　自分が書いたプログラムにどのような難癖を付けられるのか気になる人もいると思いますので参考にしてください&lt;img class=&quot;emoji&quot; title=&quot;grin&quot; alt=&quot;grin&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/grin.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ニュースフィード&lt;/strong&gt;&lt;br /&gt;
　Test&amp;amp;Deployの機能や通知機能を使う気がない自分にとってはあまり必要がないメニューかも&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dashboard&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; height:240px; float: left;&quot;&gt;

  &lt;p&gt;&lt;img src=&quot;/images/dashboard_org_my-posi.png&quot; alt=&quot;ダッシュボード画面初期状態&quot; title=&quot;初レビュー時のダッシュボード画面&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div style=&quot;width:320px; height:240px; float: left;&quot;&gt;

  &lt;p&gt;&lt;img src=&quot;/images/dashboard_new_my-posi.png&quot; alt=&quot;ダッシュボード画面コード改修後&quot; title=&quot;コード改修後のダッシュボード画面&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div style=&quot;width:320px; height:280px; margin: 0 auto;&quot;&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;セキュリティ&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://brakemanscanner.org/docs/warning_types/link_to_href/&quot;&gt;Cross Site Scripting: Link to HREF&lt;/a&gt;&lt;br /&gt;
twitterで呟くための文字列をAPIに渡す以下のコードでセキュリティ警告が出ました。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;&amp;lt;%= link_to(&quot;結果をTwitterでつぶやく&quot;, &quot;https://twitter.com/intent/tweet?text=#{u(@strategy.get_message_str)}&amp;amp;url=&quot; + request.url) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;　たしかRails3以降は自動で文字列をエスケープしてくれるはずと思って検索したら&lt;a href=&quot;https://www.rubylife.jp/rails/template/index7.html&quot;&gt;ここ&lt;/a&gt;にもそう書いてあります。それなのに警告が出るのはおそらくSideCI上の&lt;a href=&quot;https://github.com/railsbp/rails_best_practices&quot;&gt;Rails Best Practice&lt;/a&gt;のオプション設定の問題だと思います。もしそうだとしたらGemfileに使用しているRailsのバージョンが書いてあるのだからオプション設定もそれに合わせてほしいところですが、一応以下のように修正して警告を出さないようにすることは出来ました。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;&amp;lt;%= link_to(&quot;結果をTwitterでつぶやく&quot;, &quot;https://twitter.com/intent/tweet?text=#{h(@strategy.get_message_str)}&amp;amp;url=#{h(request.url)}&quot;) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;念のためhtmlタグやシングルクォートを出力して確認しましたがh()で囲まなくてもちゃんとエスケープされていました。無駄な時間を取られましたが、まぁ確認する機会を得られたと前向きに考えるべきなのでしょうかヽ(~〜~　)ノ\ ハテ?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;コード品質&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://rails-bestpractices.com/posts/148-protect-mass-assignment&quot;&gt;Protect mass assignment&lt;/a&gt;&lt;br /&gt;
このサイト（&lt;a href=&quot;https://qiita.com/aquamikan/items/57c6c95b39f961a18453&quot;&gt;Rails4はattr_accessibleが使えない&lt;/a&gt;）に書いてある通り、Rails4だとエラーになるからRailsをバージョンアップした時に削除したのに、そこが悪いと指摘されました。これはどういうことでしょう？これもセキュリティの警告と同じで&lt;a href=&quot;https://github.com/railsbp/rails_best_practices&quot;&gt;Rails Best Practice&lt;/a&gt;がRails4に対応していないものを使っているのか、オプション設定が厳しめになっているのかそんなところでしょう。よく分からないけど無視することにしました。こうなってくるとコードレビューしたことが混乱を引き起こすという本末転倒になってる気もしますが^^;本気でこのツールを使う気があるなら運営元に質問すればおそらく解決するでしょう。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://rails-bestpractices.com/posts/7-move-model-logic-into-the-model&quot;&gt;Move Model Logic into the Model&lt;/a&gt;&lt;br /&gt;
自分が納得したとこだけ修正しました。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://rails-bestpractices.com/posts/72-remove-empty-helpers&quot;&gt;Remove empty helpers&lt;/a&gt;&lt;br /&gt;
中身が空のヘルパーファイルがありますよ。自動生成したくなかったら&lt;code&gt;config.generators.helper = false&lt;/code&gt;しておけということですね。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://rails-bestpractices.com/posts/27-replace-instance-variable-with-local-variable&quot;&gt;Replace instance variable with local variable&lt;/a&gt;&lt;br /&gt;
納得。Rails2の頃からのソースで、よく理解していないまま書いていたコードがそのままでした。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://rails-bestpractices.com/posts/86-restrict-auto-generated-routes&quot;&gt;restrict auto-generated&lt;/a&gt; routes strategies (except: [:new])&lt;br /&gt;
以下のように定義していたルートに対して、&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;resources :strategies do
  collection do
    get :children
  end
  member do
    get :paint
    post :copy
  end
  resources :positions, :only =&amp;gt; [&quot;destroy&quot;, &quot;update&quot;, &quot;create&quot;, &quot;edit&quot;]
end
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;　「newが使われていませんよ」と指摘してくれたわけです。これはいいかも。以下のように修正しました。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;resources :strategies, :except =&amp;gt; [&quot;new&quot;] do
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://rails-bestpractices.com/posts/62-simplify-render-in-controllers&quot;&gt;Simplify render in controllers&lt;/a&gt;&lt;br /&gt;
このプロジェクトはModel用のテストスクリプト（Model用のspecファイル）しか書いていなくて、Railsのバージョンアップをした時に以下のようなRailsが出力する雛形のコードに対するテストが不十分でしたが、バグ出しツールとして役に立ちました。saveに失敗したら’new’テンプレートをrenderするとコードでは書いていますが、newテンプレートは存在していませんでした。但しファイルが存在しないことを指摘してくれたわけではありません。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;  respond_to do |format|
    if @user.save
      format.html { redirect_to @user, notice: 'User was successfully created.' }
      format.json { render action: 'show', status: :created, location: @user }
    else
      format.html { render action: 'new' }
      format.json { render json: @user.errors, status: :unprocessable_entity }
    end
  end
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://rails-bestpractices.com/posts/61-simplify-render-in-views&quot;&gt;Simplify render in views&lt;/a&gt;&lt;br /&gt;
部分テンプレートを使うとき&lt;code&gt;:partial&lt;/code&gt;というオプションを使わなければならない機会っていうのは無いってことなのか？と、新たな疑問が湧きましたが、リンク先に書いてある通りに修正しました。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://rails-bestpractices.com/posts/60-remove-trailing-whitespace&quot;&gt;remove trailing whitespace&lt;/a&gt;&lt;br /&gt;
行末のスペースを削除しろってことだけど、これは細かい！まぁチームで開発するときには一応統一しておいたほうがいいでしょうね。&lt;br /&gt;
あと、一つのファイルで最初に見つかった行だけを指摘するみたいなので、他の場所にも存在しないかよく確認してからcommitしましょう。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;remove unused methods&lt;br /&gt;
また使うかもしれないから残しておこうなんて思ったコードが結構残っていました。自分一人のプロジェクトなので他人を混乱させる心配はないのですが、せっかくgitでバージョン管理しているのだからバッサリ削除すべきですね。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;テスト &amp;amp; デプロイ設定&lt;/strong&gt;&lt;br /&gt;
　自分が使用しているtwitterAPI用の環境変数とかSSH Keyを登録するのが不安なので使用するのは止めておきました。まぁherokuではなんの警戒もせずtwitterの認証コードを環境変数にセットして使っているのに、なんで使わないのかと問われれば返答に困りますが、仕事で使う機会があれば使ってみたいと思います。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>gruffからlazy_high_chartへ</title>
   <link href="https://happyclam.github.io/programming/2014-10-27/my-posi-chart"/>
   <updated>2014-10-27T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2014-10-27/my-posi-chart</id>
   <content type="html">&lt;h3 id=&quot;rails3からrails4への移行&quot;&gt;Rails3からRails4への移行&lt;/h3&gt;
&lt;p&gt;　一応&lt;a href=&quot;https://my-posi.herokuapp.com/&quot;&gt;herokuで公開&lt;/a&gt;してますがほとんど誰も使っていないようだし&lt;img class=&quot;emoji&quot; title=&quot;grin&quot; alt=&quot;grin&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/grin.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;自分が使うときはローカル環境で動かすだけなのでRails4に移行する必要も無いのですが、&lt;a href=&quot;/project/2014-05-30/tweetwatch/&quot;&gt;TweetWatch&lt;/a&gt;を作ったときにLazyHighChartが気に入ったのでグラフ描画機能を変更する目的でついでにRailsもバージョンアップしました。Rails3からRails4への以降に関しては特に大きな変更は必要なかったのでgruffからlazy_high_chartへの移行に関して書きます。&lt;/p&gt;

&lt;h3 id=&quot;使い方&quot;&gt;使い方&lt;/h3&gt;
&lt;p&gt;　その前に&lt;a href=&quot;https://www.ruby-toolbox.com/categories/graphing&quot;&gt;ここのサイト&lt;/a&gt;でいろんなグラフ描画ツールが紹介されています。以前googlechartsは試したことがあるのですが、何か気に入らないことがあってgruffに戻しました。でも、その理由が何であったのか忘れてしまいました&lt;img class=&quot;emoji&quot; title=&quot;grin&quot; alt=&quot;grin&quot; src=&quot;https://github.global.ssl.fastly.net/images/icons/emoji/grin.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Gemfileに追記
　&lt;code&gt;gem 'lazy_high_charts'&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Controllerでインスタンス変数にデータをセット&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;      @graphs = LazyHighCharts::HighChart.new(&quot;graph&quot;) do |f|
        f.chart(:type =&amp;gt; &quot;line&quot;)
        f.title(:text =&amp;gt; strategy.name)
        f.tooltip(:pointFormat =&amp;gt; '{series.name}: {point.y}&amp;lt;br /&amp;gt;',
                  :shared =&amp;gt; true,
                  :useHTML =&amp;gt; true,
                  :style =&amp;gt; {margin: 0}
                  )
        f.xAxis(:title =&amp;gt; {:text =&amp;gt; &quot;先物価格&quot;}, :categories =&amp;gt; labels)
        f.yAxis(:title =&amp;gt; {:text =&amp;gt; &quot;収益&quot;})
        f.series(:name =&amp;gt; &quot;満期時計&quot;, :data =&amp;gt; total_data)
        f.series(:name =&amp;gt; &quot;理論値計&quot;, :data =&amp;gt; bm_data)
        distinct.each do |d|
          f.series(:name =&amp;gt; d.keys[0], :data =&amp;gt; d.values[0])
        end
      end
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Viewに出力&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;chart&quot; style=&quot;width:640px; height:480px; margin:0 auto;&quot;&amp;gt;
&amp;lt;%= high_chart(&quot;graph&quot;, @graphs) %&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　gruffを使っていた時のコードをほぼそのまま流用できましたが一点だけ引っかかったのが一つのキャンバスに複数の折れ線グラフを描画する方法。&lt;br /&gt;
　&lt;a href=&quot;https://www.highcharts.com/docs/getting-started/your-first-chart&quot;&gt;本家サイトのサンプル&lt;/a&gt;を見てHashの配列を渡すのかと思いきや上のコードのようにseriesメソッドを複数回呼ぶようにしないとグラフを描画してくれませんでした。本家のサンプルはもちろんそのまま動きましたので、これはlazy_high_chart gemの仕様ということでしょう。普通の人は引っかからないのかぁ？たぶん普通はgemのヘルプの方を見るんですね。&lt;/p&gt;

&lt;h3 id=&quot;グラフ描画ツールを変えたことによる影響&quot;&gt;グラフ描画ツールを変えたことによる影響&lt;/h3&gt;
&lt;dl&gt;
  &lt;dt&gt;画像（ドット絵）からベクターデータへ&lt;/dt&gt;
  &lt;dd&gt;gruffを使っていた以前のバージョンはpng画像を動的に生成していたのですが、lazy_high_chartではcanvasオブジェクトへの描画になるので、高速に描画出来るようになりました。以前は画像生成という重たい処理だったのでherokuの無料枠で運用していると処理が重すぎて画像生成に失敗してグラフ画像が表示されないことがありましたが、そういうことがなくなりそうです。それとクライアント側でJavaScriptで描画されたベクターデータなので、ブラウザを拡大・縮小するとそれに伴って画質を落とすこと無くグラフを拡大・縮小させることも出来るようになりました。まぁこのサイトの場合、画像を拡大・縮小しても縮尺を変えない限りあまり意味は無い（縮尺を変える機能はすでにある）ので、とりあえず今まで通りVGAサイズ（640×480）にしていますが、&lt;s&gt;サイズ変更するとしてもCSSで変更出来るから楽です。&lt;/s&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;ただ、古いブラウザ（HTML5に対応していない）だとグラフが描画出来ないことがあるかもしれません。&lt;/dd&gt;
  &lt;dt&gt;損益分岐線を描画する必要が無くなった&lt;/dt&gt;
  &lt;dd&gt;gruffの現状はよく知らないのですがgruffを使って開発した当初はメンテが行き届いていないようで縦軸のメモリを調整するのが簡単には出来なかったので、損益分岐線（0の値）のグラフをわざわざ自前で描画していたのですが、その必要がなくなりグラフがすっきりしました。&lt;/dd&gt;
&lt;/dl&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;gruff&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;lazy_high_chart&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/my_posi_ex1.png&quot; alt=&quot;gruffの画像1&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/my_posi_chart1.png&quot; alt=&quot;lazy_high_chartの画像1&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/my_posi_ex2.png&quot; alt=&quot;gruffの画像2&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/my_posi_chart2.png&quot; alt=&quot;lazy_high_chartの画像2&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　それとグラフ上にマウスを持ってくるとグラフの数値をポップアップで表示してくれるのもいいですね。&lt;/p&gt;

&lt;div style=&quot;width:320px; height:240px; margin:0 auto;&quot;&gt;

  &lt;p&gt;&lt;img src=&quot;/images/my_posi_chart3.png&quot; alt=&quot;マウスオーバーによるポップアップの画像&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　また、ググればいろいろ出て来ますが、gruffをruby1.9.3で使用するためとかLineメソッドを使うためにパッチを当てたりしなければいけませんでしたが、そういう無駄な作業からも開放されました。まあRubyだからモンキーパッチで簡単に出来る作業ではありましたが。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;cssでwidthが変化するのでてっきり反映出来ているものと思っていましたが、&lt;a href=&quot;https://api.highcharts.com/highstock#chart.height&quot;&gt;highchartsのドキュメント&lt;/a&gt;に書いてある通りデフォルトの高さに関しては400pxのようです。ソースコードは修正済みです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>三目並べ（tic tac toe）で遊んでみた（続き）</title>
   <link href="https://happyclam.github.io/software/2014-10-04/arrange_line"/>
   <updated>2014-10-04T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2014-10-04/arrange_line</id>
   <content type="html">&lt;h3 id=&quot;先読み手数を制限しても必勝の結論は出ないはず&quot;&gt;先読み手数を制限しても必勝の結論は出ないはず&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2014-09-23/tictactoe_arrange&quot;&gt;前回の記事&lt;/a&gt;で自分が作ったプログラムは千日手対応をしていないから先手必勝の結論が出ても信用できないって書きましたが、よく考えてみたら千日手対応していなくても先手必勝の評価が出てくるってことは、ArrangeLineってゲームが先手必勝であるか検証に使った自分のプログラムがバグっているかのどちらかであると気づきました。評価関数が返す値は一つの局面に関して勝ちか負けか引き分けかの三種類にしか分けていないので、千日手の局面は引き分けの一局面として評価しているはずで、引き分けに成り得るなら後手は引き分けになる手を選択し先手勝ちの評価にはならない。スタンダードの三目並べを調べた場合と違って、11手読みという手数を限定して先読みをしているわけだからそんなこともあるかと流してしまったけど、読み切っていないから勝ちか負けか決められない（引き分けになる）という評価が返ってくることはあっても、引き分けがあり得るのに必勝・必敗の評価を返してくるというのはバグっている可能性が高いのではないか。でも一応スタンダードな三目並べでは問題なさそうだし、バグの見当が付かなかったのでまずは先に千日手対応をしてみることにしました。&lt;br /&gt;
　その前にArrangeLineをダウンロードして自分のプログラムと対戦させて確認したのですが、ArrangeLineのLevel2で自分のプログラムが先手なのに千日手になり決着が付かないケースがありました。実際に千日手になることを確認していたためArrangeLineは双方最善手を打てば千日手になるゲームだと思ってしまったのですが、繰返しますが千日手になるのであればやっぱり先手必勝の結論が出るのはおかしい。&lt;/p&gt;

&lt;h3 id=&quot;千日手対応&quot;&gt;千日手対応&lt;/h3&gt;
&lt;p&gt;　先読みの最中に過去に現れた局面が一定周期で続いて現れるかどうかを判定するってプログラムが重くなりそうだし、難しそうな気がして対応する気がしなかったのですが、よく考えてみると先読みの最中である必要は無く、実際に打った一手だけを局面毎に保存しておいて、先読みを開始する一手目の時だけ過去に同一局面があったかどうかを調べるだけで済みそうです。これなら重くなることもありません。&lt;br /&gt;
　※&lt;a href=&quot;/software/2014-09-23/tictactoe_arrange&quot;&gt;前回の記事&lt;/a&gt;で必ず千日手になることを証明するのは難しいと書いたのは、完全読み切りが出来ない場合（将棋もその一つ）はたしかにその通りですが、先手必勝あるいは後手必勝という結論を返してくるということは完全読み切りが出来ているということなので、その時点で千日手は結論に関係無かったと言うことです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #過去に同一局面があったかどうか判定
  def check_dup(sengo)
    temp = self.dup
    temp.unshift(sengo)
    return @duplication.has_key?(temp.hash)
  end
  #局面データのハッシュ値だけ保存
  def set_dup(sengo)
    temp = self.dup
    temp.unshift(sengo)
    @duplication[(temp).hash] = temp
  end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　局面データと手番データからハッシュ値を生成して保存するメソッドと、そのハッシュ値を検索するメソッドを追加。&lt;br /&gt;
　過去に評価した局面を再現したりその時の評価値を再利用したりするわけでは無く、過去に同一局面があったかどうかを判断するだけなので保存するのはハッシュ値だけでもいいのですが、一応局面と手番のデータを保存しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if board.check_dup(turn)
          temp_v = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　そして局面を評価した後に過去に現れた局面なら強制的に評価値を引き分け（DRAW=0）にする処理を追加しただけです。引き分けでなく同じ局面を再現させたら負けとすることも考えられますが、それだとArrangeLineと対戦させたときにこのソフト側だけが不利なルールで戦うことになるのでよくありません。その他にも評価値を少し下げるとかいろいろ奥が深そうですが、将棋のように何らかの千日手に関するルールが無い限りは引き分けの評価（0）でよさそうです。&lt;br /&gt;
　ということで、同一局面を出現させたら引き分けという評価を返す状態で、前回の記事同様に一手打った状態から検証プログラムを動かしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|X|9|
2手目: 1 評価値: 9
2手目: 2 評価値: 9
2手目: 3 評価値: 9
2手目: 4 評価値: 9
2手目: 5 評価値: 9
2手目: 6 評価値: 9
2手目: 7 評価値: 9
2手目: 9 評価値: 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　前回と同じく初手に辺の部分に打てばやっぱり先手必勝になるという結果になります。そして実際のandroidアプリと対戦させて見たところ、以前は先手なのに必ず千日手になっていたケースでも千日手を避けるようになり、先手の場合に限っては必ず勝利することが出来るようです。なのでArrangeLineは先手必勝のゲームと言っていいでしょう。もし何か間違いに気づいた人がいれば連絡して下さい。景品を差し上げます…ウソです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;自作プログラムの対戦状況&lt;/em&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;先手・後手\ArrangeLineのLevel&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;Level 1&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;Level 2&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;Level 3&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;自作プログラムが先手&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;自作プログラムが後手&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;初手が辺&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;負け&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;^&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;初手が辺以外&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;千日手&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　ArrangeLineは乱数を使っているようなのでこの表の結果はいつも同じではないはずですが、自作プログラムが先手の場合はいつも勝ちます。それと千日手対応したのに千日手になることがあるのは自作のプログラムが後手で、負けるはずなのにArrangeLine側が初手で辺の部分（2,4,6,8）を取らなかったために起きる現象です。自作ソフト側としては後手なので勝てないから千日手に持っていくしか無い状況ってことです。これは&lt;a href=&quot;/software/2014-09-23/tictactoe_arrange&quot;&gt;前回の記事&lt;/a&gt;で初手から検証した時に以下の結果になったことと符合します。初手で辺の部分を取らない場合は、勝てるとは限らないということです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|8|9|
1手目: 1 評価値: 0
1手目: 2 評価値: 9
1手目: 3 評価値: 0
1手目: 4 評価値: 9
1手目: 5 評価値: 0
1手目: 6 評価値: 9
1手目: 7 評価値: 0
1手目: 8 評価値: 9
1手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;先手後手が決まった段階で勝負は既に決まっている&quot;&gt;先手・後手が決まった段階で勝負は既に決まっている&lt;/h3&gt;
&lt;p&gt;　androidアプリのArrangeLine側は乱数を使っているようなので必ず再現するわけではないのですが、私のプログラムが先手の場合は必ず勝つのですが、後手の場合は最短の5手で負ける場合があります。&lt;/p&gt;

&lt;div style=&quot;width:240px; height:287px; margin:0 auto;&quot;&gt;

  &lt;p&gt;&lt;img src=&quot;/images/arrangeline.png&quot; alt=&quot;負け画像&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　先手がリーチ（あと一手でラインが揃う）状態になっても揃うことを防ごうとしないことがあるのです。最初はバグか？と思いましたが、これもよく考えてみると私のソフト側は後手で尚且つ初手で辺の部分を取られていると、どう足掻いても負けることがわかっているので勝つことを諦めているわけです。&lt;a href=&quot;/project/2014-08-05/tictactoe&quot;&gt;以前の記事&lt;/a&gt;に通常ルールの三目並べソフトが初手に有利なはずの真ん中を取らないことを書きましたが、初手にどこを取っても引き分けになることを読み切っている（初手にどこを選んでも引き分けの評価値が返ってくる）ので、1（左上隅）の場所から順に読み始めて最後に評価した9の場所（右下隅）を取る現象と同じです。ArrangeLineでも初手に辺の部分を取られているとその後どういう変化をしようが負けることがわかっている（先手勝ちの評価値MAX_VALUE=9が返ってくる）ため、相手がリーチをかけていようがいまいが関係なくたまたま最後に評価した場所を選んでしまいます。一回リーチを防いでも負けることが分かってるのですから…。&lt;br /&gt;
　この現象を防ぐにはどうすればいいのか、前にも書きましたが将棋にしろオセロにしろ局面の形勢判断用の評価関数と読み切り用（将棋で言えば詰将棋用）の評価関数を分けて使用するか、リーチを優先的に防ぐ処理（将棋で言えば王手放置を避ける）を用意すればいいのでしょうが、相手が間違えない限り手数を伸ばすだけで、勝敗は既に決まっています。将棋と違って完全読切りが完了しているゲームでこの処理を入れるのは虚しいだけでしょう。ただ、このArrangeLineに関して言えばandroid端末用のゲームなので完全読切りするにはマシンパワーの制限で難しいからそれなりに形勢判断用の評価関数を工夫する意味はあると思います。自分はあまり興味湧きませんが…&lt;br /&gt;
　今回の記事の中で「よく考えてみると」と何度も書いてますが、この手のソフトは自分の意図通りに動いているのかうまくいっていないのか結構悩まされます。最後の例でもそうですが、考えて納得して改良したあとにいきなり5手で負けたりするとさっぱり意味が分からなくなりました。でも、特別なアルゴリズムを使わなくても完全読み切りが出来るわけですから、将棋なんかに較べたら作り易いゲームではあると思います。今回、千日手回避のために他にもいろいろ試行錯誤したのでそれらの手法を使って将棋作りに活かしてみようと思っています。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>三目並べ（tic tac toe）で遊んでみた</title>
   <link href="https://happyclam.github.io/software/2014-09-23/tictactoe_arrange"/>
   <updated>2014-09-23T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2014-09-23/tictactoe_arrange</id>
   <content type="html">&lt;h3 id=&quot;いろんなテストケース&quot;&gt;いろんなテストケース&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/project/2014-08-05/tictactoe&quot;&gt;以前作った三目並べのプログラム&lt;/a&gt;でいろいろ遊んでみました。&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;githubに公開&lt;/a&gt;しているので暇な人はソースをいじって試すこともできます。但し、短いソースとはいえ自分でコードを読んで編集する必要があります。もともとは対戦用プログラムとして作ったものですが、テスト用に9ヶ所の升目を順に取っていってその時の評価値を表示するように作った関数を使って、いろんなケースでプログラムの検証をしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NOUGHT = -1
CROSS = 1
DRAW = 0
MAX_VALUE = 9
MIN_VALUE = -9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　上記のように定数を定義しています。CROSSは×（バツ）NOUGHTは◯（マル）でCROSSが先手です。評価関数は先手勝ち（MAX_VALUE）、後手勝ち（MIN_VALUE）、引き分け（DRAW）の3値の内どれかを返すようになっています。&lt;br /&gt;
　テスト用の関数は先手から交互に1～9の升目を取っていって、その時に先読み関数から返ってくる評価値を順に画面に表示していくようになってます。三目並べはパスが無いので奇数手目は先手×で偶数手目は後手◯になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo@bar:~$ ruby play.rb 

 |1|2|3|
 |4|5|6|
 |7|8|9|
1手目: 1 評価値: 0
1手目: 2 評価値: 0
1手目: 3 評価値: 0
1手目: 4 評価値: 0
1手目: 5 評価値: 0
1手目: 6 評価値: 0
1手目: 7 評価値: 0
1手目: 8 評価値: 0
1手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　1手目に1の場所（先手は×）を取れば0の評価値が返ってきたという意味ですが、どこの場所を取っても評価値0が返ってきてます。どこの場所を取っても引き分けになると言うことを示していますが、これではプログラムがうまく動いているかどうかわかりません。初手に先手が5を取った局面から先読み開始してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|X|6|
 |7|8|9|
2手目: 1 評価値: 0
2手目: 2 評価値: 9
2手目: 3 評価値: 0
2手目: 4 評価値: 9
2手目: 6 評価値: 9
2手目: 7 評価値: 0
2手目: 8 評価値: 9
2手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　2手目に後手◯が奇数の場所1、3、7、9（隅）を取った場合の評価値はすべて0になっています。お互いに最善手を選択すれば引き分けになるということです。2手目に後手○が2、4、6、8の辺部分を取るとすべて最大値（9）の評価が返ってきています、その後双方が最善を尽くせば先手が勝つということです。最小値（-9）が返ってくれば後手が勝つという意味です。&lt;br /&gt;
　そういえば三目並べでは初手で真ん中を取って、相手が2手目で隅（角）以外の部分を取ると先手が勝つことを思い出しました。念のため確認してみましょう。&lt;br /&gt;
　初手で真ん中を取り、2手目で辺を取った場合と隅を取った場合を順に確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1手目5、2手目に辺（8）の場合：
       
 |1|2|3|
 |4|X|6|
 |7|O|9|
3手目: 1 評価値: 9
3手目: 2 評価値: 0
3手目: 3 評価値: 9
3手目: 4 評価値: 9
3手目: 6 評価値: 9
3手目: 7 評価値: 9
3手目: 9 評価値: 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　3手目に先手が2の場所を取った場合以外は先手が勝つ（評価値が9）となります。MIN-MAX法（αβ法）は互いに最善手を打つことが前提となっていますので、2手目で後手◯が辺を取った後、先手が最善手を打てば勝つことが出来るのですが、間違えて2の場所を取ると勝てないことを示しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　ちなみに2手目に辺を取るとなぜ後手◯が負けるのかというと、先手が3手目に隅を取れば下図のように２ヶ所同時に、あと一つで揃う局面に出来るからです。後手は２ヶ所同時に防ぐことが出来ません。

|X| |O|
| |X| |
|X|O| |
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1手目5、2手目に隅（3）の場合：

 |1|2|O|
 |4|X|6|
 |7|8|9|
3手目: 1 評価値: 0
3手目: 2 評価値: 0
3手目: 4 評価値: 0
3手目: 6 評価値: 0
3手目: 7 評価値: 0
3手目: 8 評価値: 0
3手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　すべてのケースで引き分けになることを示していて、最初のテスト結果と符合しますので、一応プログラムは正常に動作しているようです。&lt;br /&gt;
　あと、&lt;a href=&quot;/software/2014-09-16/ab_method&quot;&gt;前回の記事&lt;/a&gt;にも書きましたが、αβ法がうまく機能していれば最終的な評価値の結果がMIN-MAX法と一致するはずです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      if (temp_v &amp;gt;= value &amp;amp;&amp;amp; turn == CROSS) 
        value = temp_v 
        locate = i
#        break if threshold &amp;lt; temp_v
      elsif (temp_v &amp;lt;= value &amp;amp;&amp;amp; turn == NOUGHT)
        value = temp_v 
        locate = i
#        break if threshold &amp;gt; temp_v
      end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　上記のようにプログラム中の枝刈り部分のコード２行をコメントにして、上記のテスト結果と同じ結果が得られましたので枝刈りも正常に機能しているようです。ちなみに評価関数が呼び出される回数を数えて見たところ、すべての手を読み切るまでにMIN-MAX法では255,168回、αβ法では100,645回でした。&lt;/p&gt;

&lt;h3 id=&quot;ちょっと変わった三目並べ&quot;&gt;ちょっと変わった三目並べ&lt;/h3&gt;
&lt;p&gt;　Twitter使っていると&lt;a href=&quot;https://androider.jp/official/app/4f0d853da0473562/&quot;&gt;「ちょっと変わった三目並べ Arrange Line」&lt;/a&gt;というアプリを見かけたのでルールを確認してみると、なんと今弄っている三目並べをほとんどそのまま流用出来そうじゃないですか？なんか神様から使命を授かったような気になったので作って見ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Board.initializeに追加
    @c_q = Array.new
    @c_bk = Array.new
    @n_q = Array.new
    @n_bk = Array.new
#Board.initに追加    
    @c_q.clear
    @c_bk.clear
    @n_q.clear
    @n_bk.clear
#Boardクラスに追加
  def set(i, v)
    if self[i]
      raise &quot;Error!&quot;
    else
      self[i] = v
    end
    if v == CROSS
      @c_q &amp;lt;&amp;lt; i
      if @c_q.size &amp;gt; 3
        idx = @c_q.shift
        @c_bk.push([idx, self[idx]])
        self[idx] = nil
      end
    elsif v == NOUGHT
      @n_q &amp;lt;&amp;lt; i
      if @n_q.size &amp;gt; 3
        idx = @n_q.shift
        @n_bk.push([idx, self[idx]])
        self[idx] = nil
      end
    end
  end

  def unset(v)
    if v == CROSS
      if @c_bk.size &amp;gt; 0
        h = Hash[*(@c_bk.pop)]
        temp = h.each{|k, v| self[k] = v}
        @c_q.unshift(temp.keys[0])
      end
      idx = @c_q.pop
    elsif v == NOUGHT
      if @n_bk.size &amp;gt; 0
        h = Hash[*(@n_bk.pop)]
        temp = h.each{|k, v| self[k] = v}
        @n_q.unshift(temp.keys[0])
      end
      idx = @n_q.pop
    end
    self[idx] = nil
  end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　評価関数や画面出力部分はまったく変更する必要は無く、Boardクラスに指し手を記憶するための配列を追加し、setメソッドとunsetメソッドを追加して、今まで&lt;code&gt;board[n] = CROSS&lt;/code&gt;等、配列に値を代入していたところを&lt;code&gt;board.set(n, CROSS)&lt;/code&gt;のように変更し、&lt;code&gt;board[n] = nil&lt;/code&gt;としていたところを&lt;code&gt;board.unset(CROSS)&lt;/code&gt;に変えるだけです。&lt;br /&gt;
　で、初手から読み切りさせて見たところ、敢えなくスタックオーバーフロー。でもこれは将棋でいうところの千日手になるケースがあるのだろうと思ったので、先読み手数を制限して9手読み、10手読みと試していきました。すると、10手読みのところまでは三目並べと同じように全部0の評価だったのですが、11手読みまで増やすと以下のような結果が出ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|8|9|
1手目: 1 評価値: 0
1手目: 2 評価値: 9
1手目: 3 評価値: 0
1手目: 4 評価値: 9
1手目: 5 評価値: 0
1手目: 6 評価値: 9
1手目: 7 評価値: 0
1手目: 8 評価値: 9
1手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　初手に偶数の場所つまり辺の部分に先手が着手すれば先手が勝つことが出来ると言ってます。普通の三目並べと違って真ん中を取るのはよくないようです。&lt;br /&gt;
　あと、10手読みまでは三目並べと同じように評価0ばかりだったと言っても、三目並べの場合は完全に読み切った上で引き分けになることを示しているのですが、この新しいルールの三目並べは先読み手数を制限しているので、制限手数内で先読みした限りでは勝負がつかないということを示しているだけです。&lt;br /&gt;
　次に辺の部分に初手を打てば勝てるということなのでその局面から先読み開始してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|X|9|
2手目: 1 評価値: 9
2手目: 2 評価値: 9
2手目: 3 評価値: 9
2手目: 4 評価値: 9
2手目: 5 評価値: 9
2手目: 6 評価値: 9
2手目: 7 評価値: 9
2手目: 9 評価値: 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　全部先手勝ちとなりました。これで「ちょっと変わった三目並べ（Arrage Line）」というゲームは先手必勝のゲームであることが確認出来たと早合点して&lt;a href=&quot;https://twitter.com/SappierBoy/status/512377344582225920&quot;&gt;Twitterにも呟いてしまった&lt;/a&gt;んですが、千日手（同じ手の繰り返しで局面が進まない状態）に対応していないのでなんとも言えません。どうもこのゲームは互いに最善手を打ちつづけると千日手になるような気もしますが、それを証明するのは結構難しそうです。&lt;br /&gt;
　本来の三目並べやオセロゲームは指し手が盤上を埋めていき、選択肢がだんだん減っていくので読みやすくなっていきますが、このArrangeLineや将棋は盤上のスペースを埋めていくわけでは無いので、先読みプログラムを作る方は大変です。結局、前回の記事同様先読みプログラム作りの大変さを再認識する結果になってしまいました。おもしろい題材なのでArrangeLineについてはまた何か発見があれば記事を書いてみようと思います。&lt;/p&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>MIN-MAX法とαβ法</title>
   <link href="https://happyclam.github.io/software/2014-09-16/ab_method"/>
   <updated>2014-09-16T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2014-09-16/ab_method</id>
   <content type="html">&lt;h3 id=&quot;min-max法&quot;&gt;MIN-MAX法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/tree_min-max.png&quot; alt=&quot;min-max法&quot; style=&quot;width: 800px; vertical-align:middle;&quot; /&gt;
　MIN-MAX法とは、オセロゲームなどのある局面で先手、後手、どちらが有利か判断する評価関数を用意し、先手、後手が互いに最善手を打つと仮定して先読みを行うアルゴリズムです。先手をプラス方向の値（MAX値）後手をマイナス方向の値（MIN値）で評価することが多いようです。&lt;br /&gt;
　上の図はオセロゲームで3手読みをする場合の例ですが、◯図形はオセロの一局面（ノード）で□内の数字が3手目を打ったときの評価値になります。3手目と書いてあるノードは先手が打つことが出来るすべての手を順番に評価していくためのループで、2手目となっているノードが後手が打つことが出来るすべての手を順番に評価していくためのループです。実際のプログラムではこのツリー構造を左から右の順に局面を評価していくことになります。&lt;br /&gt;
　全体図は1手目を先手が打った場合に後手が2手目を打つことが可能な手が2通りあり、その後先手が打てる手がそれぞれ3通り、2通りあることを表しています。まず左側のtreeを見ていくと、3手目に先手が打った局面で評価関数を呼ぶと15、22、-5という3つの評価値が得られたということです。で、先手は自分にとって最善手である一番評価値が高い22の局面を選び、取りあえずその評価値と指し手を記憶しておきます。次のノードで同様に3手目まで手を進めて14、25、9、33という4つの評価値を得て先手が選んだ最大値33と先ほどの評価値22を比較して、後手は自分に取って最善手である小さい方の22を選ぶという具合です。先手（3手目）では最大値、後手（2手目）では最小値を選択するというやり方で進めて、評価値が18という左側のtreeの2手目の評価が完了します。次に、右側のtreeでも先手（3手目）は最大値、後手（2手目）は最小値を選び-11という評価値が残ります。最終的には18と-11を比較して先手は大きい方の18を選び、1手目の先手の評価が完了します。&lt;br /&gt;
　最終的に指し手を決めるまでに、3手目の局面の数の分だけ評価関数を呼び出したことになるので、1手目の評価が完了するまでに14局面評価したことになります。&lt;/p&gt;

&lt;h3 id=&quot;αβ法&quot;&gt;αβ法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/tree_ab-method.png&quot; alt=&quot;αβ法&quot; style=&quot;width: 800px; vertical-align:middle;&quot; /&gt;
　αβ法はMIN-MAX法と同じ結果を得られるにもかかわらず、局面を枝刈りすることで時間短縮が出来るというすばらしいアルゴリズムです。なぜ局面の枝刈り（評価の回数を減らす）をしながら同じ結果が得られるのか見ていきましょう。&lt;br /&gt;
　まずMIN-MAX法と同様に左の3つの評価値から22という評価値が得られます。この22を基準値として読み進めると14、25という評価値を得ますがこの25という評価値を得た時点で、このノードは選ばれないことがわかります。なぜなら一つ上の後手のノードでは常に最小値を選ぶからです。この先読み進めて25より大きい評価値を得られたとしても一つ上の後手のノードで、22より大きな値が選ばれることはないので、ここで読みを打ち切っても問題ない（MIN-MAX法と同様の結果が得られる）わけです。これをβカットと言うそうです。その後同じく22を基準値として、次のノードに移り18という評価値を得ますが、18は22より小さいのでそのまま読み進みます。そして18と-12の大きい方である18が選ばれ、後手のノードで18と基準値の22を比較し小さい方の18が選ばれます。これで2手目の候補手が一つ決まりました。&lt;br /&gt;
　次に右サイドのtreeに移りますが、1手目の候補手から読み直すので、基準値は無く新たに末端ノードの3手目を順に評価することになります。得られた8と16を比較して先手（3手目）では最大値である16が選ばれます。16という後手の候補手が一つ得られたわけですが、後手の候補手はより小さい評価値が選ばれるわけですから、今のノードから分岐する3手目をいくら読み進んでいっても16以上になることはないということがわかります。そして一つ上の1手目の先手のノードでは先程の評価値18と比較して大きな方が選ばれることが分かっているわけです。つまり18より小さい評価値が後手（2手目）の候補手に一つでも現れた時点で、この後手のノードから分岐する先の手は読む必要がないことがわかります。これをαカットと言うそうです。ということで先程の18と今読みを打ち切った16を比較して、MIN-MAX法と同じ18が選ばれます。&lt;br /&gt;
　この例ではMIN-MAX法と比較して評価関数を呼び出す回数を5回減らすことが出来ただけで、それほど有り難みが伝わらないかもしれませんが、例えば一局面で選択できる手が3手だったとして3手先まで読むとMIN-MAX法だと&lt;script type=&quot;math/tex&quot;&gt;3^3&lt;/script&gt;回（27回）評価関数を呼ぶことになりますが、評価する局面の順番が理想的な場合αβ法だと&lt;script type=&quot;math/tex&quot;&gt;3^\frac{3}{2}&lt;/script&gt;回（約6回）で済むそうです。&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;前回記事&lt;/a&gt;で紹介した&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;三目並べのプログラム&lt;/a&gt;の例の場合、まさにこれぐらいの高い効果が得られたと思います。&lt;/p&gt;

&lt;h3 id=&quot;オセロと将棋の違い&quot;&gt;オセロと将棋の違い&lt;/h3&gt;
&lt;p&gt;　今までにいろんなプログラミング言語でオセロを作った経験があるのですが、オセロを作った同じやり方で三目並べを作るとうまく出来ませんでした。三目並べを作った顛末は&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;ここ&lt;/a&gt;に書いていますが、どのような問題があったかというと、オセロの局面の評価は末端ノード（葉）で行うため、三目並べで同様の作り方をすると途中でラインが揃って勝負がついているにも関わらず先読みを続けてしまうという不都合が起こり、間違った結果が返ってきます。各ノードで局面の評価を先にしてから先読みを続けるかどうか判断するという作り方にしなければなりません。その違いに気づくまで私は結構悩みました。&lt;br /&gt;
　将棋も三目並べと同じでゲームがいきなり終了する（詰み）ことがあるので、有限手数先を読みそこで評価する作り方をしているとあり得ない局面を読んでいて間違った評価をすることになります。では、オセロはゲームがいきなり終了することは無いのかというとそうでもなく、頻度は低いと思いますがオセロにもパーフェクトで勝負がつくケースというのがあるので、その対策は必要です。でも自分がオセロプログラムを作った経験から言うと、特にパーフェクト負けへの対応をしていなくても自然と回避されるケースが多いと思います。巷に出回っているオセロのソフトも偶々うまくいっているというケースが多いのではないでしょうか。&lt;br /&gt;
　もう20年以上前のことですが、自分が作ったオセロプログラムがどれほどの強さなのか他のプログラムと手動で対戦させていた頃、とても強くて自分が作ったソフトは歯が立たないフリーソフトがあったんですが、そのソフトに自分の作ったソフトが何度か序盤（オセロ盤に打つ場所がいっぱい残っている状態）でパーフェクト勝ちをしたことを思い出しました。その強いオセロソフトはパーフェクト負けへの対応をしていなかったのでしょう。三目並べを作って見るまではオセロも三目並べも将棋も同じようなゲームだと思っていたのに、そんな違いがあることに今更ながら驚きました。ちょっと大袈裟かもしれませんが自分にとっては新発見でした。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>将棋はやっぱり深く読まなくてはダメ</title>
   <link href="https://happyclam.github.io/software/2014-09-09/pre_shogi"/>
   <updated>2014-09-09T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/software/2014-09-09/pre_shogi</id>
   <content type="html">&lt;h3 id=&quot;三目並べtictactoe作成後&quot;&gt;三目並べ（tictactoe）作成後&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;前回の記事&lt;/a&gt;で自分で作った将棋ソフトが弱い原因を確認するために三目並べ（tictactoe）プログラムを作ったことを書きましたが、一応その後の結果を書いておこうと思います&lt;br /&gt;
　&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;三目並べプログラム&lt;/a&gt;で先読み関数には問題ないと確認出来たので、将棋プログラムの先読み部分もそれと同じように修正してみました。将棋の前にオセロプログラムも作って確認したのですがここではその話は置いておきます。それと、三目並べと同じように修正したと言っても将棋には盤上の駒を動かす場合と持ち駒を打つ場合があったり、相手の駒を取ったりするので、三目並べと同じにはならないのですが、どういうパラメータを与えるかとかどこで評価関数を呼んでどこで再帰関数から抜けるのかとかそういう部分を同じにしたということです。将棋プログラムでは、評価関数を呼び出す場所を先読み再帰関数の先頭にしてみたりforループの中にしたり、評価部分の等号・不等号の違いや評価する局面の枝刈りをする場所変えたりいろいろ試行錯誤しているうちに正確に先読み・枝刈りが出来ているかどうかわからなくなってきたので、三目並べで確認したかったんです。&lt;br /&gt;
　この類のゲームを作ったことがある人なら分かると思いますが、自分の書いたプログラムが膨大な局面の評価値のtree構造をどのように遷移して結論を出したのか確認するのは結構面倒です。評価の遷移を出力して確認するためのテストコードを書くのが王道かもしれませんが、それより簡単そうで面白そうなので三目並べを作って確認し、それと同じ作りにしてしまおうということです。&lt;br /&gt;
　で、結論はどうだったかというと、先読み部分を三目並べと同じように変更しても将棋ソフトは全然強くなりませんでした。結局、先読み部分には大きな問題はなく、ソフトが弱い原因は先読み手順以外の部分（評価関数や読む深さ）にあるということがはっきりしたわけです。今の評価関数は駒の重み（飛車=85点、竜=100点、玉=9999点、金=50点、歩=10点…等）の合計値を使って局面を評価しているだけなので、いい結果が望めないのは当然といえばそうなのですが、&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;前回の記事&lt;/a&gt;で書いたように、駒の重みだけの評価関数でオセロを作った場合には非常に強いソフトになるのに将棋だとなんでこんなに弱いのか納得出来なかったので念のため確かめたって感じです。&lt;br /&gt;
　仕方がないので疑問手を指した局面で、何でこんな手を指すのか地道にコードを追っていって調べたところ何となくオセロとの違いが分かってきましたので、実際にソフトが指した手を示しながら説明したいと思います。&lt;br /&gt;
　というか本当に強い将棋ソフトを作りたいのなら、今のご時世ならソースコードが公開されているらしいBonanzaのソースコードを調べてそれに倣うのが一番手っ取り早いと思いますが、それでは面白く無いのであくまで自己流でやってます。&lt;/p&gt;

&lt;h3 id=&quot;テスト局面の例&quot;&gt;テスト局面の例&lt;/h3&gt;
&lt;p&gt;　本将棋もどうぶつ将棋もプレイ出来るような作りにしているのですが、本将棋（９×９）だと確認が大変なのでミニ将棋（５×５）で確認しました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ケース１&lt;br /&gt;
&lt;img src=&quot;/images/scr1-1.png&quot; alt=&quot;局面1-1&quot; /&gt;&lt;br /&gt;
　先手＝ソフト、後手＝人間で上の図の初期配置から先読みをせずに、というか１手先を読む設定でソフトに初手を指させると「１二飛」と指します&lt;br /&gt;
&lt;img src=&quot;/images/scr1-2.png&quot; alt=&quot;局面1-2&quot; /&gt;&lt;br /&gt;
　ソフトは自分が一手指した局面で評価（自分の駒の重みの合計点ー相手の駒の重みの合計点）を計算しますので、この局面では歩を一枚得をした状態なので自分が有利と判断します。次の一手で後手に飛車を取り返されて大損するにもかかわらずです。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ケース２&lt;br /&gt;
局面２ー１:&lt;br /&gt;
&lt;img src=&quot;/images/scr2-1.png&quot; alt=&quot;局面2-1&quot; /&gt;&lt;br /&gt;
　先手＝ソフト、後手＝人間で、既に後手有利な局面ですが、ここで５一の飛車を使うために４三角と指します。&lt;br /&gt;
局面２ー２:&lt;br /&gt;
&lt;img src=&quot;/images/scr2-2.png&quot; alt=&quot;局面2-2&quot; /&gt;&lt;br /&gt;
　もし、ソフトが角を取れば４五飛車の一手詰という仕掛けです。3手先を読む設定にしたソフトで、この局面で指させると下図のように堂々と４三金と角を取ってしまいます。&lt;br /&gt;
局面２ー３:
&lt;img src=&quot;/images/scr2-3.png&quot; alt=&quot;局面2-3&quot; /&gt;&lt;br /&gt;
　ソフトからすると４三金（1手目）、４五飛（2手目）と進んでも４五同玉（3手目）とすれば自分が有利と計算することになるからです。&lt;br /&gt;
局面２ー４:
&lt;img src=&quot;/images/scr2-4.png&quot; alt=&quot;局面2-4&quot; /&gt;&lt;br /&gt;
　４五同玉と取った時点の駒の重みの合計点は飛車の分が加算されて先手のソフト側の点数がかなり高くなります。この飛車を取ることが出来るというところまで読んで「局面２ー２」の時点で４三金と角を取る手を選んでしまうわけです。その次の一手で後手に４五同馬と玉を取られるにもかかわらずです。ソフトを4手先を読む設定にすれば、その先で自玉が取られて合計点が大幅に減ることが分かるので「局面２ー２」で４三金とは指しません。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;オセロとの違い&quot;&gt;オセロとの違い&lt;/h3&gt;
&lt;p&gt;　ケース１では飛車が取られる、ケース２では玉が取られるという、序盤であれ終盤であれ一手違うだけで評価値が激変するのが将棋のオセロに無い特徴だと思います。将棋以外のゲームでも勝ちか負けかという局面では評価値が激変するのは当然ですが、将棋は一手毎に駒を打つ場所が少なくなるオセロや囲碁と違って、徐々にゲームの終わりが近づいているわけではありません。いつ終了するか（いつ玉が詰まされるか）わかっていないので常に局面を厳しく評価する必要があるのです。オセロの評価関数は序盤でいい加減な評価関数を使用していたとしても、ゲームの終盤で残り15手とか20手になったときに最後まで読み切ることが可能なので強いソフトが比較的簡単に作れるのでしょう。三目並べも同様です。将棋の場合、読み切りと言えば詰みを探すということになりますが、初手から詰みを探しても時間の無駄ですし、オセロのように一手毎に終わりが近づいているわけではないので、残り何手になったら詰みを探すという作りにも出来ません。常に局面を正確に評価し、詰みがある局面ではそれを逃さないような作りにする必要があります。&lt;br /&gt;
　それともう一つオセロや三目並べは、手が進むに連れて徐々に手の選択肢が少なくなるので深く読むことが容易になっていきますが、将棋にはそういうことがありません。むしろ持ち駒が増えると読む手が増えていきます。&lt;br /&gt;
　ということで、まずはもっと深く読むことが必要だと思うので、クラスの構成やデータ構造も見直して作り直そうかと思っています。駒の働きや玉の固さなども考慮した凝った評価関数を作るとなると、結局速度が必要になるのでデータ構造も出来るだけ単純にすべきなのですが、そもそもRubyで実効速度は期待出来ないと思っていたし、ミニ将棋ならオセロより駒の数も少ないし特に凝ったことしなくても自然と強いソフトになるだろうなんて甘い見通しだったのがいけなかったようです。&lt;/p&gt;

&lt;h3 id=&quot;おまけ&quot;&gt;おまけ&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://sdin.jp/browser/board/55shogi/&quot;&gt;SDIN将棋のサイト&lt;/a&gt;で自分が作ったソフトとCPU対戦したところ、4手読みの設定でいい加減な評価関数でもレベル２には常に勝てるようです。レベル３には勝てませんので、これに勝つことを当面の目標にしてみます。&lt;br /&gt;
　それと、つい最近まで開発の動機なども含めてgithubのwikiに書いて「Shoes de shogi」という名前でgithubで公開していたのですが、とりあえずもう少し強くできるまで一時的に削除することにしました。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>三目並べ（tictactoe）</title>
   <link href="https://happyclam.github.io/project/2014-08-05/tictactoe"/>
   <updated>2014-08-05T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2014-08-05/tictactoe</id>
   <content type="html">&lt;p&gt;Project: 「&lt;strong&gt;三目並べ&lt;/strong&gt;」: &lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;開発の動機&quot;&gt;開発の動機&lt;/h3&gt;
&lt;p&gt;　Ruby用のGUI開発ツールShoesを使って一通り機能を備えた将棋ソフトを作ってみたのですが、思っていた以上に弱い。大昔にオセロのソフトを作ったことがあるのですが、min-max法とαβ法を使えば普通の人では勝てないぐらいのものが簡単に作れました。オセロでは四隅を取ると有利になるので、隅のコマは点数を高くして、その隣の位置は点数を低くするという、コマを置く盤面の位置に重み付けすることで局面を評価するよくある評価関数を使えば十分でした。&lt;br /&gt;
　だから将棋の場合もそれぞれの駒に重み付けをして評価関数を作れば、オセロに比べると読む局面の数が多くなるとはいえ、それなりに強いものが出来ると思っていたのにあまりにも弱かったのです。そこで評価関数は置いといて局面の先読み部分がうまくいってるのか確認するために、まずはより単純なゲームである三目並べで確認しようと思ったのが作成のきっかけです。三目並べ（tictactoe）なら初手からゲーム終了まで読みきれるので先読み関数に問題がないかどうか判断しやすいと思ったからです。&lt;/p&gt;

&lt;h3 id=&quot;min-max法&quot;&gt;min-max法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  #先手×は最大値、後手○は最小値を選択するように再帰しながら局面を先読み
  def lookahead(board, turn, cnt)
    if turn == CROSS
      value = MIN_VALUE
    else
      value = MAX_VALUE
    end
    locate = nil
    board.each_with_index {|b, i|
      next if b
      board[i] = turn
      temp_v = evaluation(board)
      teban = (turn == CROSS) ? NOUGHT : CROSS
      if (temp_v != MAX_VALUE &amp;amp;&amp;amp; temp_v != MIN_VALUE &amp;amp;&amp;amp; cnt &amp;lt; SIZE - 1)
        #指定した深さまで再帰呼出し
        temp_v, temp_locate = lookahead(board, teban, cnt + 1)
      end
      board[i] = nil
      #先手×の番と後手○の番で、同じ深さでの最小、最大の評価値をvalueに保存
      if (temp_v &amp;gt; value &amp;amp;&amp;amp; turn == CROSS) || (temp_v &amp;lt; value &amp;amp;&amp;amp; turn == NOUGHT)
        value = temp_v 
        locate = i
      end
    }
    #同じ深さでの最小、最大の評価値を返す
    return value, locate
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;αβ法&quot;&gt;αβ法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;min-max法に、親局面の評価値を子局面に伝えるための引数を追加&lt;/li&gt;
  &lt;li&gt;引数で渡された親局面の評価値と現局面を比較して、現局面が選択されることがないことがわかったら、先読みを中断してreturnする（αカットとβカット）&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  #現局面の評価値を子局面に渡しながら再帰関数で局面を先読み
  def lookahead(board, turn, cnt, threshold)
    if turn == CROSS
      value = MIN_VALUE
    else
      value = MAX_VALUE
    end
    locate = nil
    board.each_with_index {|b, i|
      next if b
      board[i] = turn
      temp_v = evaluation(board)
      teban = (turn == CROSS) ? NOUGHT : CROSS
      if (temp_v != MAX_VALUE &amp;amp;&amp;amp; temp_v != MIN_VALUE &amp;amp;&amp;amp; cnt &amp;lt; SIZE - 1)
        temp_v, temp_locate = lookahead(board, teban, cnt + 1, temp_v)
      end
      board[i] = nil
      #先手×の番
      if (temp_v &amp;gt; value &amp;amp;&amp;amp; turn == CROSS) 
        value = temp_v 
        locate = i
        #閾値を上回ったら先読み中止
        return value, locate if threshold &amp;lt; temp_v
      #後手○の番
      elsif (temp_v &amp;lt; value &amp;amp;&amp;amp; turn == NOUGHT)
        value = temp_v 
        locate = i
        #閾値を下回ったら先読み中止
        return value, locate if threshold &amp;gt; temp_v
      end
    }
    #同じ深さでの最小、最大の評価値を返す
    return value, locate
  end

end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;※min-max法に僅かなコードを追加しただけで素晴らしい効果が得られました。&lt;a href=&quot;https://www.vaio.sony.co.jp/Products/P1/spec_vom1.html&quot;&gt;vaio type p (VGN-P90S)&lt;/a&gt;という非力なPCで比較したところ、単なるmin-max法で完全読み切りに３０秒ほどかかったのに、αβ法なら５秒で完了しました。評価関数が、勝ち、負け、引き分けの３値しかない単純なものだったせいもありますがすごいです。&lt;/p&gt;

&lt;h3 id=&quot;検証と意外だったこと&quot;&gt;検証と意外だったこと&lt;/h3&gt;
&lt;p&gt;　先読みがうまく機能しているかは、初手をどこに打ってゲーム開始しても引き分けという結果が返ってくることや、先手・後手でそれぞれ何度か三目並べで遊んでみて確認した程度ですが、それで十分でしょう。&lt;br /&gt;
　でも作ってみて意外だったのは初手から完全読み切りするわけだから、ソフトに初手を指させたら当然真ん中に×をつける（打つ？指す？）と思っていたのに真ん中には打ってこなかったことです。人間ならすぐに一番勝つ可能性が高い真ん中を取るはずですが、ソフトは双方が最善手を指せば引き分けになることを読み切っているので、結局どこに打っても同じと判断するわけです。評価関数が勝ち、負け、引き分けの三値しか返さない関数なので、初手に真ん中に打てばラインを揃える可能性が一番高いとはいえ、引き分けには違いないので区別しないのだと一応納得しました。&lt;br /&gt;
　念の為、真ん中は２点、隅は１点、その他は０点という場所による重み付けをしてその点数による評価関数を作って、それを使えば真ん中に打つことは確認しましたが、そんな評価関数では当然弱いソフトになりました。それ以外にも何とか初手に真ん中を選択しながら、強い評価関数はどうすればいいか考えてみましたが、シンプルでいい方法は思いつきませんでした。&lt;br /&gt;
　結局オセロでも将棋でもそうですが、局面の形成判断をする評価関数と読み切り用の評価関数は分けて作るのがいいのかもしれません。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>BlueToothマウス</title>
   <link href="https://happyclam.github.io/hardware/2014-07-12/bt_mouse"/>
   <updated>2014-07-12T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/hardware/2014-07-12/bt_mouse</id>
   <content type="html">&lt;h3 id=&quot;携帯する気は無いがマウスのケーブルは細い方がいい&quot;&gt;携帯する気は無いが、マウスのケーブルは細い方がいい&lt;/h3&gt;
&lt;p&gt;　まだ一年程しか使っていなかったマウスが壊れました。ケーブルが平べったいタイプでUSB端子をマウスの中に収納できるタイプのもの。ケーブルが巻き取れるタイプのものは携帯用の小さなマウスばかりですが、USB端子も本体に収納出来るようになっているため比較的マウス本体も大きめの作りでまぁまぁ気に入っていたのに短い命でした。このタイプのマウスでもう一つお気に入りのマウスを持っているのですが、それはビックカメラ製の今はもう製造していないであろう珍しいもの（だと思います）。10年以上前に新横浜のビックカメラで買ったものですが、ELECOM等のOEM製品だと思いますが、どういう経緯で自社ブランドで販売したのか知りませんが、確かにビックカメラ製と銘打っていたと記憶しています。あの時まとめて買いだめしておけばよかったと思います。&lt;br /&gt;
&lt;img src=&quot;/images/biccamera_mouse.png&quot; alt=&quot;ビックカメラ製マウス&quot; style=&quot;float: left;&quot; /&gt;
　大きいマウスの方が使いやすいのですが、ケーブルが太いと、わずかではあるけどケーブルに操作を持っていかれる時があるので好きではありません。だからと言ってケーブルの無い無線方式だと何となく信頼できないというか、安心できないというかイザというとき困るんじゃないかとか、CPU切替器も使っているのでちゃんと動くかどうかわからないという不安が先走って、未だに無線方式のものは使わずにいます。マウスに関してはキーボードほど使い勝手にこだわりは無いのでそろそろ無線を試してもいいかもと思いながらも、あくまで細いケーブルの大きなマウスを求めていろんな店舗を見て回ることにしました。&lt;/p&gt;

&lt;h3 id=&quot;予定していた行動とまったく違うことすることってありますよね&quot;&gt;予定していた行動とまったく違うことすることってありますよね&lt;/h3&gt;
&lt;p&gt;　細く平たいケーブルのマウスか、それが無ければ無線マウスを買うつもりで家を出たのに、家に持ち帰ったのはBuffalo製の&lt;a href=&quot;https://buffalo.jp/product/input/mouse/bsmbb17/&quot;&gt;BlueToothマウス&lt;/a&gt;でした。細いケーブルのマウスは携帯用の小さいものしか無く、目当てのものが売っていなかったのが最大の原因ですが、無線のマウスは専用のレシーバが必要なのが何となく嫌で躊躇していたところにそれ以外の選択肢が目についてしまったのです。プログラマっていうのはXXX社製専用というのが何となく美しくないと感じてしまうものです、そう、縛られるのが嫌いなのでしょう。BlueToothマウスもBlueTooth機能を備えていないPCで使う場合はドングルというレシーバが必要なわけですが、マウスと同じメーカーでなくても使えます。マウスと同じメーカーの対になったレシーバしか使えないという不自由さが気に入らないのでしょう（家でしか使わないならそれで十分なのに…）。そういえば昔買ってほとんど使わずじまいのドングルが家に何個かあるなぁと思い出してしまったことも購入に踏み切った原因だと思います。&lt;/p&gt;

&lt;h3 id=&quot;ubuntu1204では使えない&quot;&gt;Ubuntu12.04では使えない？&lt;/h3&gt;
&lt;p&gt;　家では主にUbuntu12.04を使っているのですが、そのままでは認識すらしてくれませんでした。Windows7のノートPCでは２つのドングル（&lt;a href=&quot;https://www.planex.co.jp/product/bluetooth/bt-microedr2x/&quot;&gt;BT-MicroEDR2X&lt;/a&gt;、&lt;a href=&quot;https://www.planex.co.jp/product/bluetooth/bt-01ude.shtml&quot;&gt;BT-01UDE&lt;/a&gt;）で確認したので故障ではありません。dbusを最新のものに入れ替えたらデバイス検索でBSMBB17を検出してはくれたものの動作しませんでした。そこで以前から更新しようと思っていながら放ったらかしにしていたUbuntu14.04へのアップグレード（do-release-upgradeコマンド一発）をやってみたらすぐに認識することが出来、使えました。メデタシメデタシ。って結局マウスが壊れたおかげで以前から懸案だったUbuntuアップグレード作業をすることが出来たことが収穫って感じです。マウスが壊れたところから神様のお導きだったのかもしれません。&lt;br /&gt;
&lt;a href=&quot;https://buffalo.jp/product/input/mouse/bsmbb17/&quot;&gt;&lt;img src=&quot;/images/bsmbb17_mouse.png&quot; alt=&quot;BSMBB17&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
　で、肝心のBlueToothマウスの使い勝手ですが、頻繁に動作が引っかかる感じでとても使い続ける気にはなりませんでした。自分的にはBlueToothマウスはまだまだ実用には堪えられないって感じです。あくまでlinuxで使う場合の話ですが…。結局マウスはしばらく買わずに、とっておきのビックカメラ製のものを使うことにします。チャンチャン。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>production環境でjQueryが発動しない</title>
   <link href="https://happyclam.github.io/programming/2014-07-07/rails_env"/>
   <updated>2014-07-07T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2014-07-07/rails_env</id>
   <content type="html">&lt;h3 id=&quot;自宅サーバーにdeployment&quot;&gt;自宅サーバーにdeployment&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/project/2014-05-30/tweetwatch&quot;&gt;TweetWatch&lt;/a&gt;がとりあえず完成したので、自鯖（Apatch）で動かしてみたらjQueryの一部（画面描画時&lt;code&gt;$(document).ready()&lt;/code&gt;の処理だけ）が上手く動かなかったので動くようになったまでの顛末を書きます（Rails 4.0.2, ruby 2.0.0p353）。&lt;br /&gt;
コードは以下の通りです&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#app/assets/javascripts/users.js
$(document).ready(function(){
    $.ajax({
        url: '/tweets/check', 
        data: {},
        dataType: &quot;script&quot;
    }).done(function(data, status, xhr) {
    }).fail(function(xhr, status, error) {
        alert('Error Occured(' + error + ')');
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;処理の内容はあまり関係ないと思いますが、jQueryからcontrollerのメソッドを呼び出し、サーバースクリプトが動いているかどうかをチェックして画面にstatusを表示する処理をしています。このusers.jsがdevelopment環境では動くのにproduction環境では動かないという現象に悩まされました。動くようになるまでに辿った作業を順に箇条書きにしてみると以下のようになります。&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;p&gt;1. Apache+Passenger環境でうまく動かないので、以下の設定でwebrickでproduction環境を試す。特にwebrick用の設定とも言える&lt;code&gt;serve_static_assets = true&lt;/code&gt;がdevelopment環境との大きな違い&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
    #config/environments/production.rb
    config.assets.compile = false
    config.assets.js_compressor = :uglifier
    config.serve_static_assets = true
    config.assets.digest = true
    config.assets.debug = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rake assets:precompile RAILS_ENV=production&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;rails s -e production&lt;/code&gt;&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;p&gt;2. 変化が無かったのでjquery-turbolinks gemを追加してみる&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
    #Gemfile
    gem 'jquery-turbolinks'  &amp;lt;- 追加
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    #app/assets/javascripts/application.js
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require users.js
//= require turbolinks
//= require jquery.turbolinks     &amp;lt;- 追加
//= require highcharts/highcharts
//= require highcharts/highcharts-more
//= require highcharts/highstock
//= require_tree .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rake assets:precompile RAILS_ENV=production&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;rails s -e production&lt;/code&gt;
&lt;/p&gt;
※&amp;lt;a href=https://github.com/kossnocorp/jquery.turbolinks/blob/master/README.md&amp;gt;jquery-turbolinksのドキュメント&amp;lt;/a&amp;gt;
&lt;/dd&gt;
&lt;br /&gt;
&lt;dt&gt;&lt;p&gt;3. jquery-turbolinks gemを追加してもダメだったので、今度は逆にturbolinksを無効にしてみる&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
    #Gemfile
#    gem 'turbolinks'         &amp;lt;- コメント化
#    gem 'jquery-turbolinks'  &amp;lt;- コメント化
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
    #app/assets/javascripts/application.js
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require users.js
//= require turbolinks            &amp;lt;- この行を削除
//= require jquery.turbolinks     &amp;lt;- この行を削除
//= require highcharts/highcharts
//= require highcharts/highcharts-more
//= require highcharts/highstock
//= require_tree .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    #app/views/layouts/application.html.erb
    #変更前
  &amp;lt;%= stylesheet_link_tag    &quot;application&quot;, media: &quot;all&quot;, &quot;data-turbolinks-track&quot; =&amp;gt; true %&amp;gt;
  &amp;lt;%= javascript_include_tag &quot;application&quot;, &quot;data-turbolinks-track&quot; =&amp;gt; true %&amp;gt;
    #変更後
  &amp;lt;%= stylesheet_link_tag    &quot;application&quot;, media: &quot;all&quot; %&amp;gt;
  &amp;lt;%= javascript_include_tag &quot;application&quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rake assets:precompile RAILS_ENV=production&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;rails s -e production&lt;/code&gt;&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;p&gt;4. turbolinksは関係なかったので、関係ないと思ったけど今度はcoffee scriptに変えてみる&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;span&gt;jqueryとturbolinks両イベント対応の書き方&lt;/span&gt;
&lt;pre&gt;&lt;code&gt;
#app/assets/javascripts/user.js.coffee
$(document).on 'ready page:load', -&amp;gt;
  url = '/tweets/check'
  dfd = $.ajax
    url: url
    format: 'script'
    data: {}
    method: 'get'
  promise = dfd.promise()
  promise.done((data, status, xhr) -&amp;gt;
  )
  promise.fail((xhr, status, error) -&amp;gt;
    alert(error)
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;span&gt;jqueryイベントとturbolinksイベントを分けた書き方&lt;/span&gt;
&lt;pre&gt;&lt;code&gt;
#app/assets/javascripts/user.js.coffee
ready = -&amp;gt;
  url = '/tweets/check'
  dfd = $.ajax
    url: url
    format: 'script'
    data: {}
    method: 'get'
  promise = dfd.promise()
  promise.done((data, status, xhr) -&amp;gt;
  )
  promise.fail((xhr, status, error) -&amp;gt;
    alert(error)
  )

$(document).ready(ready)
$(document).on('page:load', ready)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rake assets:precompile RAILS_ENV=production&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;rails s -e production&lt;/code&gt;&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;p&gt;5. どっちのcoffee scriptでもダメなので、こんどは正常に動作しているdevelopment環境の設定をproduction環境と同じにして確認。&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
    #config/environments/development.rb
    config.assets.compile = false
    config.assets.js_compressor = :uglifier
    config.serve_static_assets = true
    config.assets.digest = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;デフォルトでは書かれていない上記設定をdevelopment環境の設定ファイルに追加して&lt;code&gt;rails s -e development&lt;/code&gt;すると、めでたく？production環境と同じくページload時のjqueryだけが発動しない現象が再現しました。結局config.assets.compileがtrueかfalseかで動作が変わるようです。念のためdevelopment環境でconfig.assets.compileの値だけを書き換えて現象の発生の有無を確認しました。&lt;br /&gt;
　でも本番（production）環境でconfig.assets.compile = trueにして運用することは、重くなるので普通はしないと思いますし、結局config.assets.compile = falseのままではturbolinksの有効・無効に関係なく、このjqueryを発動させることは出来ませんでした。
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;p&gt;6. 何か方法はないかとテンプレートファイルに直接jqueryを直書きしてみたところ&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
#app/views/users/show.html.erb
&amp;lt;%= javascript_tag do %&amp;gt;
$(document).ready(function(){
    $.ajax({
        url: '/tweets/check', 
        data: {},
        dataType: &quot;script&quot;
    }).done(function(data, status, xhr) {
    }).fail(function(xhr, status, error) {
        alert('Error Occured(' + error + ')');
    });
});
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでdevelopment環境でもproduction環境でもページ読み込み時のjqueryが正常に動作しました。&lt;br /&gt;
config.assets.compile = falseでdevelopment,production両方の環境で動きます。いろいろ環境を弄りましたが元の環境からjqueryをテンプレートに直書きするように変えるだけで他は変更しなくてよかったみたいです。turbolinksが有効でも無効でも大丈夫です
&lt;/p&gt;
&lt;/dd&gt;

&lt;/dl&gt;

&lt;p&gt;&lt;em&gt;結論&lt;/em&gt;&lt;br /&gt;
「$document.readyイベントを使うjqueryが動作しない時は、テンプレートに直書きしてみる。」&lt;/p&gt;

&lt;p&gt;　※ネットの情報を漁っていると、jquery-turbolinks gemを使えば解決するというものが多いのですが、document.readyイベントに関してはそういうわけにはいかないようです。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>ツイートを監視して集計する（client側）</title>
   <link href="https://happyclam.github.io/project/2014-06-07/tweetwatch_client"/>
   <updated>2014-06-07T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2014-06-07/tweetwatch_client</id>
   <content type="html">&lt;h3 id=&quot;サーバースクリプトの状態遷移&quot;&gt;サーバースクリプトの状態遷移&lt;/h3&gt;
&lt;p&gt;　言うまでもなくclient側と言ってもWebサーバ上で動いているわけなのでユーザから見ればサーバーとして機能しているわけですが、TwitterAPIを使ってデータをDBに保存するサーバースクリプトに対してclient側ということです。&lt;br /&gt;
state_machine gemを利用してサーバースクリプトの状態を管理しています。
&lt;img src=&quot;/images/tweetwatch.png&quot; alt=&quot;状態遷移図&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;状態遷移表&lt;/em&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;status\method&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;start&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;store&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;stop&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;停止中(down)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;待機中(prepared)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;待機中(prepared)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;集計中(storing)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;停止中(down)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;集計中(storing)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;停止中(down)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;サーバー停止中のユーザー画面&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;/images/state1.png&quot; alt=&quot;サーバー停止中&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;サーバー集計中のユーザー画面&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;/images/state2.png&quot; alt=&quot;サーバー集計中&quot; /&gt;&lt;br /&gt;
　ユーザ向け画面では「停止中」と「集計中」の２つの状態しかないのですが、EventMachineを使用しているサーバースクリプトでは、接続確立が完了した状態（post_initイベントが発生後）にならないとコマンドラインで渡したパラメータが有効にならないので、サーバースクリプトを起動した直後の状態を「待機中」として管理しています。&lt;br /&gt;
&lt;!-- other list --&gt;&lt;/li&gt;
  &lt;li&gt;停止中 —– サーバースクリプト停止中&lt;/li&gt;
  &lt;li&gt;待機中 —– サーバースクリプトが起動しているが、TwitterAPIを呼び出していない状態&lt;/li&gt;
  &lt;li&gt;集計中 —– TwitterAPIを呼び出しツイートデータをDBに保存している状態&lt;br /&gt;
※「集計中」から「待機中」には遷移できません（停止して再起動）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;機能&quot;&gt;機能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;server側スクリプトの制御（起動、終了、状態確認）&lt;br /&gt;
※遅いノートPC（Atom機）で試したところserver側スクリプト起動に時間がかかり、接続がタイムアウトすることがあったので５秒のsleepを入れています。&lt;/li&gt;
  &lt;li&gt;server側のスクリプトがDBに保存したツイートデータを集計してグラフ表示する。&lt;br /&gt;
※Twitterのデータ構造はハッシュタグを本文とは別に保持しているようですが、SQLで集計する際にハッシュタグで集計するのはコストがかかるので、本文の内容でgroup byするという単純なやり方で妥協しています。詳細は別記事にするつもりです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;er図&quot;&gt;ER図&lt;/h3&gt;
&lt;object data=&quot;/pdf/struct_tweetwatch.pdf&quot; width=&quot;600&quot; height=&quot;600&quot;&gt;
&lt;p&gt;ご覧の環境では、object要素がサポートされていないようです。&lt;a href=&quot;/pdf/struct_tweetwatch.pdf&quot;&gt;PDFファイルをダウンロードしてください&lt;/a&gt;&lt;/p&gt;
&lt;/object&gt;

&lt;ul&gt;
  &lt;li&gt;Tweetテーブルへの書き込みはサーバースクリプトのみで、client側のRailsアプリからTweetテーブルへのアクセスはRead onlyです。&lt;/li&gt;
  &lt;li&gt;Servモデルはユーザがサーバースクリプトを起動する時に指定したTwitter検索タグとサーバースクリプトの状態を管理します。&lt;/li&gt;
  &lt;li&gt;ユーザは複数のTrackモデル（検索タグ）を保存できますが、サーバースクリプト起動時に指定出来るタグは一つだけです。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>ツイートを監視して集計する（server側）</title>
   <link href="https://happyclam.github.io/project/2014-06-06/tweetwatch_server"/>
   <updated>2014-06-06T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2014-06-06/tweetwatch_server</id>
   <content type="html">&lt;h3 id=&quot;eventmachineで簡単インターフェース&quot;&gt;EventMachineで簡単インターフェース&lt;/h3&gt;
&lt;p&gt;　初めて&lt;a href=&quot;https://morizyun.github.io/blog/ruby-twitter-stream-api-heroku/&quot;&gt;morizyun氏のこの記事&lt;/a&gt;を読んだときはEventMachineとかforemanとかって何をするものか知らなかったのですが、EventMachineというのは「&lt;a href=&quot;https://morizyun.github.io/blog/reactor-pattern-ruby/&quot;&gt;[Ruby] Reactorパターンについて&lt;/a&gt;」にも書いてある通り、ソケットの受信待機をして貰って簡単にReactorパターンを実現することが出来るツールってことのようです。だからわざわざ自分でプロセス間通信の手続きを書く必要がなくアプリケーションレベルのコマンドを用意してあげるだけで済むのではないか？と思いながら作ったら思惑通りにうまく動いたって感じです。実際に組み込む前には、以下のような単純なサンプルで確認しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#server側サンプル  
require 'eventmachine'

class Serv &amp;lt; EM::Connection
  attr_accessor :track
  def post_init
    puts &quot;myserv: init&quot;
  end

  def receive_data(data)
    puts data
    send_data @track
    EM.stop if data =~ /stop/i
  end

  def connection_completed
    puts &quot;myserv: completed&quot;
  end

  def unbind
    puts &quot;myserv: unbind&quot;
  end
end

EM.run do
  EM.start_server(&quot;127.0.0.1&quot;, 10000, Serv) do |conn|
    conn.track = ARGV[0]
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下のようにコマンドラインパラメータを付加して起動し、&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby myserv.rb O.K.&lt;/code&gt;&lt;br /&gt;
クライアント接続時にServクラスのプロパティに保持されていることを確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#client側サンプル
require &quot;net/telnet&quot;

begin
  localhost = Net::Telnet::new(&quot;Host&quot; =&amp;gt; &quot;localhost&quot;,
                             &quot;Port&quot; =&amp;gt; 10000,
                             &quot;Timeout&quot; =&amp;gt; 1,
                             &quot;Telnetmode&quot; =&amp;gt; false,
                             &quot;Output_log&quot; =&amp;gt; &quot;./temp0.log&quot;,
                             &quot;Prompt&quot; =&amp;gt; &quot;O.K.&quot;)
  localhost.cmd(&quot;search word&quot;) { |c| print c }
  localhost.close
  localhost = nil
  p &quot;end&quot;
rescue Net::ReadTimeout
  p &quot;readtimeout&quot;
  p $!.to_s
rescue
  p $!.to_s
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このserver側の処理を、twitterAPIを使ってDBに検索結果を保存するスクリプトに組み込んで、client側の処理をRails製のサイトに組み込めばいいわけです。&lt;br /&gt;
　あと、server側のスクリプトは、ユーザ毎に起動してユーザがWebサイトから制御しなければならないので、foremanは必要無さそうです。&lt;/p&gt;

&lt;h3 id=&quot;サーバースクリプトへのパラメータの受け渡し&quot;&gt;サーバースクリプトへのパラメータの受け渡し&lt;/h3&gt;
&lt;p&gt;　EventMachine::Connectionを継承したクラスServにユーザ情報を保存するメンバ変数（プロパティ）を用意して、Webサイト（client側）からサーバースクリプトを起動する時にコマンドライン引数でそれらの値を渡してあげます。起動の際に「10000+ユーザID」をポート番号に指定することでWebサイト利用者とサーバースクリプト利用者を一致させています。EventMachineを使ったプログラム同士が変数を共有する仕組みのようなものがあるかもしれませんが、ステートレスなHTTPで動いているWebサイトから起動するのだから、コマンドラインで渡すのがちょうど良さそうです。&lt;br /&gt;
　twitterのStreamingAPIを使用する部分は&lt;a href=&quot;/project/2014-05-30/tweetwatch&quot;&gt;以前書いた記事&lt;/a&gt;で紹介したmorizyun氏のコードをServ.trackingメソッドに閉じ込めてほぼそのまま動かしています。twitter側でエラーが発生した場合このままでいいのかよく分かりませんが、エラーになればWebサイト側からサーバースクリプトを再起動してもらえばいいという考え方で作ってます。&lt;br /&gt;
　client側からserver側スクリプトに受け渡すパラメータはTwitterAPIを利用するために必要な認証key文字列（４種類）とユーザIDとTwitterのfilterAPIに渡す検索文字列（検索タグ）です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#実際のソースの一部
require 'eventmachine'
require 'optparse'

class Serv &amp;lt; EM::Connection
  attr_accessor :uid
  attr_accessor :track
  attr_accessor :c_key
  attr_accessor :c_secret
  attr_accessor :a_key
  attr_accessor :a_secret
  def receive_data(data)
    case data
    when /stop/i
      send_data &quot;O.K.&quot;
      EM.stop
    when /check/i
      send_data @track
    省略
      :

  def tracking(track, c_key, c_secret, a_key, a_secret, uid)
    stream = Twitter::JSONStream.connect(
  省略
    :

EM.run do
  EM.start_server(&quot;127.0.0.1&quot;, 10000 + params[&quot;p&quot;].to_i, Serv) do |conn|
    conn.track = params[&quot;t&quot;]
    conn.uid = params[&quot;p&quot;].to_i
    conn.c_key = params[&quot;c&quot;]
    conn.c_secret = params[&quot;k&quot;]
    conn.a_key = params[&quot;s&quot;]
    conn.a_secret = params[&quot;a&quot;]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;参考サイト&quot;&gt;参考サイト&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://keijinsonyaban.blogspot.jp/2010/12/eventmachine.html&quot;&gt;【翻訳】EventMachine入門 &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gihyo.jp/dev/serial/01/ruby/0032&quot;&gt;Reactorで非同期処理をやってみよう（2）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>ツイートを監視して集計する</title>
   <link href="https://happyclam.github.io/project/2014-05-30/tweetwatch"/>
   <updated>2014-05-30T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2014-05-30/tweetwatch</id>
   <content type="html">&lt;p&gt;Project: 「tweetwatch」: &lt;a href=&quot;https://github.com/happyclam/tweetwatch&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;開発の動機&quot;&gt;開発の動機&lt;/h3&gt;
&lt;p&gt;　今年の都知事選の頃、多くのフォロワーを抱えている人（以下a氏と表記）が&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Twitterで&lt;strong&gt;#都知事選&lt;/strong&gt;というタグをつけて自分が投票した候補者の名前を呟けば、それを集計してくれるアプリ作れないかな～&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と物欲しそうに呟いていたのが目に止まりました。&lt;br /&gt;
Yahooのアンケートのように、誰がどれぐらい票を獲得しているかtwitterで独自に確認しようという意図のようです。
　プログラマたるもの、そこで「すぐ出来ますよ」とリプライするような軽率な行動をとってはいけません。職業プログラマなら尚更です。誰かが手を挙げるかもと思いながらしばらく様子を見ていましたが、その呟きに対して反応する人はいなかったようです。こういう場合、相手がどれほどのものを要求しているかわからないので迂闊に出来ますなんて言えませんが、StreamingAPI使えばとりあえず使える程度のものであれば、すぐ出来るんじゃないかと思い調べてみました。&lt;/p&gt;

&lt;h3 id=&quot;とりあえずローカル環境で動くもの&quot;&gt;とりあえずローカル環境で動くもの&lt;/h3&gt;
&lt;p&gt;　「StreamingAPI」で検索すると役に立ちそうなサイトはすぐに見つかりました→&lt;a href=&quot;https://morizyun.github.io/blog/ruby-twitter-stream-api-heroku/&quot;&gt;「Herokuの無料枠でTwitter Stream APIを常時監視 =&amp;gt; DBに保存するRubyコード」&lt;/a&gt;&lt;br /&gt;
このmorizyunって人のサイトは調べ物をしている際にはよくお世話になっていますが、今回見つけた記事も自分の要望その物です。私はherokuは使いませんでしたがほぼこの記事のコードそのままがローカル環境で動作しました。ツイートの集計がしたいのであればDBに溜まったデータに対してSQLを打ち込めば好きな結果が得られます。a氏に教えてあげようかとも思いましたが、おそらくプログラミングやSQLも知らないa氏が実際に自分のPCで動かすためにはそうとうな時間をかけてサポートしてあげないと無理だろうと思って止めておきました。自分が良かれと思って教えても、逆に恨まれることになり兼ねません。そうなんです、自分でニタニタ楽しむためのソフトを作れたとしても、それをひと様に使ってもらおうとするとまた一段とハードルが高くなるんですねぇ（今回は自分で楽しむものさえパクリですが）。&lt;/p&gt;

&lt;h3 id=&quot;ひと様が使えるようにするために&quot;&gt;ひと様が使えるようにするために&lt;/h3&gt;
&lt;p&gt;　最初はDBにデータを格納するだけのシェルスクリプトを起動しながら、ユーザー向けのwebインターフェースを提供してあげればいいだけだからそれほど手間はかからないと思いましたが、そうすると２プロセス動かすことになり、herokuの無料枠では済まなくなります。それに運用環境を何とか用意したとしても、自分のtwitterアカウントの認証キーをそのサービスで利用するとなると、一人しか利用できないwebサービスになってしまいます。twitter社にAPI利用料を支払えば解決ですが、そこまでする気もないので開発に取りかかるのは躊躇してました。&lt;br /&gt;
で結局、&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;運用環境に関してはとりあえず自宅サーバで動くようにしてから考える&lt;/li&gt;
  &lt;li&gt;twitterのAPIキーをユーザ自身が登録して、そのキーを利用しながらDB格納プロセスを起動するようにする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という方針で作りました。
&lt;img src=&quot;/images/tweetwatch_screen.png&quot; alt=&quot;集計画面&quot; /&gt;  &lt;br /&gt;
DBにデータを格納するシェルスクリプトは、&lt;a href=&quot;https://morizyun.github.io/blog/ruby-twitter-stream-api-heroku/&quot;&gt;morizyun氏のコード&lt;/a&gt;を叩き台にしてWebサイトから制御するためのプロセス間通信用インターフェースを追加し、そのサーバーとなるシェルスクリプトに接続するクライアントアプリとなるユーザ向けのwebサイトを作る。そのwebサイトは&lt;a href=&quot;https://railstutorial.jp/&quot;&gt;Ruby on Rails チュートリアル&lt;/a&gt;でRSpecの勉強（写経）をしながら作ったものがあったのでそれを流用しています。&lt;br /&gt;
以降、DBにデータを格納する&lt;a href=&quot;/project/2014-06-06/tweetwatch_server/&quot;&gt;&lt;em&gt;サーバースクリプト（server側）&lt;/em&gt;&lt;/a&gt;とRails製&lt;a href=&quot;/project/2014-06-07/tweetwatch_client/&quot;&gt;&lt;em&gt;Webサイト（client側）&lt;/em&gt;&lt;/a&gt;に分けて紹介します。&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>ボラティリティについて</title>
   <link href="https://happyclam.github.io/miscellaneous/2014-05-27/my-posi_vola"/>
   <updated>2014-05-27T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/miscellaneous/2014-05-27/my-posi_vola</id>
   <content type="html">&lt;h3 id=&quot;インプライドボラティリティivとヒストリカルボラティリティhv&quot;&gt;インプライド・ボラティリティ（IV）とヒストリカル・ボラティリティ（HV）&lt;/h3&gt;
&lt;p&gt;　ボラティリティには２種類ありますが、ニュースの記者や市況解説者が「ボラティリティ」という言葉を理解していないまま使っていることが多いと感じるので、以前から一言言っておきたいと思っていたことを書いておこうと思います。&lt;br /&gt;
　市況解説の中でも現物市場ではなく特に先物市場の解説をしている人が、先物価格の値動きが荒かった日などに「今日はボラの大きな一日でした」と解説しているのを聞くと「(・_・)……ン?」となることがあります、そういう日でもインプライドボラティリティ(IV)が低い日も結構あるからです。オプションの買いで勝負する時はボラが高い時が有利、逆に売りはボラが低い時が有利なのですが、IVが低い日に「今日は（オプション買いに）手出ししなくてよかった」と思っているところに、市況解説で「ボラの高い一日でした」なんて言われると「(‾△‾;)エッ・・そうだっけ？」となるわけです。実際にIVが高かったかどうかはスマイルチャートなどで確認できます。&lt;br /&gt;
　&lt;a href=&quot;https://www.option-dojo.com/kn/225_latest.html&quot;&gt;直近1年のボラティリティー&lt;/a&gt;をみればよく分かりますが、ヒストリカル・ボラティリティ（HV）とインプライド・ボラティリティ（IV）の動きは必ずしも一致していません。原資産である先物の動きがそれ程なくても、オプションの値動きが激しい日もあるということです。それにオプションは先物と違い、満期(SQ)が近づくとボラ(IV)が高くなるという性質（時間価値の減少に伴うもの）もあります。また、日経２２５先物とそれを原資産とする派生商品である日経２２５オプションの関係だけでなく、現物株とそれを原資産とする派生商品（株オプ等）の間でも同じことが言えます。&lt;br /&gt;
　まぁIVとHVの違いは理解しているけど、ボラティリティと言う言葉は単に「値動き」とか「値幅」と同義で使っているだけなので、区別する必要はないと言われればそれまでなのですが。&lt;/p&gt;

&lt;h3 id=&quot;誤解を生む説明の仕方&quot;&gt;誤解を生む説明の仕方&lt;/h3&gt;
&lt;p&gt;　ネットや本ではよく&lt;strong&gt;「ボラティリティが高いとオプションのプレミアムが高くなる、ボラティリティが低いとオプションのプレミアムが低くなる」&lt;/strong&gt;と説明されています。でもこの文を読んでいる人を騙そうとする悪意があるかどうかは別にして、非常に誤解を生みやすい説明だと思います。なぜなら、&lt;strong&gt;ボラティリティが高いと&lt;/strong&gt;という前提条件がIVのことを指しているのかHVのことを指しているのかわかりません。&lt;br /&gt;
　もしIVのことを指しているとしたら、IVが高いとプレミアムが高くなるのはその通りですが、そのIVというものはオプションの価格から算出されているものだから当たり前のことを言っているに過ぎません。IVが高いとオプションのプレミアムが高くなるわけではなく、IVが高いってことはオプションが割高に買われているってことです。&lt;br /&gt;
　また、&lt;strong&gt;ボラティリティが高いと&lt;/strong&gt;という前提条件がHVのことを指しているのだとすると、HVが高いとオプションの&lt;strong&gt;理論価格&lt;/strong&gt;が高くなることは間違いないですが、オプションの&lt;strong&gt;実際の価格&lt;/strong&gt;が理論価格通りに高くなるとは限りません。HVが高いとオプションの価格（プレミアム）が高くなるのではなく、HVが高いとオプションの&lt;strong&gt;理論価格&lt;/strong&gt;が高くなると言うべきです。&lt;br /&gt;
　&lt;strong&gt;ボラティリティが高いと&lt;/strong&gt;という表現がIVのことを指しているとしてもHVのことを指しているとしても、いずれも不正確な文章だと言えます。IVとHVの違いを理解している人でもつい説明する手間を省いて、こういう表現をしがちなんだと思いますが、説明する側がよく理解していないケースも多いと思います。&lt;/p&gt;

&lt;h3 id=&quot;違いが分かる説明の仕方&quot;&gt;違いが分かる説明の仕方&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E3%83%9C%E3%83%A9%E3%83%86%E3%82%A3%E3%83%AA%E3%83%86%E3%82%A3&quot;&gt;wikipediaによるボラティリティの説明&lt;/a&gt;は学問的で、これはこれでいいのかもしれません。それに「インプライド・ボラティリティとは&lt;strong&gt;現実のオプション市場でついたオプション価格から逆算されたボラティリティ&lt;/strong&gt;のことである」とこれ以上望めない簡潔な言葉で言い表されています。&lt;br /&gt;
しかし、これ&lt;br /&gt;
&lt;img src=&quot;https://upload.wikimedia.org/math/c/8/9/c89911f0951782890cbb855572aa9de7.png&quot; alt=&quot;wikipediaのHVの数式&quot; /&gt;&lt;br /&gt;
とか、&lt;br /&gt;
こういう&lt;br /&gt;
&lt;img src=&quot;https://upload.wikimedia.org/math/1/9/b/19beb2fcdc78f6d56e3e16ad3f04c624.png&quot; alt=&quot;wikipediaのIVの数式&quot; /&gt;&lt;br /&gt;
難しい数式が出てくるので、「要するにどちらも値動きの荒さ、変動率のことだろ？」と言う感じで思考を中断してしまいがちだと思うのです。オプションという商品を理解しているつもりだった自分も、&lt;a href=&quot;https://my-posi.herokuapp.com&quot;&gt;先物・オプション売買損益シミュレーションサイト&lt;/a&gt;を自分で作ってみるまではIVとHVの違いを明確に区別出来ていなくて、よく似たような物ぐらいに考えていました。２つの間には相関関係が非常に薄いにも関わらずです。&lt;br /&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
ヒストリカル・ボラティリティxとオプション理論価格yは以下のように表すことが出来て、  \\
y = ax\\
オプションの実際の価格がy_1であった時に、導き出されるものがインプライド・ボラティリティx_1である。  \\
x_1 = \frac{y_1}{a}\\
&lt;/script&gt;
という感じで簡略化した数式を書いてくれれば２つのボラティリティの関係が分かりやすいと思うんですけど、どうでしょうか？&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>DBのカラムに対応しないプロパティ</title>
   <link href="https://happyclam.github.io/programming/2014-05-26/my-posi_tip1"/>
   <updated>2014-05-26T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2014-05-26/my-posi_tip1</id>
   <content type="html">&lt;h3 id=&quot;日付型のカラムのデータを年月だけの文字列にしてコンボボックスに表示したい&quot;&gt;日付型のカラムのデータを年月だけの文字列にしてコンボボックスに表示したい&lt;/h3&gt;
&lt;p&gt;先物やオプションの建玉を入力する時には限月を選ぶ必要がありますが、必要なのは年と月(“2014/06”等の文字列)だけです。でもDBに”年/月”のフォーマットで文字列として格納するのはあまりにも汚い。DBのカラム属性は日付型にしておいた方が何かと便利、というかしておくべきでしょう（日数や時間の差を計算する時に困ります）。&lt;br /&gt;
&lt;img src=&quot;/images/dropdown_exp.png&quot; alt=&quot;限月の選択&quot; title=&quot;限月の選択&quot; /&gt;&lt;br /&gt;
こういう場合、昔PHPで仕事していた時には、文字列型と日付型を相互にフォーマット変換するコードをView上のあちこちに散りばめながら実現していた記憶があります。&lt;/p&gt;

&lt;h3 id=&quot;シンプルな実現方法&quot;&gt;シンプルな実現方法&lt;/h3&gt;
&lt;p&gt;Position.expirationがDBのカラムに対応するプロパティで日付型です。そこにPosition.ym_expirationというDBにカラムが存在しない入出力用のプロパティを用意し、そのsetterとgetterを定義します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Model(Position)&lt;br /&gt;
getter(日付型のデータを、年/月のフォーマットの文字列に変換してして返す)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  def ym_expiration
    return self.expiration.strftime(&quot;%Y/%m&quot;) if self.expiration
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setter(年/月の文字列データを日付01を付加して日付型に変換して格納)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  def ym_expiration=(ym_expiration)
    self.expiration = Date.strptime(ym_expiration + &quot;/01&quot;, &quot;%Y/%m/%d&quot;)
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Viewから呼ばれる、年/月の文字列データを返すメソッド&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  def get_expiration_list
    :省略
    :
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;View(_edit_position.html.erb)&lt;br /&gt;
Viewでは入出力用に追加したym_expirationプロパティだけを使うようにすれば、あたかもDBに対応するカラムのように扱えます。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ERB&quot;&gt;&amp;lt;td align=&quot;center&quot;&amp;gt;&amp;lt;%= f.select(&quot;ym_expiration&quot;, position.get_expiration_list, {:include_blank =&amp;gt; false}, {:class =&amp;gt; &quot;span6&quot;, :style =&amp;gt; &quot;width:90px;&quot;}) %&amp;gt;&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CakephpやPHP5以上ならたぶん同じことが出来ると思いますが、もうPHPに戻りたくないし調べる気にもなりません&lt;/p&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>先物・オプションのシミュレーションサイト</title>
   <link href="https://happyclam.github.io/project/2014-05-24/my-posi"/>
   <updated>2014-05-24T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/project/2014-05-24/my-posi</id>
   <content type="html">&lt;p&gt;Project: 「&lt;a href=&quot;https://my-posi.herokuapp.com/&quot;&gt;&lt;strong&gt;みんなのポジション&lt;/strong&gt;&lt;/a&gt;」: &lt;a href=&quot;https://github.com/happyclam/my-posi&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;開発の動機&quot;&gt;開発の動機&lt;/h3&gt;
&lt;p&gt;当時、利用している証券会社のシステムが物足りなく信用できないものであったため自作しました。でも自分で作成した後、まもなくネット証券側もシステムをリニューアルして、自分のものより遥に高機能なものに置き換わったのですが、損益グラフを表示した時にグラフのメモリ幅を変更出来ないため見にくいという不満があったりするので、その点でまだは自分のソフトの方が優れているかなと思っています。まぁオプション売買を活発にしている人はそれ程多くないと思いますので、証券会社も力を入れていないのだと思います。５社ほどで取引したことありますが、そもそもオプション売買のシミュレーション機能なんて無い証券会社もありました。&lt;br /&gt;
最近は自分もあまりオプション取引をしていないのでよく知りませんが、今ではWebベースでもWindowsネイティブソフト並にユーザインターフェースに凝ったソフトを提供している証券会社があるかもしれません。&lt;/p&gt;

&lt;h3 id=&quot;機能&quot;&gt;機能&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;日経225先物、日経225先物ミニ、日経225オプション(CALL,PUT)の建玉を一つのポジション、複数のポジションをまとめたものをストラテジーとして、ユーザ毎の複数のストラテジーの保存。&lt;/li&gt;
  &lt;li&gt;複数の建玉の売買シミュレーションと損益推移（個別・合算）グラフを表示&lt;br /&gt;
※ブラックショールズモデルを利用したオプション理論価格計算に対応しているので、満期（SQ）時の損益だけでなく、現時点での原資産価格（日経225先物価格）毎の損益推移を表示出来ます&lt;/li&gt;
  &lt;li&gt;twitterを利用したユーザー認証とポジションをtwitterで呟く&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;er図&quot;&gt;ER図&lt;/h3&gt;
&lt;object data=&quot;/pdf/ERD.pdf&quot; width=&quot;760&quot; height=&quot;480&quot;&gt;
&lt;p&gt;ご覧の環境では、object要素がサポートされていないようです。&lt;a href=&quot;/pdf/ERD.pdf&quot;&gt;PDFファイルをダウンロードしてください&lt;/a&gt;&lt;/p&gt;
&lt;/object&gt;

&lt;p&gt;UserモデルとStrategyモデルが1対多、StrategyモデルとPositionモデルが1対多で関連付けられている単純なテーブル構造です。&lt;br /&gt;
他のテーブルと関連付けられていないCandlestickモデルというのはネット上に転がっている先物価格のロウソク足用のcsvデータを流し込むためのテーブルで、ヒストリカル・ボラティリティ（HV）を計算するためだけに使用しています。HVの計算方法には色々あるようですが、自分が使用したのは&lt;a href=&quot;https://www.option-dojo.com/kn/225_vola.html&quot;&gt;ここ&lt;/a&gt;に記載されている方法に倣っています。&lt;br /&gt;
気が向いたときにcsvデータを手動で更新するという運用の仕方をしてました。画面から手入力するとその値を優先して使用するようにしているので、実際にはHVを手入力して使うことが多かったです。開発当時は無かったのですが、今なら日経平均ボラティリティインデックスがリアルタイムで更新されているのでその値を手入力する方がいいかもしれません。20%（日経平均VIが20ポイント）であれば0.2を入力します。このHVの値を使ってオプション理論価格を算出します。&lt;br /&gt;
※ボラティリティにはHVとは別にインプライド・ボラティリティ（IV）というものがありますが、ボラティリティに関しては別記事を書こうと思います。&lt;/p&gt;

&lt;h3 id=&quot;テーブル構造&quot;&gt;テーブル構造&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Userテーブル&lt;/em&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;名称&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;例&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;name&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;サイト内で使用する独自のユーザ名&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;provider&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;twitter認証APIで返される文字列&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“twitter”&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;screen_name&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;twitter認証APIで返される文字列&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“SappierBoy”&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;uid&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;twitter認証APIで返される文字列&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“1111111111”&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Strategyテーブル&lt;/em&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;名称&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;例&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;draw_type&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;損益グラフを個別表示するか合算表示するか&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;1,未定義&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;interest&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;金利&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.02&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;name&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;ストラテジー名&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“abc戦略”&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;range&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;グラフの幅デフォルト500とした相対数値で拡大・縮小&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;500&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;sigma&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;オプション理論価格計算に使用するボラティリティ(HV)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.2&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Positionテーブル&lt;/em&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;名称&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;例&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;distinct&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;商品種別（日経225先物、日経225先物mini、CALLオプション、PUTオプション）&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;exercise&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;行使価格（オプションの場合のみ、先物の場合はnil）&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.02&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;expiration&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;限月（満期月）&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“2014/06”&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;maturity&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;残存日数（1日に満たない場合も日数換算）&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.1～365&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;number&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;オプション理論価格計算に使用するボラティリティ&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;sale&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;売り、買いの区別&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;unit&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;商品単価&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Candlestickテーブル&lt;/em&gt;&lt;br /&gt;
※どこから先物価格のデータを取得するかでテーブル構造は変わるので省略します。必要なのはオプションの原資産となる先物価格の終値20日分です。私が利用していたのは&lt;a href=&quot;https://k-db.com/&quot;&gt;このサイト&lt;/a&gt;です。&lt;br /&gt;
以下のようにcsvデータをダウンロード&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;wget -O ./lib/futures.csv &quot;https://k-db.com/site/jikeiretsuF.aspx?c=101&amp;amp;year=0&amp;amp;download=csv&quot;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;csvデータから先物価格データを格納&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rails runner Candlestick::biteoff
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.co.jp/%E4%B8%96%E7%95%8C%E4%B8%80%E3%82%84%E3%81%95%E3%81%97%E3%81%84%E9%87%91%E8%9E%8D%E5%B7%A5%E5%AD%A6%E3%81%AE%E6%9C%AC%E3%81%A7%E3%81%99-%E7%94%B0%E6%B8%95-%E7%9B%B4%E4%B9%9F/dp/4534040512/ref=sr_1_1?ie=UTF8&amp;amp;qid=1413415898&amp;amp;sr=8-1&amp;amp;keywords=%E3%80%8C%E4%B8%96%E7%95%8C%E4%B8%80%E3%82%84%E3%81%95%E3%81%97%E3%81%84%E9%87%91%E8%9E%8D%E5%B7%A5%E5%AD%A6%E3%81%AE%E6%9C%AC%E3%81%A7%E3%81%99%E3%80%8D&quot;&gt;「世界一やさしい金融工学の本です」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>rspecに納得できない</title>
   <link href="https://happyclam.github.io/programming/2014-05-17/inflexible-rspec"/>
   <updated>2014-05-17T00:00:00+09:00</updated>
   <id>https://happyclam.github.io/programming/2014-05-17/inflexible-rspec</id>
   <content type="html">&lt;p&gt;先日衝動買いした&lt;a href=&quot;https://www.amazon.co.jp/Instant-RSpec-Test-Driven-Development-How-ebook/dp/B00DMYO1QK&quot;&gt;Instant RSpec Test-Driven Development How-to [Kindle版]&lt;/a&gt;の最初に出てくるサンプルコード&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#location_spec.rb
describe Location do
  describe &quot;#initialize&quot; do
    it &quot;sets the latitude and longitude&quot; do
      loc = Location.new(:latitude =&amp;gt; 38.911268,
                         :longitude =&amp;gt; -77.444243)
      loc.latitude.should == 38.911268
      loc.longitude.should == -77.444243
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;上記テストを通過させるために「自分が書いたコード」が以下のもの&lt;code&gt;rspec failed&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;   #my_answer.rb  
   class  Location  
       attr_accessor :latitude  
       attr_accessor :longitude  
       def initialize(lati=nil, long=nil)  
           @latitude = lati  
           @longitude = long  
       end  
   end  
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;「リファクタリング前のコード」として本で紹介されているコード&lt;code&gt;rspec passed&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;   #bad_answer.rb
   class  Location
       def initialize(args = {});end
       def latitude
           38.911268
       end
       def longitude
           -77.444243
       end
   end
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;「リファクタリング後のコード」として本で紹介されているコード&lt;code&gt;rspec passed&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;   #model_answer.rb
   class Location
       attr_accessor :latitude, :longitude
       def initialize(args = {})
           self.latitude = args[:latitude]
           self.longitude = args[:longitude]
       end
   end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストを通過させるためだけに書かれたような「リファクタリング前のコード」がエラーにならないのに、上記「自分のコード」がエラーになるのは納得がいかない。&lt;br /&gt;
自分のコードに何かエラーにしなければならない理由があるのか？自分にはわからないので誰か教えてください。&lt;/p&gt;

</content>
 </entry>
 
 
</feed>