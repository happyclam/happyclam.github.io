<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=2.0, user-scalable=yes">
  <meta name="author" content="happyclam">
  <meta name="description"
    content="三目並べ（tic tac toe）で遊んでみた（続き） ちょっと変わった三目並べ（ArrangeLine）の検証 Reinventing the wheel.">
  <title> 三目並べ（tic tac toe）で遊んでみた（続き） - 自己満足プログラミング </title>

  <!-- Global Site Tag (gtag.js) - Google Analytics -->
  <!-- <script async src="https://www.googletagmanager.com/gtag/js?id=UA-1752720-7"></script> -->
  <!-- <script> -->
  <!--   window.dataLayer = window.dataLayer || []; -->
  <!--   function gtag(){dataLayer.push(arguments);} -->
  <!--   gtag('js', new Date()); -->
  <!--   gtag('config', 'UA-1752720-7'); -->
  <!-- </script> -->

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@SappierBoy">
  <meta name="twitter:creator" content="@SappierBoy">
  
  <meta name="twitter:title" content="三目並べ（tic tac toe）で遊んでみた（続き）">
  
  
  <meta name="twitter:url" content="/software/2014-10-04/arrange_line">
  
  
  <meta name="twitter:description" content="Reinventing the wheel.">
  
  
  <meta name="twitter:image:src" content="https://happyclam.github.io/images/favicon.png">
  

  <!-- stylesheets -->
  <link media="all" href="//netdna.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
  <link media="all" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link media="all" rel="stylesheet" href="/assets/css/site.css">

</head>


<body>
  <header>
  <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a id="site-title" class="navbar-brand" href="/">
          <img class="pull-left img-responsive" src="">
          <span class="name-holder">自己満足プログラミング</span>
        </a>
      </div>

      <div class="collapse navbar-collapse" id="navbar">

        <ul id="main-menu" class="nav navbar-nav navbar-right">

          
            <li><a href="/">
              <i class="fa fa-home"></i> Home</a>
            </li>
          
            <li><a href="/categories/">
              <i class="fa fa-sitemap"></i> Categories</a>
            </li>
          
            <li><a href="/tags/">
              <i class="fa fa-tag"></i> Tags</a>
            </li>
          
            <li><a href="/about/">
              <i class="fa fa-info-circle"></i> About</a>
            </li>
          
            <li><a href="/policy/">
              <i class="fa fa-check"></i> Policy</a>
            </li>
          

        </ul>
      </div>
      <!-- /.navbar-collapse -->
    </div>
    <!-- /.container-fluid -->
  </nav>
</header>

    <div style="text-align: center;">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-9018029357773039",
        enable_page_level_ads: true
        });
      </script>
    </div>
  <div class="blog-header">
    <div class="span3">
      <a href="https://twitter.com/share" class="twitter-share-button"{count} data-via="SappierBoy">Tweet</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    </div>
  </div>
  
  <div class="container">
  <div class="row">
    <div class="col-xs-12 col-sm-12 col-md-offset-1 col-md-10 col-lg-offset-2 col-lg-8">
      <div class="page">

        <header class="page-header">
          <h2 class="page-title"><a href="/software/2014-10-04/arrange_line">三目並べ（tic tac toe）で遊んでみた（続き）</a></h2>
          <div class="post-metadata">
            <div> <i class="fa fa-calendar"></i>
              <time>
                Saturday, October 04, 2014
              </time>
            </div>
            <div> <i class="fa fa-tag"></i>
                
                  <span class="label label-tag">ruby</span>
                
                  <span class="label label-tag">programming</span>
                
                  <span class="label label-tag">tictactoe</span>
                
            </div>
          </div>

        </header>

        <article class="page-content">
          <h3 id="先読み手数を制限しても必勝の結論は出ないはず">先読み手数を制限しても必勝の結論は出ないはず</h3>
<p>　<a href="/software/2014-09-23/tictactoe_arrange">前回の記事</a>で自分が作ったプログラムは千日手対応をしていないから先手必勝の結論が出ても信用できないって書きましたが、よく考えてみたら千日手対応していなくても先手必勝の評価が出てくるってことは、ArrangeLineってゲームが先手必勝であるか検証に使った自分のプログラムがバグっているかのどちらかであると気づきました。評価関数が返す値は一つの局面に関して勝ちか負けか引き分けかの三種類にしか分けていないので、千日手の局面は引き分けの一局面として評価しているはずで、引き分けに成り得るなら後手は引き分けになる手を選択し先手勝ちの評価にはならない。スタンダードの三目並べを調べた場合と違って、11手読みという手数を限定して先読みをしているわけだからそんなこともあるかと流してしまったけど、読み切っていないから勝ちか負けか決められない（引き分けになる）という評価が返ってくることはあっても、引き分けがあり得るのに必勝・必敗の評価を返してくるというのはバグっている可能性が高いのではないか。でも一応スタンダードな三目並べでは問題なさそうだし、バグの見当が付かなかったのでまずは先に千日手対応をしてみることにしました。<br />
　その前にArrangeLineをダウンロードして自分のプログラムと対戦させて確認したのですが、ArrangeLineのLevel2で自分のプログラムが先手なのに千日手になり決着が付かないケースがありました。実際に千日手になることを確認していたためArrangeLineは双方最善手を打てば千日手になるゲームだと思ってしまったのですが、繰返しますが千日手になるのであればやっぱり先手必勝の結論が出るのはおかしい。</p>

<h3 id="千日手対応">千日手対応</h3>
<p>　先読みの最中に過去に現れた局面が一定周期で続いて現れるかどうかを判定するってプログラムが重くなりそうだし、難しそうな気がして対応する気がしなかったのですが、よく考えてみると先読みの最中である必要は無く、実際に打った一手だけを局面毎に保存しておいて、先読みを開始する一手目の時だけ過去に同一局面があったかどうかを調べるだけで済みそうです。これなら重くなることもありません。<br />
　※<a href="/software/2014-09-23/tictactoe_arrange">前回の記事</a>で必ず千日手になることを証明するのは難しいと書いたのは、完全読み切りが出来ない場合（将棋もその一つ）はたしかにその通りですが、先手必勝あるいは後手必勝という結論を返してくるということは完全読み切りが出来ているということなので、その時点で千日手は結論に関係無かったと言うことです。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  #過去に同一局面があったかどうか判定
  def check_dup(sengo)
    temp = self.dup
    temp.unshift(sengo)
    return @duplication.has_key?(temp.hash)
  end
  #局面データのハッシュ値だけ保存
  def set_dup(sengo)
    temp = self.dup
    temp.unshift(sengo)
    @duplication[(temp).hash] = temp
  end

</code></pre></div></div>
<p>　局面データと手番データからハッシュ値を生成して保存するメソッドと、そのハッシュ値を検索するメソッドを追加。<br />
　過去に評価した局面を再現したりその時の評価値を再利用したりするわけでは無く、過去に同一局面があったかどうかを判断するだけなので保存するのはハッシュ値だけでもいいのですが、一応局面と手番のデータを保存しています。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        if board.check_dup(turn)
          temp_v = 0
</code></pre></div></div>
<p>　そして局面を評価した後に過去に現れた局面なら強制的に評価値を引き分け（DRAW=0）にする処理を追加しただけです。引き分けでなく同じ局面を再現させたら負けとすることも考えられますが、それだとArrangeLineと対戦させたときにこのソフト側だけが不利なルールで戦うことになるのでよくありません。その他にも評価値を少し下げるとかいろいろ奥が深そうですが、将棋のように何らかの千日手に関するルールが無い限りは引き分けの評価（0）でよさそうです。<br />
　ということで、同一局面を出現させたら引き分けという評価を返す状態で、前回の記事同様に一手打った状態から検証プログラムを動かしてみます。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> |1|2|3|
 |4|5|6|
 |7|X|9|
2手目: 1 評価値: 9
2手目: 2 評価値: 9
2手目: 3 評価値: 9
2手目: 4 評価値: 9
2手目: 5 評価値: 9
2手目: 6 評価値: 9
2手目: 7 評価値: 9
2手目: 9 評価値: 9
</code></pre></div></div>
<p>　前回と同じく初手に辺の部分に打てばやっぱり先手必勝になるという結果になります。そして実際のandroidアプリと対戦させて見たところ、以前は先手なのに必ず千日手になっていたケースでも千日手を避けるようになり、先手の場合に限っては必ず勝利することが出来るようです。なのでArrangeLineは先手必勝のゲームと言っていいでしょう。もし何か間違いに気づいた人がいれば連絡して下さい。景品を差し上げます…ウソです。</p>

<ul>
  <li>
    <p><em>自作プログラムの対戦状況</em></p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">先手・後手\ArrangeLineのLevel</th>
          <th style="text-align: left"> </th>
          <th style="text-align: center">Level 1</th>
          <th style="text-align: center">Level 2</th>
          <th style="text-align: center">Level 3</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">自作プログラムが先手</td>
          <td style="text-align: left"> </td>
          <td style="text-align: center">勝ち</td>
          <td style="text-align: center">勝ち</td>
          <td style="text-align: center">勝ち</td>
        </tr>
        <tr>
          <td style="text-align: left">自作プログラムが後手</td>
          <td style="text-align: left">初手が辺</td>
          <td style="text-align: center">勝ち</td>
          <td style="text-align: center">勝ち</td>
          <td style="text-align: center">負け</td>
        </tr>
        <tr>
          <td style="text-align: left">^</td>
          <td style="text-align: left">初手が辺以外</td>
          <td style="text-align: center">勝ち</td>
          <td style="text-align: center">勝ち</td>
          <td style="text-align: center">千日手</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p>　ArrangeLineは乱数を使っているようなのでこの表の結果はいつも同じではないはずですが、自作プログラムが先手の場合はいつも勝ちます。それと千日手対応したのに千日手になることがあるのは自作のプログラムが後手で、負けるはずなのにArrangeLine側が初手で辺の部分（2,4,6,8）を取らなかったために起きる現象です。自作ソフト側としては後手なので勝てないから千日手に持っていくしか無い状況ってことです。これは<a href="/software/2014-09-23/tictactoe_arrange">前回の記事</a>で初手から検証した時に以下の結果になったことと符合します。初手で辺の部分を取らない場合は、勝てるとは限らないということです。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> |1|2|3|
 |4|5|6|
 |7|8|9|
1手目: 1 評価値: 0
1手目: 2 評価値: 9
1手目: 3 評価値: 0
1手目: 4 評価値: 9
1手目: 5 評価値: 0
1手目: 6 評価値: 9
1手目: 7 評価値: 0
1手目: 8 評価値: 9
1手目: 9 評価値: 0
</code></pre></div></div>

<h3 id="先手後手が決まった段階で勝負は既に決まっている">先手・後手が決まった段階で勝負は既に決まっている</h3>
<p>　androidアプリのArrangeLine側は乱数を使っているようなので必ず再現するわけではないのですが、私のプログラムが先手の場合は必ず勝つのですが、後手の場合は最短の5手で負ける場合があります。</p>

<div style="width:240px; height:287px; margin:0 auto;">

  <p><img src="/images/arrangeline.png" alt="負け画像" /></p>

</div>

<p>　先手がリーチ（あと一手でラインが揃う）状態になっても揃うことを防ごうとしないことがあるのです。最初はバグか？と思いましたが、これもよく考えてみると私のソフト側は後手で尚且つ初手で辺の部分を取られていると、どう足掻いても負けることがわかっているので勝つことを諦めているわけです。<a href="/project/2014-08-05/tictactoe">以前の記事</a>に通常ルールの三目並べソフトが初手に有利なはずの真ん中を取らないことを書きましたが、初手にどこを取っても引き分けになることを読み切っている（初手にどこを選んでも引き分けの評価値が返ってくる）ので、1（左上隅）の場所から順に読み始めて最後に評価した9の場所（右下隅）を取る現象と同じです。ArrangeLineでも初手に辺の部分を取られているとその後どういう変化をしようが負けることがわかっている（先手勝ちの評価値MAX_VALUE=9が返ってくる）ため、相手がリーチをかけていようがいまいが関係なくたまたま最後に評価した場所を選んでしまいます。一回リーチを防いでも負けることが分かってるのですから…。<br />
　この現象を防ぐにはどうすればいいのか、前にも書きましたが将棋にしろオセロにしろ局面の形勢判断用の評価関数と読み切り用（将棋で言えば詰将棋用）の評価関数を分けて使用するか、リーチを優先的に防ぐ処理（将棋で言えば王手放置を避ける）を用意すればいいのでしょうが、相手が間違えない限り手数を伸ばすだけで、勝敗は既に決まっています。将棋と違って完全読切りが完了しているゲームでこの処理を入れるのは虚しいだけでしょう。ただ、このArrangeLineに関して言えばandroid端末用のゲームなので完全読切りするにはマシンパワーの制限で難しいからそれなりに形勢判断用の評価関数を工夫する意味はあると思います。自分はあまり興味湧きませんが…<br />
　今回の記事の中で「よく考えてみると」と何度も書いてますが、この手のソフトは自分の意図通りに動いているのかうまくいっていないのか結構悩まされます。最後の例でもそうですが、考えて納得して改良したあとにいきなり5手で負けたりするとさっぱり意味が分からなくなりました。でも、特別なアルゴリズムを使わなくても完全読み切りが出来るわけですから、将棋なんかに較べたら作り易いゲームではあると思います。今回、千日手回避のために他にもいろいろ試行錯誤したのでそれらの手法を使って将棋作りに活かしてみようと思っています。</p>


        </article>
      </div>
    </div>
  </div>
</div>


  

<footer class="footer">
    <div class="container">
      <div class="row">
        <div class="col-lg-offset-3 col-lg-6">
            <div class="row">
              <div class="col-xs-12 text-center">
                <small>&copy; rifyll theme, 2014</small>
              </div>
            </div>
        </div>
      </div>
    </div>
  </footer>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
  <!--<script src="/assets/js/prism.js"></script> -->
  <script src="/assets/js/site.js"></script>

</body>

</html>
