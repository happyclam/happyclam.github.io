<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>自己満足プログラミング</title>
        <description>自己満足プログラミング - happyclam</description>
        <link>http://happyclam.github.io</link>
        <link>http://happyclam.github.io</link>
        <lastBuildDate>2016-01-16T09:14:09+09:00</lastBuildDate>
        <pubDate>2016-01-16T09:14:09+09:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>学習効果をグラフ化してみる</title>
                <description>&lt;h3 id=&quot;github-pagesgithub-pagesurlflotr2flotr2url&quot;&gt;ブログ（&lt;a href=&quot;http://jekyllrb-ja.github.io&quot;&gt;Github Pages&lt;/a&gt;）でグラフ描画（&lt;a href=&quot;http://www.humblesoftware.com/flotr2&quot;&gt;Flotr2&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;　ジュンク堂書店でオライリーのカレンダーを入手するために&lt;a href=&quot;http://www.amazon.co.jp/本-JavaScriptによるデータビジュアライゼーション入門-Stephen-Thomas/dp/4873117461/ref=sr_1_1?ie=UTF8&amp;amp;qid=1452166533&amp;amp;sr=8-1&amp;amp;keywords=javascript+ビジュアライゼーション&quot;&gt;「JavaScriptによるデータビジュアライゼーション入門」&lt;/a&gt;という本を買ってしまいました。前回まで三目並べプログラムの学習効果の記事を書いていましたが、１０万回対戦（学習）後の最終結果だけではなく、推移をグラフ化してみたいと思っていながらも面倒なのでやってなかったのですが、本を買ったことでやる気が出たので、awkやemacsのキーボードマクロを駆使してグラフ用データを編集してみました。今回はとりあえず買った本の内容は置いといて、グラフ化した学習効果の結果について書きます。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;小石の数を減らしたことの影響&lt;/h3&gt;
&lt;p&gt;　前回までのテストで小石の初期値や補充数を少なくすることが一番効果的だということがわかったので、まずは小石の初期値と補充分を１０個にしていた「従来の強化学習」と、「１０個から１個に修正した」分と、全てのテストを通して一番学習効果が高かった線形関数（&lt;script type=&quot;math/tex&quot;&gt; y = \frac{1}{総手数} x &lt;/script&gt;）を使った「終盤の手ほど重要視」するパターンの３つのグラフを比較してみます。&lt;br /&gt;
　横軸の１目盛りが千回分の対戦で、縦軸に下から勝ち（青）・負け（黄緑）・引分（赤）の数を積み上げてグラフにしています。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;対乱数プログラムにおける学習効率の比較&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-1&quot;&gt;最終成績&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;No.&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;学習方法&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　対乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;65,266勝22,986敗11,748分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;74,470勝15,664敗9,866分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;76,304勝13,126敗10,570分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;section-2&quot;&gt;推移グラフ&lt;/h5&gt;

&lt;div id=&quot;rand-allten-int&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;rand-allone-int&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;rand-linear&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　このグラフを見ると弱い対戦相手（乱数プログラム）を使っていくら学習を続けても、ある回数（３、４万回）に達すると限界に達してそれ以上続けても学習効果が望めなくなる（強くならない）ことが推測できます。これは人間が将棋や囲碁を学習する際にも当てはまりそうです。また、３つのグラフを比較すると学習し始めた頃は学習の仕方によって伸び方が違ってくるということも見て取れますが、これも人間と同じだと言えそうです。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;対最強プログラムにおける学習効率の比較&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-3&quot;&gt;最終成績&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;No.&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;学習方法&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝9,678敗90,322分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝3,891敗96,109分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝2,038敗97,962分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;section-4&quot;&gt;推移グラフ&lt;/h5&gt;

&lt;div id=&quot;dfs-allten-int&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;dfs-allone-int&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;dfs-linear&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　人間の実力と並んでいるであろうと考えられる「引き分け率９割７分」に達するのは、学習方法１が約44,000回後、学習方法２が約17,000回後、学習方法３が約9,000回後です。小石の総数を減らすことと終盤を重要視する方法を組み入れることで、学習効果が向上することがグラフからはっきりと見てとれます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;グラフの傾きを変えることによる影響&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2015-12-25/log-linear/&quot;&gt;前々回の記事&lt;/a&gt;でいろいろな方程式を使って結果を比較しましたが、途中経過がなかったので違いがよく分かりませんでした。対最強プログラムに対する引き分け数だけを取り出してみて同一グラフ上に学習度合いの推移を描画し比較してみました。&lt;/p&gt;

&lt;div id=&quot;dfs-regression&quot; style=&quot;width:600px;height:300px;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　&lt;a href=&quot;/software/2015-12-25/log-linear/&quot;&gt;前々回の記事&lt;/a&gt;の方程式１（青、&lt;script type=&quot;math/tex&quot;&gt; y = \frac{1}{総手数} x &lt;/script&gt;）と方程式２（黄緑、&lt;script type=&quot;math/tex&quot;&gt; y = 0.029 \times 1.882^x &lt;/script&gt;）が、わずかですが他の２つの方程式より学習効率がいいということがグラフから分かります。&lt;br /&gt;
　でも、グラフが少し見にくいですね。１０万回分の対戦データを取らなくても、２万回分程度のデータでグラフを描画すべきだったのでしょうか？でも、そうするともっと対戦を続けた場合どうなるか知りたくなるので、これはこれでいいと思います。こういう時こそ今回導入したグラフライブラリの出番です。&lt;br /&gt;
　そこで&lt;a href=&quot;http://www.flotcharts.org&quot;&gt;Flotライブラリ&lt;/a&gt;を使って、次の記事で拡大表示可能なグラフに変更してみます。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

function show_dfs_allone_int(){
    var dfs_lose = [];
    var dfs_win = [[1 ,645],[2 ,465],[3 ,413],[4 ,327],[5 ,278],[6 ,201],[7 ,167],[8 ,136],[9 ,79],[10 ,61],[11 ,55],[12 ,43],[13 ,50],[14 ,47],[15 ,46],[16 ,36],[17 ,26],[18 ,23],[19 ,23],[20 ,28],[21 ,24],[22 ,23],[23 ,18],[24 ,15],[25 ,22],[26 ,14],[27 ,16],[28 ,19],[29 ,12],[30 ,15],[31 ,16],[32 ,13],[33 ,11],[34 ,9],[35 ,15],[36 ,14],[37 ,12],[38 ,14],[39 ,15],[40 ,12],[41 ,11],[42 ,15],[43 ,10],[44 ,5],[45 ,10],[46 ,10],[47 ,9],[48 ,10],[49 ,7],[50 ,8],[51 ,7],[52 ,12],[53 ,10],[54 ,18],[55 ,14],[56 ,13],[57 ,8],[58 ,5],[59 ,9],[60 ,13],[61 ,5],[62 ,13],[63 ,4],[64 ,10],[65 ,12],[66 ,3],[67 ,5],[68 ,7],[69 ,7],[70 ,2],[71 ,3],[72 ,6],[73 ,5],[74 ,8],[75 ,6],[76 ,6],[77 ,5],[78 ,10],[79 ,7],[80 ,9],[81 ,5],[82 ,6],[83 ,6],[84 ,6],[85 ,6],[86 ,4],[87 ,6],[88 ,3],[89 ,5],[90 ,4],[91 ,4],[92 ,7],[93 ,7],[94 ,4],[95 ,7],[96 ,2],[97 ,4],[98 ,1],[99 ,5],[100 ,4],];
    var dfs_draw = [[1 ,355],[2 ,535],[3 ,587],[4 ,673],[5 ,722],[6 ,799],[7 ,833],[8 ,864],[9 ,921],[10 ,939],[11 ,945],[12 ,957],[13 ,950],[14 ,953],[15 ,954],[16 ,964],[17 ,974],[18 ,977],[19 ,977],[20 ,972],[21 ,976],[22 ,977],[23 ,982],[24 ,985],[25 ,978],[26 ,986],[27 ,984],[28 ,981],[29 ,988],[30 ,985],[31 ,984],[32 ,987],[33 ,989],[34 ,991],[35 ,985],[36 ,986],[37 ,988],[38 ,986],[39 ,985],[40 ,988],[41 ,989],[42 ,985],[43 ,990],[44 ,995],[45 ,990],[46 ,990],[47 ,991],[48 ,990],[49 ,993],[50 ,992],[51 ,993],[52 ,988],[53 ,990],[54 ,982],[55 ,986],[56 ,987],[57 ,992],[58 ,995],[59 ,991],[60 ,987],[61 ,995],[62 ,987],[63 ,996],[64 ,990],[65 ,988],[66 ,997],[67 ,995],[68 ,993],[69 ,993],[70 ,998],[71 ,997],[72 ,994],[73 ,995],[74 ,992],[75 ,994],[76 ,994],[77 ,995],[78 ,990],[79 ,993],[80 ,991],[81 ,995],[82 ,994],[83 ,994],[84 ,994],[85 ,994],[86 ,996],[87 ,994],[88 ,997],[89 ,995],[90 ,996],[91 ,996],[92 ,993],[93 ,993],[94 ,996],[95 ,993],[96 ,998],[97 ,996],[98 ,999],[99 ,995],[100 ,996]];

    Flotr.draw(
        document.getElementById(&quot;dfs-allone-int&quot;),
        [
            {data: dfs_lose, label: &quot;勝ち&quot;},
            {data: dfs_win, label: &quot;負け&quot;},
            {data: dfs_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;小石の初期値と補充分を１０から１に修正&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_rand_allone_int(){
    var rand_lose = [[1 ,462],[2 ,508],[3 ,519],[4 ,519],[5 ,583],[6 ,587],[7 ,623],[8 ,636],[9 ,662],[10 ,672],[11 ,651],[12 ,690],[13 ,683],[14 ,689],[15 ,653],[16 ,687],[17 ,663],[18 ,705],[19 ,690],[20 ,729],[21 ,709],[22 ,717],[23 ,746],[24 ,720],[25 ,713],[26 ,722],[27 ,736],[28 ,726],[29 ,738],[30 ,747],[31 ,740],[32 ,734],[33 ,738],[34 ,752],[35 ,737],[36 ,748],[37 ,744],[38 ,759],[39 ,759],[40 ,740],[41 ,734],[42 ,748],[43 ,754],[44 ,772],[45 ,779],[46 ,752],[47 ,787],[48 ,765],[49 ,767],[50 ,777],[51 ,793],[52 ,771],[53 ,768],[54 ,763],[55 ,779],[56 ,781],[57 ,772],[58 ,774],[59 ,790],[60 ,784],[61 ,805],[62 ,772],[63 ,775],[64 ,799],[65 ,794],[66 ,769],[67 ,798],[68 ,740],[69 ,778],[70 ,778],[71 ,770],[72 ,805],[73 ,803],[74 ,792],[75 ,803],[76 ,794],[77 ,780],[78 ,772],[79 ,809],[80 ,797],[81 ,785],[82 ,787],[83 ,777],[84 ,784],[85 ,798],[86 ,788],[87 ,805],[88 ,795],[89 ,799],[90 ,787],[91 ,825],[92 ,815],[93 ,798],[94 ,788],[95 ,799],[96 ,840],[97 ,806],[98 ,799],[99 ,810],[100 ,806]];
    var rand_win = [[1 ,424],[2 ,379],[3 ,359],[4 ,353],[5 ,294],[6 ,287],[7 ,249],[8 ,250],[9 ,223],[10 ,209],[11 ,226],[12 ,197],[13 ,207],[14 ,186],[15 ,237],[16 ,209],[17 ,213],[18 ,194],[19 ,199],[20 ,162],[21 ,185],[22 ,187],[23 ,169],[24 ,179],[25 ,180],[26 ,167],[27 ,160],[28 ,175],[29 ,151],[30 ,150],[31 ,150],[32 ,166],[33 ,173],[34 ,144],[35 ,157],[36 ,150],[37 ,146],[38 ,143],[39 ,155],[40 ,149],[41 ,169],[42 ,148],[43 ,159],[44 ,139],[45 ,133],[46 ,138],[47 ,130],[48 ,126],[49 ,137],[50 ,124],[51 ,138],[52 ,124],[53 ,147],[54 ,140],[55 ,134],[56 ,131],[57 ,138],[58 ,128],[59 ,123],[60 ,120],[61 ,129],[62 ,133],[63 ,125],[64 ,126],[65 ,122],[66 ,129],[67 ,112],[68 ,155],[69 ,117],[70 ,101],[71 ,122],[72 ,119],[73 ,105],[74 ,117],[75 ,103],[76 ,121],[77 ,130],[78 ,128],[79 ,110],[80 ,112],[81 ,122],[82 ,120],[83 ,125],[84 ,124],[85 ,108],[86 ,113],[87 ,114],[88 ,113],[89 ,111],[90 ,123],[91 ,99],[92 ,100],[93 ,112],[94 ,116],[95 ,111],[96 ,88],[97 ,107],[98 ,112],[99 ,103],[100 ,108]];
    var rand_draw = [[1 ,114],[2 ,113],[3 ,122],[4 ,128],[5 ,123],[6 ,126],[7 ,128],[8 ,114],[9 ,115],[10 ,119],[11 ,123],[12 ,113],[13 ,110],[14 ,125],[15 ,110],[16 ,104],[17 ,124],[18 ,101],[19 ,111],[20 ,109],[21 ,106],[22 ,96],[23 ,85],[24 ,101],[25 ,107],[26 ,111],[27 ,104],[28 ,99],[29 ,111],[30 ,103],[31 ,110],[32 ,100],[33 ,89],[34 ,104],[35 ,106],[36 ,102],[37 ,110],[38 ,98],[39 ,86],[40 ,111],[41 ,97],[42 ,104],[43 ,87],[44 ,89],[45 ,88],[46 ,110],[47 ,83],[48 ,109],[49 ,96],[50 ,99],[51 ,69],[52 ,105],[53 ,85],[54 ,97],[55 ,87],[56 ,88],[57 ,90],[58 ,98],[59 ,87],[60 ,96],[61 ,66],[62 ,95],[63 ,100],[64 ,75],[65 ,84],[66 ,102],[67 ,90],[68 ,105],[69 ,105],[70 ,121],[71 ,108],[72 ,76],[73 ,92],[74 ,91],[75 ,94],[76 ,85],[77 ,90],[78 ,100],[79 ,81],[80 ,91],[81 ,93],[82 ,93],[83 ,98],[84 ,92],[85 ,94],[86 ,99],[87 ,81],[88 ,92],[89 ,90],[90 ,90],[91 ,76],[92 ,85],[93 ,90],[94 ,96],[95 ,90],[96 ,72],[97 ,87],[98 ,89],[99 ,87],[100 ,86]];

    Flotr.draw(
        document.getElementById(&quot;rand-allone-int&quot;),
        [
            {data: rand_lose, label: &quot;勝ち&quot;},
            {data: rand_win, label: &quot;負け&quot;},
            {data: rand_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;小石の初期値と補充分を１０から１に修正&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: false,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_dfs_allten_int(){
    var dfs_lose = [];
    var dfs_win = [[1 ,807],[2 ,620],[3 ,583],[4 ,511],[5 ,507],[6 ,448],[7 ,392],[8 ,375],[9 ,358],[10 ,348],[11 ,324],[12 ,295],[13 ,276],[14 ,233],[15 ,225],[16 ,179],[17 ,176],[18 ,167],[19 ,141],[20 ,143],[21 ,133],[22 ,112],[23 ,114],[24 ,92],[25 ,89],[26 ,90],[27 ,78],[28 ,73],[29 ,76],[30 ,66],[31 ,79],[32 ,58],[33 ,61],[34 ,54],[35 ,52],[36 ,48],[37 ,41],[38 ,45],[39 ,43],[40 ,33],[41 ,38],[42 ,36],[43 ,32],[44 ,25],[45 ,32],[46 ,27],[47 ,28],[48 ,23],[49 ,29],[50 ,27],[51 ,20],[52 ,33],[53 ,19],[54 ,23],[55 ,34],[56 ,14],[57 ,31],[58 ,21],[59 ,18],[60 ,21],[61 ,21],[62 ,13],[63 ,19],[64 ,24],[65 ,19],[66 ,15],[67 ,17],[68 ,9],[69 ,23],[70 ,16],[71 ,13],[72 ,16],[73 ,20],[74 ,16],[75 ,15],[76 ,17],[77 ,17],[78 ,15],[79 ,13],[80 ,14],[81 ,14],[82 ,16],[83 ,13],[84 ,9],[85 ,16],[86 ,12],[87 ,16],[88 ,17],[89 ,14],[90 ,14],[91 ,19],[92 ,8],[93 ,14],[94 ,13],[95 ,16],[96 ,13],[97 ,8],[98 ,11],[99 ,11],[100 ,16]];
    var dfs_draw = [[1 ,193],[2 ,380],[3 ,417],[4 ,489],[5 ,493],[6 ,552],[7 ,608],[8 ,625],[9 ,642],[10 ,652],[11 ,676],[12 ,705],[13 ,724],[14 ,767],[15 ,775],[16 ,821],[17 ,824],[18 ,833],[19 ,859],[20 ,857],[21 ,867],[22 ,888],[23 ,886],[24 ,908],[25 ,911],[26 ,910],[27 ,922],[28 ,927],[29 ,924],[30 ,934],[31 ,921],[32 ,942],[33 ,939],[34 ,946],[35 ,948],[36 ,952],[37 ,959],[38 ,955],[39 ,957],[40 ,967],[41 ,962],[42 ,964],[43 ,968],[44 ,975],[45 ,968],[46 ,973],[47 ,972],[48 ,977],[49 ,971],[50 ,973],[51 ,980],[52 ,967],[53 ,981],[54 ,977],[55 ,966],[56 ,986],[57 ,969],[58 ,979],[59 ,982],[60 ,979],[61 ,979],[62 ,987],[63 ,981],[64 ,976],[65 ,981],[66 ,985],[67 ,983],[68 ,991],[69 ,977],[70 ,984],[71 ,987],[72 ,984],[73 ,980],[74 ,984],[75 ,985],[76 ,983],[77 ,983],[78 ,985],[79 ,987],[80 ,986],[81 ,986],[82 ,984],[83 ,987],[84 ,991],[85 ,984],[86 ,988],[87 ,984],[88 ,983],[89 ,986],[90 ,986],[91 ,981],[92 ,992],[93 ,986],[94 ,987],[95 ,984],[96 ,987],[97 ,992],[98 ,989],[99 ,989],[100 ,984]];

    Flotr.draw(
        document.getElementById(&quot;dfs-allten-int&quot;),
        [
            {data: dfs_lose, label: &quot;勝ち&quot;},
            {data: dfs_win, label: &quot;負け&quot;},
            {data: dfs_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の強化学習&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_rand_allten_int(){
    var rand_lose = [[1 ,440],[2 ,444],[3 ,458],[4 ,488],[5 ,467],[6 ,497],[7 ,500],[8 ,506],[9 ,518],[10 ,515],[11 ,535],[12 ,545],[13 ,561],[14 ,542],[15 ,550],[16 ,567],[17 ,553],[18 ,540],[19 ,567],[20 ,560],[21 ,595],[22 ,602],[23 ,584],[24 ,603],[25 ,625],[26 ,557],[27 ,619],[28 ,643],[29 ,604],[30 ,624],[31 ,634],[32 ,640],[33 ,620],[34 ,634],[35 ,621],[36 ,633],[37 ,668],[38 ,632],[39 ,649],[40 ,665],[41 ,638],[42 ,664],[43 ,682],[44 ,664],[45 ,689],[46 ,699],[47 ,644],[48 ,687],[49 ,701],[50 ,679],[51 ,684],[52 ,685],[53 ,695],[54 ,667],[55 ,673],[56 ,678],[57 ,679],[58 ,696],[59 ,697],[60 ,695],[61 ,703],[62 ,703],[63 ,687],[64 ,689],[65 ,684],[66 ,703],[67 ,716],[68 ,699],[69 ,724],[70 ,717],[71 ,720],[72 ,710],[73 ,713],[74 ,727],[75 ,728],[76 ,718],[77 ,734],[78 ,736],[79 ,718],[80 ,727],[81 ,720],[82 ,714],[83 ,716],[84 ,724],[85 ,744],[86 ,738],[87 ,728],[88 ,723],[89 ,733],[90 ,726],[91 ,736],[92 ,732],[93 ,718],[94 ,729],[95 ,746],[96 ,738],[97 ,754],[98 ,725],[99 ,731],[100 ,734]];
    var rand_win = [[1 ,438],[2 ,420],[3 ,412],[4 ,396],[5 ,388],[6 ,386],[7 ,385],[8 ,364],[9 ,358],[10 ,351],[11 ,353],[12 ,335],[13 ,318],[14 ,341],[15 ,327],[16 ,313],[17 ,325],[18 ,315],[19 ,320],[20 ,309],[21 ,281],[22 ,284],[23 ,277],[24 ,269],[25 ,243],[26 ,311],[27 ,264],[28 ,233],[29 ,282],[30 ,259],[31 ,247],[32 ,242],[33 ,265],[34 ,264],[35 ,247],[36 ,238],[37 ,224],[38 ,240],[39 ,227],[40 ,231],[41 ,233],[42 ,220],[43 ,202],[44 ,216],[45 ,206],[46 ,177],[47 ,228],[48 ,195],[49 ,179],[50 ,196],[51 ,205],[52 ,190],[53 ,198],[54 ,221],[55 ,210],[56 ,191],[57 ,192],[58 ,193],[59 ,200],[60 ,208],[61 ,191],[62 ,196],[63 ,204],[64 ,188],[65 ,188],[66 ,170],[67 ,186],[68 ,181],[69 ,168],[70 ,168],[71 ,168],[72 ,181],[73 ,172],[74 ,162],[75 ,158],[76 ,180],[77 ,153],[78 ,145],[79 ,169],[80 ,160],[81 ,176],[82 ,168],[83 ,179],[84 ,160],[85 ,152],[86 ,164],[87 ,155],[88 ,162],[89 ,171],[90 ,155],[91 ,152],[92 ,153],[93 ,165],[94 ,157],[95 ,140],[96 ,140],[97 ,139],[98 ,165],[99 ,151],[100 ,152]];
    var rand_draw = [[1 ,122],[2 ,136],[3 ,130],[4 ,116],[5 ,145],[6 ,117],[7 ,115],[8 ,130],[9 ,124],[10 ,134],[11 ,112],[12 ,120],[13 ,121],[14 ,117],[15 ,123],[16 ,120],[17 ,122],[18 ,145],[19 ,113],[20 ,131],[21 ,124],[22 ,114],[23 ,139],[24 ,128],[25 ,132],[26 ,132],[27 ,117],[28 ,124],[29 ,114],[30 ,117],[31 ,119],[32 ,118],[33 ,115],[34 ,102],[35 ,132],[36 ,129],[37 ,108],[38 ,128],[39 ,124],[40 ,104],[41 ,129],[42 ,116],[43 ,116],[44 ,120],[45 ,105],[46 ,124],[47 ,128],[48 ,118],[49 ,120],[50 ,125],[51 ,111],[52 ,125],[53 ,107],[54 ,112],[55 ,117],[56 ,131],[57 ,129],[58 ,111],[59 ,103],[60 ,97],[61 ,106],[62 ,101],[63 ,109],[64 ,123],[65 ,128],[66 ,127],[67 ,98],[68 ,120],[69 ,108],[70 ,115],[71 ,112],[72 ,109],[73 ,115],[74 ,111],[75 ,114],[76 ,102],[77 ,113],[78 ,119],[79 ,113],[80 ,113],[81 ,104],[82 ,118],[83 ,105],[84 ,116],[85 ,104],[86 ,98],[87 ,117],[88 ,115],[89 ,96],[90 ,119],[91 ,112],[92 ,115],[93 ,117],[94 ,114],[95 ,114],[96 ,122],[97 ,107],[98 ,110],[99 ,118],[100 ,114]];

    Flotr.draw(
        document.getElementById(&quot;rand-allten-int&quot;),
        [
            {data: rand_lose, label: &quot;勝ち&quot;},
            {data: rand_win, label: &quot;負け&quot;},
            {data: rand_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;従来の強化学習&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_rand_linear(){
    var rand_lose = [[1 ,486],[2 ,499],[3 ,595],[4 ,541],[5 ,602],[6 ,629],[7 ,635],[8 ,662],[9 ,660],[10 ,680],[11 ,661],[12 ,665],[13 ,683],[14 ,672],[15 ,730],[16 ,715],[17 ,704],[18 ,693],[19 ,704],[20 ,726],[21 ,732],[22 ,740],[23 ,747],[24 ,760],[25 ,742],[26 ,752],[27 ,752],[28 ,739],[29 ,754],[30 ,769],[31 ,753],[32 ,742],[33 ,774],[34 ,779],[35 ,773],[36 ,793],[37 ,773],[38 ,767],[39 ,754],[40 ,791],[41 ,772],[42 ,789],[43 ,766],[44 ,757],[45 ,796],[46 ,801],[47 ,799],[48 ,786],[49 ,764],[50 ,799],[51 ,799],[52 ,790],[53 ,782],[54 ,765],[55 ,799],[56 ,791],[57 ,800],[58 ,798],[59 ,799],[60 ,800],[61 ,809],[62 ,806],[63 ,803],[64 ,792],[65 ,797],[66 ,816],[67 ,803],[68 ,787],[69 ,808],[70 ,808],[71 ,813],[72 ,787],[73 ,817],[74 ,808],[75 ,793],[76 ,799],[77 ,807],[78 ,797],[79 ,813],[80 ,814],[81 ,822],[82 ,815],[83 ,819],[84 ,798],[85 ,806],[86 ,838],[87 ,815],[88 ,820],[89 ,828],[90 ,837],[91 ,817],[92 ,804],[93 ,809],[94 ,822],[95 ,826],[96 ,805],[97 ,835],[98 ,813],[99 ,804],[100 ,814]];
    var rand_win = [[1 ,405],[2 ,372],[3 ,288],[4 ,291],[5 ,267],[6 ,246],[7 ,233],[8 ,203],[9 ,214],[10 ,191],[11 ,198],[12 ,205],[13 ,187],[14 ,186],[15 ,145],[16 ,170],[17 ,194],[18 ,186],[19 ,181],[20 ,162],[21 ,158],[22 ,143],[23 ,142],[24 ,138],[25 ,152],[26 ,133],[27 ,128],[28 ,154],[29 ,123],[30 ,123],[31 ,138],[32 ,141],[33 ,121],[34 ,133],[35 ,129],[36 ,118],[37 ,114],[38 ,123],[39 ,131],[40 ,110],[41 ,115],[42 ,105],[43 ,112],[44 ,132],[45 ,109],[46 ,106],[47 ,119],[48 ,108],[49 ,103],[50 ,95],[51 ,103],[52 ,88],[53 ,121],[54 ,114],[55 ,95],[56 ,112],[57 ,107],[58 ,110],[59 ,90],[60 ,104],[61 ,102],[62 ,97],[63 ,99],[64 ,109],[65 ,99],[66 ,88],[67 ,101],[68 ,105],[69 ,115],[70 ,97],[71 ,82],[72 ,106],[73 ,96],[74 ,103],[75 ,109],[76 ,93],[77 ,104],[78 ,116],[79 ,91],[80 ,102],[81 ,87],[82 ,91],[83 ,92],[84 ,100],[85 ,95],[86 ,86],[87 ,99],[88 ,88],[89 ,89],[90 ,71],[91 ,100],[92 ,103],[93 ,90],[94 ,75],[95 ,73],[96 ,111],[97 ,75],[98 ,83],[99 ,93],[100 ,87]];
    var rand_draw = [[1 ,109],[2 ,129],[3 ,117],[4 ,168],[5 ,131],[6 ,125],[7 ,132],[8 ,135],[9 ,126],[10 ,129],[11 ,141],[12 ,130],[13 ,130],[14 ,142],[15 ,125],[16 ,115],[17 ,102],[18 ,121],[19 ,115],[20 ,112],[21 ,110],[22 ,117],[23 ,111],[24 ,102],[25 ,106],[26 ,115],[27 ,120],[28 ,107],[29 ,123],[30 ,108],[31 ,109],[32 ,117],[33 ,105],[34 ,88],[35 ,98],[36 ,89],[37 ,113],[38 ,110],[39 ,115],[40 ,99],[41 ,113],[42 ,106],[43 ,122],[44 ,111],[45 ,95],[46 ,93],[47 ,82],[48 ,106],[49 ,133],[50 ,106],[51 ,98],[52 ,122],[53 ,97],[54 ,121],[55 ,106],[56 ,97],[57 ,93],[58 ,92],[59 ,111],[60 ,96],[61 ,89],[62 ,97],[63 ,98],[64 ,99],[65 ,104],[66 ,96],[67 ,96],[68 ,108],[69 ,77],[70 ,95],[71 ,105],[72 ,107],[73 ,87],[74 ,89],[75 ,98],[76 ,108],[77 ,89],[78 ,87],[79 ,96],[80 ,84],[81 ,91],[82 ,94],[83 ,89],[84 ,102],[85 ,99],[86 ,76],[87 ,86],[88 ,92],[89 ,83],[90 ,92],[91 ,83],[92 ,93],[93 ,101],[94 ,103],[95 ,101],[96 ,84],[97 ,90],[98 ,104],[99 ,103],[100 ,99]];

    Flotr.draw(
        document.getElementById(&quot;rand-linear&quot;),
        [
            {data: rand_lose, label: &quot;勝ち&quot;},
            {data: rand_win, label: &quot;負け&quot;},
            {data: rand_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;終盤の手ほど重要視（線形関数）&quot;,
            subtitle: &quot;対乱数プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_dfs_linear(){
    var rand_lose = [];
    var rand_win = [[1 ,586],[2 ,362],[3 ,221],[4 ,136],[5 ,70],[6 ,48],[7 ,54],[8 ,36],[9 ,28],[10 ,20],[11 ,20],[12 ,19],[13 ,20],[14 ,16],[15 ,18],[16 ,14],[17 ,7],[18 ,20],[19 ,15],[20 ,7],[21 ,10],[22 ,9],[23 ,13],[24 ,9],[25 ,11],[26 ,8],[27 ,2],[28 ,6],[29 ,5],[30 ,6],[31 ,6],[32 ,5],[33 ,5],[34 ,7],[35 ,2],[36 ,7],[37 ,8],[38 ,5],[39 ,5],[40 ,7],[41 ,9],[42 ,3],[43 ,3],[44 ,5],[45 ,6],[46 ,4],[47 ,4],[48 ,5],[49 ,3],[50 ,4],[51 ,9],[52 ,5],[53 ,1],[54 ,6],[55 ,9],[56 ,4],[57 ,6],[58 ,7],[59 ,3],[60 ,3],[61 ,2],[62 ,3],[63 ,5],[64, 0],[65 ,2],[66 ,1],[67 ,1],[68,0],[69 ,1],[70 ,4],[71 ,1],[72 ,4],[73 ,4],[74 ,3],[75 ,1],[76 ,2],[77 ,2],[78 ,5],[79 ,2],[80 ,3],[81 ,2],[82 ,1],[83 ,2],[84 ,2],[85 ,3],[86 ,1],[87 ,3],[88 ,2],[89 ,1],[90, 0],[91 ,4],[92 ,2],[93 ,3],[94 ,4],[95, 0],[96 ,2],[97 ,2],[98 ,2],[99 ,1],[100 ,3]];
    var rand_draw = [[1 ,414],[2 ,638],[3 ,779],[4 ,864],[5 ,930],[6 ,952],[7 ,946],[8 ,964],[9 ,972],[10 ,980],[11 ,980],[12 ,981],[13 ,980],[14 ,984],[15 ,982],[16 ,986],[17 ,993],[18 ,980],[19 ,985],[20 ,993],[21 ,990],[22 ,991],[23 ,987],[24 ,991],[25 ,989],[26 ,992],[27 ,998],[28 ,994],[29 ,995],[30 ,994],[31 ,994],[32 ,995],[33 ,995],[34 ,993],[35 ,998],[36 ,993],[37 ,992],[38 ,995],[39 ,995],[40 ,993],[41 ,991],[42 ,997],[43 ,997],[44 ,995],[45 ,994],[46 ,996],[47 ,996],[48 ,995],[49 ,997],[50 ,996],[51 ,991],[52 ,995],[53 ,999],[54 ,994],[55 ,991],[56 ,996],[57 ,994],[58 ,993],[59 ,997],[60 ,997],[61 ,998],[62 ,997],[63 ,995],[64 ,1000],[65 ,998],[66 ,999],[67 ,999],[68 ,1000],[69 ,999],[70 ,996],[71 ,999],[72 ,996],[73 ,996],[74 ,997],[75 ,999],[76 ,998],[77 ,998],[78 ,995],[79 ,998],[80 ,997],[81 ,998],[82 ,999],[83 ,998],[84 ,998],[85 ,997],[86 ,999],[87 ,997],[88 ,998],[89 ,999],[90 ,1000],[91 ,996],[92 ,998],[93 ,997],[94 ,996],[95 ,1000],[96 ,998],[97 ,998],[98 ,998],[99 ,999],[100 ,997]];

    Flotr.draw(
        document.getElementById(&quot;dfs-linear&quot;),
        [
            {data: rand_lose, label: &quot;勝ち&quot;},
            {data: rand_win, label: &quot;負け&quot;},
            {data: rand_draw, label: &quot;引分&quot;}
        ],
        {
            title: &quot;終盤の手ほど重要視（線形関数）&quot;,
            subtitle: &quot;対最強プログラム&quot;,
            HtmlText: false,
            bars:{show: true, stacked: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対戦結果（勝ち／負け／引き分け）&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: true,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

function show_dfs_regression(){
    var equation1 = [[1 ,414],[2 ,638],[3 ,779],[4 ,864],[5 ,930],[6 ,952],[7 ,946],[8 ,964],[9 ,972],[10 ,980],[11 ,980],[12 ,981],[13 ,980],[14 ,984],[15 ,982],[16 ,986],[17 ,993],[18 ,980],[19 ,985],[20 ,993],[21 ,990],[22 ,991],[23 ,987],[24 ,991],[25 ,989],[26 ,992],[27 ,998],[28 ,994],[29 ,995],[30 ,994],[31 ,994],[32 ,995],[33 ,995],[34 ,993],[35 ,998],[36 ,993],[37 ,992],[38 ,995],[39 ,995],[40 ,993],[41 ,991],[42 ,997],[43 ,997],[44 ,995],[45 ,994],[46 ,996],[47 ,996],[48 ,995],[49 ,997],[50 ,996],[51 ,991],[52 ,995],[53 ,999],[54 ,994],[55 ,991],[56 ,996],[57 ,994],[58 ,993],[59 ,997],[60 ,997],[61 ,998],[62 ,997],[63 ,995],[64 ,1000],[65 ,998],[66 ,999],[67 ,999],[68 ,1000],[69 ,999],[70 ,996],[71 ,999],[72 ,996],[73 ,996],[74 ,997],[75 ,999],[76 ,998],[77 ,998],[78 ,995],[79 ,998],[80 ,997],[81 ,998],[82 ,999],[83 ,998],[84 ,998],[85 ,997],[86 ,999],[87 ,997],[88 ,998],[89 ,999],[90 ,1000],[91 ,996],[92 ,998],[93 ,997],[94 ,996],[95 ,1000],[96 ,998],[97 ,998],[98 ,998],[99 ,999],[100 ,997]];
    var equation2 = [[1 ,460],[2 ,688],[3 ,775],[4 ,850],[5 ,897],[6 ,950],[7 ,945],[8 ,962],[9 ,968],[10 ,975],[11 ,981],[12 ,981],[13 ,981],[14 ,986],[15 ,986],[16 ,986],[17 ,991],[18 ,985],[19 ,983],[20 ,985],[21 ,985],[22 ,985],[23 ,986],[24 ,991],[25 ,992],[26 ,990],[27 ,992],[28 ,996],[29 ,989],[30 ,991],[31 ,991],[32 ,989],[33 ,993],[34 ,992],[35 ,992],[36 ,995],[37 ,994],[38 ,991],[39 ,997],[40 ,996],[41 ,994],[42 ,994],[43 ,994],[44 ,996],[45 ,996],[46 ,995],[47 ,996],[48 ,994],[49 ,997],[50 ,996],[51 ,993],[52 ,997],[53 ,994],[54 ,993],[55 ,997],[56 ,996],[57 ,998],[58 ,996],[59 ,994],[60 ,998],[61 ,997],[62 ,997],[63 ,996],[64 ,998],[65 ,997],[66 ,999],[67 ,997],[68 ,997],[69 ,995],[70 ,995],[71 ,997],[72 ,998],[73 ,996],[74 ,996],[75 ,999],[76 ,997],[77 ,996],[78 ,996],[79 ,1000],[80 ,998],[81 ,995],[82 ,998],[83 ,997],[84 ,998],[85 ,997],[86 ,998],[87 ,999],[88 ,998],[89 ,998],[90 ,994],[91 ,999],[92 ,1000],[93 ,997],[94 ,995],[95 ,999],[96 ,997],[97 ,999],[98 ,999],[99 ,997],[100 ,997]];
    var equation3 = [[1 ,458],[2 ,564],[3 ,671],[4 ,768],[5 ,828],[6 ,877],[7 ,921],[8 ,935],[9 ,957],[10 ,961],[11 ,965],[12 ,974],[13 ,977],[14 ,976],[15 ,972],[16 ,979],[17 ,979],[18 ,978],[19 ,980],[20 ,978],[21 ,981],[22 ,983],[23 ,982],[24 ,984],[25 ,986],[26 ,979],[27 ,989],[28 ,992],[29 ,992],[30 ,993],[31 ,990],[32 ,991],[33 ,992],[34 ,992],[35 ,989],[36 ,993],[37 ,985],[38 ,991],[39 ,995],[40 ,992],[41 ,991],[42 ,992],[43 ,993],[44 ,988],[45 ,991],[46 ,988],[47 ,994],[48 ,994],[49 ,996],[50 ,996],[51 ,998],[52 ,996],[53 ,993],[54 ,996],[55 ,994],[56 ,998],[57 ,998],[58 ,996],[59 ,996],[60 ,993],[61 ,997],[62 ,998],[63 ,993],[64 ,992],[65 ,996],[66 ,998],[67 ,997],[68 ,996],[69 ,994],[70 ,998],[71 ,993],[72 ,995],[73 ,992],[74 ,997],[75 ,995],[76 ,996],[77 ,996],[78 ,993],[79 ,994],[80 ,998],[81 ,998],[82 ,998],[83 ,999],[84 ,996],[85 ,998],[86 ,997],[87 ,998],[88 ,998],[89 ,998],[90 ,998],[91 ,994],[92 ,999],[93 ,996],[94 ,997],[95 ,997],[96 ,997],[97 ,993],[98 ,995],[99 ,996],[100 ,998]];
    var equation4 = [[1 ,472],[2 ,571],[3 ,683],[4 ,754],[5 ,843],[6 ,897],[7 ,932],[8 ,943],[9 ,955],[10 ,969],[11 ,971],[12 ,979],[13 ,982],[14 ,983],[15 ,982],[16 ,977],[17 ,982],[18 ,988],[19 ,986],[20 ,990],[21 ,986],[22 ,982],[23 ,990],[24 ,988],[25 ,992],[26 ,993],[27 ,988],[28 ,993],[29 ,986],[30 ,994],[31 ,995],[32 ,992],[33 ,994],[34 ,993],[35 ,996],[36 ,993],[37 ,993],[38 ,988],[39 ,997],[40 ,996],[41 ,997],[42 ,993],[43 ,993],[44 ,996],[45 ,989],[46 ,996],[47 ,994],[48 ,994],[49 ,998],[50 ,995],[51 ,996],[52 ,997],[53 ,996],[54 ,995],[55 ,994],[56 ,999],[57 ,998],[58 ,998],[59 ,996],[60 ,997],[61 ,997],[62 ,995],[63 ,997],[64 ,993],[65 ,994],[66 ,997],[67 ,998],[68 ,997],[69 ,997],[70 ,996],[71 ,996],[72 ,996],[73 ,994],[74 ,995],[75 ,997],[76 ,997],[77 ,995],[78 ,998],[79 ,998],[80 ,997],[81 ,999],[82 ,998],[83 ,1000],[84 ,998],[85 ,998],[86 ,996],[87 ,998],[88 ,999],[89 ,999],[90 ,998],[91 ,999],[92 ,997],[93 ,999],[94 ,997],[95 ,996],[96 ,999],[97 ,999],[98 ,997],[99 ,997],[100 ,998]];

    Flotr.draw(
        document.getElementById(&quot;dfs-regression&quot;),
        [
            {data: equation1, label: &quot;方程式１&quot;},
            {data: equation2, label: &quot;方程式２&quot;},
            {data: equation3, label: &quot;方程式３&quot;},
            {data: equation4, label: &quot;方程式４&quot;}
        ],
        {
            legend: {position: &quot;se&quot;},
            title: &quot;方程式の違いによる学習効率&quot;,
            subtitle: &quot;対最強プログラムにおける引き分け数推移&quot;,
            HtmlText: false,
            lines:{show: true, horizontal:false},
            xaxis:{
                title: &quot;対戦回数（×１０００）&quot;,
                max: 110,
                noTicks: 10
            },
            yaxis:{
                title: &quot;対最強プログラムにおける引き分け数&quot;,
                titleAngle: 90,
                max: 1000,
                noTicks: 10
            },
            grid: {
                verticalLines: false,
                horizontalLines: true,
                outline: &quot;ws&quot;
            },
            mouse: {
                track:true,
                trackDecimals: 0
            }
        }
    );
}

window.onload = function() {
    show_rand_allten_int();
    show_rand_allone_int();
    show_rand_linear();
    show_dfs_allten_int();
    show_dfs_allone_int();
    show_dfs_linear();
    show_dfs_regression();
};

&lt;/script&gt;

&lt;hr /&gt;
</description>
                <link>http://happyclam.github.io/software/2016-01-16/flotr2</link>
                <guid>http://happyclam.github.io/software/2016-01-16/flotr2</guid>
                <pubDate>2016-01-16T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>三目並べプログラムの強化学習効率を上げる</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;気になることがまだ残っている&lt;/h3&gt;
&lt;p&gt;　前回の続きです。手数毎に報酬や罰の値を変更する方法をいろいろ試しましたが、大した成果が上がらなかったので、もとに戻して（全ての局面データに一律に報酬や罰を与える方法、前々回までの状態に戻して）他の切り口から気になっていたことを試してみたいと思います。&lt;br /&gt;
　もしかしたら三目並べに最善の強化方法というものが既に確立されているのかもしれませんが、自分で試してみたいので続けます。  &lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;強い人ほど短手数で勝つはず？&lt;/h3&gt;
&lt;p&gt;　以前から気になっていたのですが、完全読み切りプログラムでは、先手（ X ）の時に以下のような経過を辿って勝つ時があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    初期盤面      １手目      ２手目       ３手目       ４手目       ５手目
    |1|2|3|    |1|2|3|     |1|O|3|     |X|O|3|     |X|O|O|    |X|O|O|
    |4|5|6| -&amp;gt; |4|X|6|  -&amp;gt; |4|X|6|  -&amp;gt; |4|X|6|  -&amp;gt; |4|X|6| -&amp;gt; |4|X|6|
    |7|8|9|    |7|8|9|     |7|8|9|     |7|8|9|     |7|8|9|    |X|8|9|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　４手目で”9”の場所を選べば勝ちなのにそこを選ばずに”7”の場所を選んでダブルリーチをかける時があるのです。完全に読み切っているために”7”の場所も”9”の場所も同じ評価値（どちらを選んでも勝ちであることを読み切っている）なのでこういうことが起きるわけです。事前に勝ちがあるかどうかを判断して、勝ちがある時はその手を優先して選択するように変更するのは容易ですが、機械学習プログラムの場合は先読みするわけでは無いので、こういうケースに対処するために「なるべく短手数で勝負を終える方がいい」と学習させる必要があるのではないかと思ったわけです。機械学習プログラムの場合は先読み関数を使用せず、過去の経験から学習して手を選択するだけなので、勝負が長引けば間違える（悪い手を選択する）可能性も高くなります。短手数で決着したゲームの方が長手数の時より報酬を多めに与えるべきか、本当は手数と強さの相関関係を調べた方がいいのかもしれませんが、実際に試した方が早そうです。将棋などでも必ずしも強い人の総手数が短いとは言えないと思いますが、詰みがある時は逃さないという意味では「強い人は短手数で勝つ」ということが言えるような気もします。&lt;br /&gt;
　ということで、いたずらに勝負を長引かせないために、なるべく短手数で勝った時の方が報酬を多く与えるように学習機能（「強化」の方法）を変更して効果を確認してみました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#変更前
inc = (@sengo == CROSS) ? 3 : -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　↑こんな感じになっていたコードを以下のように変えただけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#変更後
base = SHORTEST / history.size
inc = (@sengo == CROSS) ? (3.0 * base) : (-1.0 * base)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　SHORTEST定数は最短で勝負がついた場合の手数６（初期盤面を含む）です。総手数を分母にしているので、最短手数の６手で勝った時だけ報酬が＋３されますが、手数が伸びるほどそれ未満の報酬しか受け取れなくなります。また、短手数で負けた時ほど罰が厳しくなります。最短手数で負けた場合は辿ったすべての局面データから、選択した場所の小石（score配列）が−１されていきますが、最長手数１０手（初期盤面を含む）で負けた時は0.6 (&lt;script type=&quot;math/tex&quot;&gt;-1\times\frac{6}{10}&lt;/script&gt; ) ずつしか引かれません&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
　これは手数によって（何手目かによって）報酬や罰を変化させるわけではないので、&lt;a href=&quot;/software/2015-12-25/log-linear/&quot;&gt;前回の記事&lt;/a&gt;の方法と似ていますが違います。何手でゲームが終了したかによって y の値が変わる横一直線のグラフになり、前回同様６手で終了した場合を敢えてグラフ化すると、以下のようになります。  &lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/shortest.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/shortest.png&quot; alt=&quot;短手数ほど報酬＆罰を増やす&quot; title=&quot;短手数ほど報酬＆罰を増やす&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　対戦結果は以下です。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;短手数の報酬を多くした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,807敗91,193分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,978勝23,394敗11,628分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　負け数が減って学習効果が上がったようですが、乱数プログラムとの対戦成績は若干勝率が悪くなっています。  &lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;終盤の一手の価値を上げる？&lt;/h3&gt;
&lt;p&gt;　前回の記事で終盤の手ほど重要視して報酬や罰を増やす方法を試しましたが、今回は報酬や罰は変えずに終盤ほど小石（score配列）の総数を減らすという方法を試してみます。&lt;br /&gt;
　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には以下のように書かれています。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;３目並べのケースでは、すぐに負けにつながるミスを効率的に処分し、罰するべきだ。ゲーム終盤の手で使うビーズの総量が少なければ、より短期間で学習されていくはずだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　強化学習の際に初期盤面や一手目の局面は頻繁に現れますが、組み合わせの数が多い中盤・終盤の局面は出現頻度が低いのでなかなか学習が進まないので学習効果を上げるためにその局面に配置されている小石（score配列）の総数を少なくすればいいというわけです。&lt;br /&gt;
　全局面の多分木データを生成する際（Player.bfsメソッド）に小石の初期値を何手目の局面かによって変えるようにしました。初期盤面は１０個、１手目の局面は９個というように手数の深さによって減らしていきます。それと小石が不足した際に補充する時（Player.learningメソッド）も局面の深さによって補充する小石の数を初期化時と同様に変える（減らす）ようにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#Player.bfs
#変更前
          @trees.add(buf, Tree.new(temp, PEBBLES))

#変更後
          @trees.add(buf, Tree.new(temp, PEBBLES - layer + 1))

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#Player.learning
#変更前
    while board
        #石が０個になっていたら置ける箇所全てに追加
        if buf.score[pre_index] &amp;lt;= 0
          buf.score.map!{|v|
            v += PEBBLES if v
          }
        }

#変更後
    pebbles = history.size
    while board
        #石が０個になっていたら置ける箇所全てに追加
        if buf.score[pre_index] &amp;lt;= 0
          buf.score.map!{|v|
            v += pebbles if v
          }
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　報酬や罰に関しては、勝ちは＋３、負けは−１、引き分けは＋１という「従来の強化学習」と全く同じだということです。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;短手数の報酬を多くした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,807敗91,193分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,978勝23,394敗11,628分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;手数によって小石の数を減らした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝7,977敗92,023分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;67,356勝21,444敗11,200分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　&lt;a href=&quot;/software/2015-12-25/log-linear/&quot;&gt;前回の記事&lt;/a&gt;を含めて、今までで一番効果が出ました。どうやら報酬や罰の与え方を変えるより、小石の総数を減らすことの方が効果があるようです。&lt;br /&gt;
　ところで「初期状態や補充分の小石の数を手数によって変化させて、報酬や罰は一定量にする」ことと「初期状態や補充分の小石の数は一定にして、報酬や罰を手数に応じて増減させる」のとどう違うのか、&lt;a href=&quot;/software/2015-12-25/log-linear/&quot;&gt;前回&lt;/a&gt;のようにグラフの傾きで考えてみると、総手数が６手（初期盤面含む）で終了した場合、小石の総数は初期盤面では９箇所×小石１０個、１手目の局面では８箇所×小石９個、２手目の局面では７箇所×小石８個、となるので数の推移は以下の表の y′ のようになり&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167(1/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.111(10/90)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.333(2/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.125(9/72)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.500(3/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.143(8/56)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.667(4/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167(7/42)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.833(5/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.200(6/30)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.000(6/6)&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.25(5/20)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　グラフにすれば以下のようななだらかな曲線になりますが、  &lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/log-linear3.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/log-linear3.png&quot; alt=&quot;曲線回帰、初期値のみ&quot; title=&quot;曲線回帰、初期値のみ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　これには途中の補充分が考慮されていないのであまり意味がありません。一応前回のように回帰方程式を使って対戦させてみましたが全然ダメでした。ゲームが終了する度に評価を実施（Player.learningメソッド）し報酬や罰を加算するわけですが、小石が補充される機会というのは毎回ではありません。でも、補充される度に今までより小石の総数が抑えられるのでかなり影響しているはずでが、計算がややこしそうだったので比較は諦めました。&lt;br /&gt;
　とにかく、前回の記事からいろいろと報酬や罰の与え方（グラフの傾き）を弄っていましたが、大事なのはそんなことではなく、如何にして小石の総数を減らすかだということがわかったということです。&lt;br /&gt;
　確認のため、終盤を重視したり短手数の時に報酬を増やしたり余計なことはせず「従来の強化方法」（手数に関係なく一律に全局面の小石の数を増減させる方法）で、小石の初期値と補充分の定数を１０から１にだけ変更して試したところ、以下の表のように断トツで今までで一番良い結果が出ました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;短手数の報酬を多くした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,807敗91,193分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,978勝23,394敗11,628分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;手数によって小石の数を減らした強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝7,977敗92,023分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;67,356勝21,444敗11,200分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝3,526敗96,474分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;77,058勝12,829敗10,113分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　勝ちは＋３、負けは−１、引き分けは＋１という報酬や罰の与え方（グラフの傾き）を変えることで学習効果に多少の改善があったとしても、そんなものは小石の総数を減らすことに比べたらわずかな効果しかないということでしょう。&lt;br /&gt;
　今から思えば小石が不足した時に補充するやり方に修正した時点（&lt;a href=&quot;/software/2015-11-27/reinforcement/&quot;&gt;前々回の記事&lt;/a&gt;）で、初期値を１０から１にすればよかったです。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;終盤の手ほど重要視する方法は効果がない？&lt;/h3&gt;
&lt;p&gt;　小石の総数を減らすことが強化学習の効果を上げるのに有効なことはわかりましたが、前回の記事で試していた終盤の手ほど重要視する（終盤ほど報酬や罰を増やす）方法が否定されたわけではありません。それを確認するために、小石の初期値や補充分を１０個から１個に修正した上で、尚且つ前回の方程式１（&lt;script type=&quot;math/tex&quot;&gt; y = \frac{1}{総手数} x &lt;/script&gt;）を適用して確認してみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝3,526敗96,474分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;77,058勝12,829敗10,113分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）Part 2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝2,068敗97,932分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;80,512勝11,417敗8,071分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　予想通り対最強プログラムでは負け数が減り、対乱数プログラムでも勝率が上がっていますので、全部は試しませんが前回の記事で使用した他の方程式を適用しても前回同様の傾向が出るのだと思います。&lt;br /&gt;
　次に、今回の記事で最初に試した「短手数のゲームほど報酬や罰を増やす」方法も試してみました。  &lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小石の初期値と補充分を１０から１に修正&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝3,526敗96,474分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;77,058勝12,829敗10,113分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）Part 2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝2,068敗97,932分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;80,512勝11,417敗8,071分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;短手数の報酬を多くした強化学習 Part 2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝2,433敗97,567分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;78,953勝11,249敗9,798分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　やはり、単に小石の総数を減らしただけより、対最強プログラムでは負け数が減り、対乱数プログラムでも勝率が上がっているので、効果が出ています。&lt;br /&gt;
　小石を浮動小数点数で扱うように変更した甲斐がありました&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;人間並みに強くするにはどれぐらい学習が必要か？&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;の仕様に沿いながらこの三目並べ機械学習プログラムを&lt;a href=&quot;/software/2015-10-25/machine_learning/&quot;&gt;初めて作った時点&lt;/a&gt;では、完全読み切りの最強プログラムとの対戦成績は８割の引き分け率でしたが、いろいろ弄って９割７分まで上げることが出来ました。三目並べを人間同士で対戦すればほぼ１００％引き分けになると思いますが、うっかりミスもあるので、９割７分の引き分け率というのはほぼ人間並みになったと言えるのではないでしょうか？&lt;br /&gt;
　でも、三目並べで１０万回も対戦（学習）させてようやく９割７分になる&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;というのは、機械学習プログラムの出来としてどれほどのものなのかわかりません。学習効率を数値化して競う大会なんかがあっても面白いかなと思いました。ただ、麻雀ソフトなんかでもそうですが、三目並べだとズルをすれば簡単に強く出来るのでチェックが大変かもしれません。&lt;br /&gt;
　結局、ソフトウェアとしての出来の良さを競うのであれば、将棋や囲碁のように完全読み切りが不可能なゲーム（ズルが出来ないゲーム）を題材にして、強さを競うという形が分かり易く現実的なのかもしれません。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;前回の記事やこのテストではscore配列は小数に変更したので、小石という表現が当てはまらなくなっています。無理矢理石に例えるなら、小石を砕いて増やしたり減らしたりしているイメージでしょうか？ &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;乱数を使って指し手を選択させる機能（Tree.apply）を浮動小数点数（小数）に対応させるには少し工夫が必要でした。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;１０万回の対戦と言ってもその大部分は学習が進んでいない、初期の９割以上負けていた分の成績を取り戻すために費やされていて、細かく分けて対戦成績を確認すれば、もっと早い段階で９割７分の引き分け率に到達しているはずです。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/software/2016-01-07/correlation</link>
                <guid>http://happyclam.github.io/software/2016-01-07/correlation</guid>
                <pubDate>2016-01-07T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>曲線回帰で強化を試みる</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;闇雲ってこういうことかも&lt;/h3&gt;
&lt;p&gt;　次に記事を書く時は別の話題にしようと思っていたのですが、三目並べの強化学習に関して試さずにはいられなかったので、闇雲と言われようが思いつくままにやってみたことを書いておきます。&lt;br /&gt;
　以前、&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;の中で序盤より終盤の手を重視する方法について記述されていることに触れました、そして今まで試した方法は報酬を与えるにしても罰するにしても選択した全ての局面で同じ値を加算したり減算したりしていましたが、今回は手数毎に違う値を加減算する方法を試してみました。&lt;/p&gt;

&lt;h3 id=&quot;part-1&quot;&gt;終盤の手ほど重要視すべき？Part 1&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には以下のように書かれています。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;　動物が学習する手法をまねたい場合、ゲーム終盤近くの手が、ゲーム序盤よりも重大であるようなシステムに調整してもよい。これは行動が適切な時期に近いほど、その行動を強化する効果が最大になるという観察結果を反映することを意図したものだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　現時点の機械学習プログラムは、勝負がついた時点で局面を初期盤面まで遡りながら局面に配置されている小石（score配列）の数を増減させて学習効果を反映させる仕様です。勝った場合は、一つ手前の局面の９個ある配列データ（score配列）の内、選択した手の場所の値を増やして（報酬を与えて）次からもその局面では再度その手を選ぶ確率を上げるようにするわけです。そしてその前の局面、その前の局面と遡りながら同じように数値を加減算していきます。でも、&lt;a href=&quot;/software/2015-10-25/machine_learning/&quot;&gt;以前の記事&lt;/a&gt;にも書きましたが、辿った全ての局面のデータを一律に同じ数だけ増やして（あるいは減らして）いくというのは確かに少し疑問を感じます。例えば相手の石が揃うのを防がなかったような場合、その手は大悪手であるにも関わらず、序盤の一手と同様の罰しか受けないわけで、感覚的にはそれでいいの？って感じです。だから、ここに書かれているように、報酬も罰も終盤ほど大きな値になるように調整してみました。&lt;br /&gt;
　まず、最終手が１になるように１を手数で割った値を係数にして、勝ちなら３負けなら−１を掛けた値を反映させるようにしてみました。x 手目の局面の報酬を決めるための係数を y で表します。  &lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt; y = \frac{1}{総手数} x \hspace{3.5em}\tag{方程式 1}&lt;/script&gt;  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　最短手数６（初期盤面を含む）で勝負がついたとすると、最終手番の局面は x = 6 で y = 1 となり、勝った場合は&lt;script type=&quot;math/tex&quot;&gt; y\times3=3&lt;/script&gt;、負けた場合は&lt;script type=&quot;math/tex&quot;&gt; y\times-1=-1&lt;/script&gt;の値を各局面のデータ（score配列）に加算します。その一つ前の手番のデータはx = 4, y = &lt;script type=&quot;math/tex&quot;&gt;\frac{4}{6}&lt;/script&gt;となり、勝ちなら&lt;script type=&quot;math/tex&quot;&gt; y \times3=2&lt;/script&gt;、負けなら&lt;script type=&quot;math/tex&quot;&gt; y \times -1=-0.6666&lt;/script&gt;が加算されます。&lt;br /&gt;
　例えば１０手（初期盤面を含む）で学習ソフトが勝ったとすると、最終盤面から初期盤面まで順番にソフトの手番の局面データに &lt;script type=&quot;math/tex&quot;&gt;3, 2.4, 1.8, 1.2, 0.6&lt;/script&gt;の値が加算され、終盤の局面ほど大きな報酬が与えられるわけです。&lt;br /&gt;
　総手数６手で終了した場合の係数（求める値 y は、あくまで３や−１に掛ける係数です）は以下の方程式で表され&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;script type=&quot;math/tex; mode=display&quot;&gt; y = \frac{1}{6}x \hspace{3.5em}\tag{方程式 1.1}&lt;/script&gt;

  &lt;table&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
        &lt;th style=&quot;text-align: right&quot;&gt;y&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.333&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.500&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.667&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;0.833&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
        &lt;td style=&quot;text-align: right&quot;&gt;1.000&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;　グラフにすると下のようになります。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/linear.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/linear.png&quot; alt=&quot;回帰直線&quot; title=&quot;回帰直線&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　この状態での対戦結果は以下のようになりました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,334敗91,666分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;61,383勝26,053敗12,564分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　若干ですが最強プログラムとの対戦成績は向上したようですが、乱数プログラムとの対戦成績（＝学習効果）は悪化しました。&lt;/p&gt;

&lt;h3 id=&quot;part-2&quot;&gt;終盤の手ほど重要視すべき？Part 2&lt;/h3&gt;
&lt;p&gt;　１０万回の対戦の途中経過を観察していないのではっきりとは言えませんが、終盤の手ほど重要視するようにはしてみたけど劇的に学習効果が上がるってわけでもなさそうです。でも、終盤を重要視すると言ってもPart 1 のように等間隔の増分でいいのでしょうか？１手目、２手目、３手目と等間隔で手の重要度が変化するとはとても思えません。相手のラインが揃うのを防がない手を選択して負けるケースなんかを考えると最終手は段違いに重要な気がします。&lt;br /&gt;
　ということで、指数関数的に指し手の重要度が増すと仮定して方程式を改造しました。総手数６手（初期盤面を含む）でゲームが終了したとするとPart 1 の方程式の値は以下のように等間隔で推移（ y の値）しますが、  &lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y (Part1)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.050&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.333&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.500&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.667&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.400&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.833&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.800&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.000&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.050&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　その横に y′ としてこんな感じになるんじゃないかという値を捏造して、その値をLibreOffice（Excelでも可）を使って回帰して得られた方程式が以下のものです&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。  &lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;　&lt;script type=&quot;math/tex&quot;&gt; y = 0.029 \times 1.882^x \hspace{3.5em}\tag{方程式 2}&lt;/script&gt;  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　グラフは以下の青のラインです  &lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/log-linear1.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/log-linear1.png&quot; alt=&quot;曲線回帰、小&quot; title=&quot;曲線回帰、小&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　対戦結果は以下です。  &lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,334敗91,666分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;61,383勝26,053敗12,564分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、小）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,863敗91,137分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;59,992勝25,810敗14,198分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　報酬や罰が等間隔で配分される線形関数の時より、対最強プログラムも対乱数プログラムも勝率が落ちてしまいました。でも最強プログラムとの対戦成績に関しては「従来の強化学習」よりいい成績なので、この時点では一応効果はあると思っていました。&lt;/p&gt;

&lt;h3 id=&quot;part-3&quot;&gt;終盤の手ほど重要視すべき？Part 3&lt;/h3&gt;
&lt;p&gt;　指数曲線にした方が勝率（というか引き分け率）が落ちてしまったのは回帰曲線が線形関数を下回っているのがよくないのかと思って、もう一度値を弄って重みを掛ける係数の値が線形関数の上にくるようにしてみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y (Part1)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′(Part2)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′′&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.050&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.300&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.333&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.100&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.480&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.500&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.200&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.750&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.667&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.400&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.833&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.800&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.920&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.000&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.050&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.030&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;　&lt;script type=&quot;math/tex&quot;&gt; y = 0.188 \times 1.588^x \hspace{3.5em}\tag{方程式 3}&lt;/script&gt;  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　グラフは以下です&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/log-linear2.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/log-linear2.png&quot; alt=&quot;曲線回帰、大&quot; title=&quot;曲線回帰、大&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　対戦結果。  &lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,334敗91,666分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;61,383勝26,053敗12,564分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、小）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,863敗91,137分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;59,992勝25,810敗14,198分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、大）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝11,075敗88,925分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,216勝23,404敗12,380分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　さらに悪化してしまいました(/_;)　でも対乱数プログラムでは改善しています。対乱数プログラムで勝率がアップしたのは係数を大きな値にしたことが素直に反映されたのだと思います。&lt;br /&gt;
　しかし、対最強プログラムの場合では相手は絶対負けないので勝ち点３を得る機会がないので指数関数で係数を大きくしてもあまり恩恵を受けなかったということでしょう。しかも、係数を大きな値にしたために小石（score配列）を補充する際のデフォルト値を１０から２０に増やす必要があったのです（小石の数がマイナスにならないよう）が、それがよくなかったのだと思います。&lt;a href=&quot;/software/2015-10-25/machine_learning/&quot;&gt;以前の記事&lt;/a&gt;にも書いたように小石の総数を増やすと学習効果が上がらなくなるのです。&lt;br /&gt;
　もう一つ問題があります。ここでは総手数が６手で終了する場合のデータをもとに作成した回帰方程式を、全ての対戦に使用しています。本来なら総手数毎に動的に計算（LibreOfficeやExcelのgrowth関数のようなものを自作する必要あり？）しなければいけないところを取り敢えず６手の場合で作った方程式を流用して手抜きしているのでよくありません。いい結果に繋がりそうなら追求してみようかと思ってましたが、やってみる価値は無さそうです。&lt;/p&gt;

&lt;h3 id=&quot;part-4&quot;&gt;終盤の手ほど重要視すべき？Part 4&lt;/h3&gt;
&lt;p&gt;　終盤ほど報酬を多くして報酬の総数はなるべく増やさずに曲線で回帰するにはどうすればいいのか考えた結果、対数グラフにしてみました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/logarithm.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/logarithm.png&quot; alt=&quot;対数方程式&quot; title=&quot;対数方程式&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　「一手の重要度が等間隔で変化するはずがない」から「曲線で推移するはずだ」けど「報酬が増え過ぎると学習効果が薄れる」から「対数関数にしてみよう」という、形から入っただけというかなんとも根拠が薄い感じがしますが、もしかしたらいい結果が出るかもしれないと期待しました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;x&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y (Part1)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′(Part2)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′′(Part3)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;y′′′&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.050&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.300&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.167&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.333&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.100&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.480&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.553&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.500&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.200&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.750&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.780&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.667&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.400&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.200&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.940&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.833&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.800&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.920&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.065&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.000&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.050&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3.030&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.167&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　それに方程式 2 や方程式 3 の指数関数と違ってこの方程式のいいところは、根拠のない数値から回帰したものではないところです。線形関数の方程式 1 と同様に、総手数と何手目かという変数 x だけで値が決まります。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;
  &lt;p&gt;　&lt;script type=&quot;math/tex&quot;&gt; y = \frac{1}{総手数} + \log{x} 総手数 \hspace{3.5em}\tag{方程式 4}&lt;/script&gt;  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　根拠がある、無いの話をしだすと、勝ちの時は３を掛けて引き分けは１を掛けるというのはどういう根拠なの？となりますが、これは&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;に書いていたのと、Jリーグなどの多くのスポーツで勝てば勝ち点３、引き分けで勝ち点１となっているので何か（経験則的な？）根拠があるのだろうと思います。&lt;br /&gt;
　で、対戦結果は以下のようになりました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;従来の強化学習&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（線形関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,334敗91,666分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;61,383勝26,053敗12,564分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、小）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝8,863敗91,137分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;59,992勝25,810敗14,198分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（指数関数、大）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝11,075敗88,925分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;64,216勝23,404敗12,380分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;終盤の手ほど重要視（対数関数）&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝10,799敗89,221分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;66,706勝22,489敗10,805分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　なぜか乱数プログラムに対する勝率はさらに向上しましたが、最強プログラムとの対戦成績は直前の指数関数よりはちょっとましになっただけで、全体として「従来の強化学習」と似たような結果に終わっているので期待はずれでした。この「従来の強化学習」をあらためて説明すると、勝ちは＋３、引き分けは＋１、負けは−１の値を序盤、終盤関係なく全ての辿った局面データに一律に加減算する強化方法です。いろいろ弄ってみて結局「元の木阿弥」という感じですが、最強プログラムとの対戦成績に関しては終盤に重きを置くことの意味はありそうです。でも、なんで報酬を等間隔に配分した線形方程式（直線）の方が良い成績になるのかは未だに疑問です。&lt;br /&gt;
　つづく&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;intercept関数とslope関数を使って x と y の表の範囲を指定すれば係数と切片（定数項）が得られます。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/software/2015-12-25/log-linear</link>
                <guid>http://happyclam.github.io/software/2015-12-25/log-linear</guid>
                <pubDate>2015-12-25T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>強化学習の修正</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;学習型三目並べプログラムの補足&lt;/h3&gt;
&lt;p&gt;　３回に渡って学習機能を持った三目並べプログラムに関する記事を書きましたが、２つの事柄について補足しておこうと思います。一つは&lt;a href=&quot;/software/2015-10-19/multi_branched_tree/&quot;&gt;前々回の記事&lt;/a&gt;で触れた多分木データに格納する局面の数をどれぐらいまで絞れるのかという点と、&lt;a href=&quot;/software/2015-10-25/machine_learning/&quot;&gt;前回の記事&lt;/a&gt;で負けても罰を与えない仕様にしたことについてです。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;287個の根拠は不明&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;マッチ箱２８７個&lt;/strong&gt;&lt;br /&gt;
　各マッチ箱には、小さい引き出しがあり、開けることができる。Michieは、各マッチ箱にラベルを貼った。このラベルには、３目並べで考えられる２８７の異なる盤面が描かれている。実際はもっと多くのパターンがあることになるが、３行×３列構成の標準的な３目並べのレイアウトは上下左右を入れ替えても同じ内容なので、４つの異なるパターンを１つに集約できる。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には上記のように書かれているので多分木データとして保持する必要がある局面の数は回転・対称形をとことん省いていけば6,046から287に絞れるのかと思って縦・横・斜めの対称形とそれぞれの局面を90度ずつ回転させた局面を省いてみても626局面までにしか絞れませんでした。どうすればいいのか見当がつかなかったのでネットで検索してみたところ&lt;a href=&quot;http://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;「数学パズルにトドメをさす？！」&lt;/a&gt;と称するサイトを見つけました。そのサイトからダウンロードできる「三目並べの局面一覧」というファイルを確認してみると、すべての局面の数は447になるとのことです。私が計算した数とどこで食い違うのかを確認してみたのですが、どうやらこのデータはお互いに最善手を打つことを前提にしているようです。このサイトの注意書きに「自分や相手のリーチを見逃さない」と書いてありますが、局面を数えるときに先手・後手のお互いが最善手を選択することを前提にして（おそらく&lt;a href=&quot;/software/2014-09-16/ab_method/&quot;&gt;MIN−MAX法&lt;/a&gt;を使った深さ優先探索を使って）数えているのでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |X|O|3|
 |X|O|6|
 |7|8|9|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　例えば上のような局面は相手のリーチ（あと一手で駒が揃う状態）を防がなかった時にしか発生しません。お互いが最善手を選択することを前提にすると、絶対現れない局面として省いているようです。&lt;br /&gt;
　でも機械学習プログラムの多分木データとして用意する局面データは発生し得るすべての局面を用意しておく必要があります。例えば乱数プログラムと対戦するときなどは、あと一手で一列揃うような時でも見逃すことはよくあるので、そういう時に最善手を打つことを前提にした局面しか用意していないと、まさに打つ手が無くなってしまいます。&lt;br /&gt;
　だから本に書いてある２８７個の局面というのは、おそらく&lt;a href=&quot;http://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;上記サイト&lt;/a&gt;のように局面の先読みすることを考慮すれば２８７個にまで省略出来るということだと思います。&lt;a href=&quot;http://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;上記サイト&lt;/a&gt;では特に局面の数を減らすことを目的にしていないと思いますが、探せば「ここまで局面が進行すれば、相手がどう応じても引き分けに持ち込める」という感じの局面が相当数存在するのだと思います。例えば「自分がダブルリーチをかけたら勝ちが確定する」からそれ以後の局面は用意しなくてもいいというのも一つの例として挙げることができます。そういった手法で先読みを考慮してとことん局面を絞ればまだまだ省略可能な局面が存在するということでしょう。でも、そこまで考慮して事前に用意する局面を絞って学習プログラムを作ると前述したように指し手が選択できないケースが生じてしまいます。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;に例え話で書かれているように、無人島で人間が判断して局面を省略する分には問題ありませんが…。&lt;br /&gt;
　と、いうことで苦労して多分木データに格納する局面数を絞っても学習プログラムには使えないので追求するのはここまでにしました。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;この本&lt;/a&gt;は結構根拠を示さずに結論を書いているところがあるので、２８７という数字が、ちゃんと裏を取った根拠のある数字じゃない可能性もありますが私には何とも言えません。&lt;br /&gt;
　根拠がある数字と言えば、&lt;a href=&quot;/project/2015-10-10/tictactoe_bfs/&quot;&gt;以前の記事&lt;/a&gt;で、３手目までを重みによる評価関数を使いそれ以降はDFSによる読み切り関数を使ったことを書きましたが、３手目までなら重みによる評価関数を使用しても負けないことを確認したからそうしたわけですが、４手目まで重みによる評価関数を使えば負けてしまうことがあるが、３手目までなら負けないようにすることが出来ることを、根拠を示して証明するのは結構大変です。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;件の本&lt;/a&gt;も、いちいち根拠を示していたら紙面が足りなくなるという事情があるのかもしれません。たかが三目並べでも突き詰めていくと奥が深いということでしょう。&lt;br /&gt;
　&lt;a href=&quot;http://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;件のサイト&lt;/a&gt;では「３目並べず&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;」のデータとして最善手を選択することを前提としていないデータも用意してあって、そのファイルでは私が数えた626に近い数になっています（以下に比較表を用意しました）。でも私が数えたときの前提条件は「既に勝負がついた局面は省く」というものなので、微妙に数値が異なっています。私は機械学習プログラムで使用する多分木データに必要なデータということで考えているので、例えば９箇所すべてが埋まっている局面のデータはすでに勝ちか負けか引き分けかの勝負がついた局面なので、必要がないため９手目の局面は０になっています。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;手数 \ 前提条件と局面の数&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　三目並べるために最善を尽くす&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　三目並べたら負け&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;ゲームが終了していない全局面&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;54&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;108&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;108&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;88&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;153&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;153&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;109&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;183&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;183&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;96&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;102&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;95&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;38&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;47&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;34&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;計　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;447&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;661&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;626&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;/pdf/aspects.txt&quot;&gt;三目並べのすべての局面データ（ X が先手、回転・対称形は同一局面と見做して除く）&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;信賞必罰が基本だけど、目的を間違えてはいけない&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2015-10-25/machine_learning/&quot;&gt;前回の記事&lt;/a&gt;で石の数が足りなくなるのを防ぐために負けても罰を与えない（石を減らさない）仕様にしたところで終わりました（勝ちが＋３、引き分けが＋１、負けが±０）が、やはりこれはよくないと思い直しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |X|X|3|
 |4|O|6|
 |7|8|9|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　例えば上記の局面で O の手番だとすると、負けないためには”3”の場所に打つしかありません。この局面のscore配列は以下のように”3”の場所以外は 0 になっている状態が理想です&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
 [nil, nil, 15, 0, nil, 0, 0, 0, 0] 
&lt;/div&gt;

&lt;p&gt;　でも負けても石を減らさない仕様だと、初期値でセットした石は永遠に残り続けるので理想の状態には絶対になりません。長い期間学習が強化され続けて、最善手（相手の石が揃うのを防ぐ手）を選ぶ確率がどんどん高くなっていっても石が残っている限り絶対１００％にはならないわけで、これは良くないと考えたわけです。&lt;br /&gt;
　しかし、よくよく考えてみると「この局面ではこの一手」というような手を指させたいのならその局面のscore配列を最初から上記のようにセットしておけばよい話で、なぜ学習させる必要があるのだろうという話になってきます。多分木データを生成する段階で、「次の一手で相手が石を揃えることが出来る」局面ではその箇所だけ１以上の値をセットしてそれ以外の箇所は０をセットしておけばいい話です。&lt;br /&gt;
　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には以下のように書かれています。  &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;　明確な改善は、間違った手を許さないことで、コンピュータを賢くする。つまり、ココナッツの中に、すぐに負けにつながるような小石を入れないことだ。この方法は、使用開始当初のコンピュータの弱さを改善できるが、実際は動物の学習方法を反映していない。よって、この方法で強い対戦相手が生まれても、教授は、このコンピュータの開発者が科学的な精密さを欠くことに失望するだろう。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　つまり、予め打たせたい手の場所にだけ小石（score配列）をセットしておくことは、いくらプログラムが強くなるとしても「学習プログラム」としての意味がなくなるということだと思います。プログラムを強くしたいだけなら「次の一手で相手の石が揃う」局面の他にも「次の一手で自分がラインを揃えることが出来る」局面ではそこしか選ばないように小石をセットしておけばいいし、先読み機能を付加して「ダブルリーチを狙える局面」では必ずその手を選ぶように小石をセットする方法も考えられます。でもこれらの方法は学習機能が無いプログラムがやっていることと同じで、本末転倒になっています。こういう方法は将棋プログラムで言えば定跡データを登録する作業に似ていると思います。学習しながら定跡データを更新してるからこそ「学習プログラム」と言えるわけで、予め定跡データをセットしておいて変更しないのなら「学習プログラム」とは言えません。&lt;/p&gt;

&lt;p&gt;　ということで、とりあえず負けたら石を一つ減らして、もし減らすべき石が足りなくなったらその都度石を補充する仕様に変更しました。補充するときは足りなくなった箇所の石だけでなく９箇所全てに同数（１０個）ずつ補充します。そうしないと１箇所だけ補充してしまうと勝った時の報酬を受け取った形になってしまうので当然こうすべきところです。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;対戦成績　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝10,572敗89,428分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;66,942勝21,791敗11,267分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面の石の数&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[38, 36072, 11, 118, 10969, 56, 5, 527, 2]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[15050, 661, 4994, 5244, 52116, 2807, 9438, 3320, 15726]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　前回同様に最強プログラムと乱数プログラムとそれぞれ１０万回ずつ対局させた結果も前回の結果よりよくなったのでとりあえずこれで良しとします&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。足りなくなれば小石を補充する仕様なので、結局いつまで経っても最初に言った理想の状態にはならないわけですが、前述の通り「学習プログラム」としてはこれで良しってことです。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　三目並べの「学習プログラム」を強くしようとすればするほど、本末転倒な作業に帰結してしまうのは、ひとえに三目並べというゲームが既に正解がわかってしまっているゲームだからだと思います。一般に機械学習機能を使って学習させたいものは未知のものであるからこそプログラムに学習させて何らかの答えを導き出したいわけで、既に答えがわかっているのならそれを選ばせればいいだけです。だから三目並べの機械学習プログラムの題材としての役割は、かなり限定的だということでしょう。&lt;br /&gt;
　ということで次作るとすれば「オセロ」か「ミニ将棋」辺りを対象にして機械学習プログラムを作ってみようと思います。将棋であれば学習すべき特徴量（「玉の固さ」、「駒の働き」、「駒の損得」等）も多いので三目並べより工夫しがいがありそうですし、三目並べでもまだまだ学習効果を上げる工夫の余地があるのは分かっていますが、完全読み切りが可能なゲームだとやり甲斐もあまりありませんので実験はもう充分って感じです。&lt;br /&gt;
　でも、何かを試すときにその前段階としてまたこの三目並べプログラムを弄ることがあるかもしれません。そうしているうちにこの三目並べプログラムが「三目並べ」の新たな特徴量を発見することは無いと思いますが…。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;「三目並べず」とは一体何のことか分からなかったのですが、&lt;a href=&quot;http://www.gensu.co.jp/saito/puzzle/a15hissho1.html&quot;&gt;このサイト&lt;/a&gt;では、三目並べたら勝ちとなる（従って三目並べるために最善を尽くす）ゲームを「三目並べ」、相手に三目並べさせたら勝ちとなるゲームを「三目並べず」としているようです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/software/2015-10-25/machine_learning/&quot;&gt;前回の記事&lt;/a&gt;で駒が打てない場所は 0 にしていましたが、今回から nil に変更しています。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;/software/2015-10-25/machine_learning/&quot;&gt;前回の記事&lt;/a&gt;の結果と同様に、最強プログラムとの対戦後のscore配列の状態は、初期盤面で真ん中（”5”）より”2”の位置の値が大きくなっていますが、これは対戦に使用した最強プログラムが一切乱数を使用していないため、特徴的な指し手（毎回同じ勝ち手順）を選んでいるのが原因だと思います。完全読み切り必勝プログラムでもいろいろな勝ち手順をランダムに選択するようにすればいいのですがそこまではやってません。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/software/2015-11-27/reinforcement</link>
                <guid>http://happyclam.github.io/software/2015-11-27/reinforcement</guid>
                <pubDate>2015-11-27T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>算数で作る機械学習プログラム</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;新たに必要になった機能&lt;/h3&gt;
&lt;p&gt;　前回の続きです。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;の内容に沿って機械学習機能を付加した三目並べプログラムを作成したのですが、元々あった三目並べ対戦プログラムに対してどんな作業が必要だったのか、新たに付加した機能を列挙してみます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;多分木データ&lt;/strong&gt;（Player.trees）&lt;br /&gt;
　&lt;a href=&quot;/software/2015-10-19/multi_branched_tree/&quot;&gt;前回の記事&lt;/a&gt;で用意した全局面分のデータです。学習データを利用して手を決めることになるので評価関数は不要になりました。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;学習機能&lt;/strong&gt;（Player.learning）&lt;br /&gt;
　勝った時は報酬を与えて（石の数を増やす）負けたら罰を与える（石の数を減らす）ことで学習効果を上げていくわけですが、&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「STATISTICS HACKS」&lt;/a&gt;には勝ちと引き分けに差をつけて、勝ちは＋３、引き分けは＋１がいいと書いてありますのでその通りにしています。そして、そこには負けた場合どうすればいいのか書いてありませんが、負けたら石を海に投げ込むという描写もあるので−１でいいだろうと思い負けは−１にしています。もしかしたら±０でいいのかもしれませんし、逆に負けを−３にする方法もありそうですがこの辺りは評価関数の調整と同じでキリがないのでとりあえずの値です。&lt;br /&gt;
　それと、実際に着手した局面の一手前の石の数（score配列）を操作するということに注意が必要です。&lt;br /&gt;
&lt;img src=&quot;/images/battle_ex1.png&quot; alt=&quot;例１&quot; /&gt;&lt;br /&gt;
　各局面が持っている石の数（score配列）はその局面で打てる場所に存在し次の手を決めるためにあるので、ソフト側が先手（X）で上記のような経過を辿って負けた場合、５手目の局面でOが揃うのを防がなかったのが悪かったということで、一つ前の４手目の局面の石（score配列）を−１します。４手目の局面で先手（X）が”2”（配列の添え字は1）を選ばずに”6”を選んだことが負けの原因なので”6”の位置のscore配列の値を−１します。score配列の初期値は[10,10,10,10,10,10,10,10,10]なので、４手目の局面のscore配列を[10,10,10,10,10,9,10,10,10]にするということです。同様に２手目で”7”を選んだことが悪かった、０手目（初期盤面）で”5”を選んだことが悪かったと評価して２手目のscore配列を[10,10,10,10,10,10,9,10,10]、０手目のscore配列を[10,10,10,10,9,10,10,10,10]にして次回からその局面でその手が選ばれにくくなるようにします。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ファイル入出力機能&lt;/strong&gt;（Player.prepare、Tree::read、Tree::save）&lt;br /&gt;
　&lt;a href=&quot;/software/2015-10-19/multi_branched_tree/&quot;&gt;前回の記事&lt;/a&gt;のスクリプトの例でinitメソッドとしていましたが、他でも使用しているのでprepareメソッドに名前を変えました。起動時にTreeオブジェクトのシリアライズデータ（trees.dump）がカレントディレクトリにあればそれを読み込み、無ければBFS探索で重複局面を省いた三目並べの全局面のツリーデータを生成します。オブジェクト指向言語には必ず用意されているシリアライズ機能はオブジェクトを丸ごと保存できるので便利です。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;指し手選択機能&lt;/strong&gt;（Tree.apply）&lt;br /&gt;
　指定された局面を探し出して、その局面で選択可能な手毎に用意されている石ころの数（score配列の値）によって指し手を選ぶわけですが、いつも一番石ころが多い手を選ぶわけではありません。&lt;br /&gt;
　「その箇所にある石の数（score配列の値）／その局面の石の総数（score配列の合計値）」&lt;br /&gt;
の頻度で指し手が選ばれるようにします。石ころの数が増えればその手が選ばれる頻度が上がる仕掛けです。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;指し手の履歴&lt;/strong&gt;（Game.history）&lt;br /&gt;
　ゲーム終了後に指し手の評価をするために必要になりました。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;直近の指し手&lt;/strong&gt;（Board.move）&lt;br /&gt;
　これもゲーム終了後に指し手の評価をするために必要になりました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;指し手選択機能について&lt;/h3&gt;
&lt;p&gt;　指し手の選択機能は、指し手を無作為に選択するわけですが、石ころの報酬を受け取る（score配列の値が増加）ことによって学習し、徐々に良い手（score配列の数値が大きい手）を選択する確率を上げていくという仕様です。石ころの総数から乱数を生成して、その値から指し手（９箇所のマス目）の配列の添え字をダイレクトに導くデータ構造はどうすればいいのか、そして選んだ添え字の場所が打てる場所なのかどうかも判断しなければなりません。  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def idx(score)
    ret = nil
    index = rand(score.inject{|sum, n| sum + n})
    start = 0
    score.each_with_index{|v, i|
      start += v
      if start &amp;gt; index
        ret = i
        break
      end
    }
    return ret
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　最初は９箇所にそれぞれ石を持っているのだから２次元配列を使うのかとかMatrixを使えば変換できるかとか難しく考えたのですが、一番シンプルな一次元配列のまま、コンストラクタで打てる場所かどうか（打てない場所は０をセットしておく）を判断し、指し手選択時にscore配列分の９回ループするだけで添え字を求められることに気がついてこれはいい！と思いました。９箇所のマス目の内、打てない場所（既に駒がある場所）のscore配列の値を０にしておくことで、インクリメントに影響を与えないのがミソです。だから石の数（score配列）がマイナスになると動きがおかしくなります。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;学習効果&lt;/h3&gt;
&lt;p&gt;　以前RubyとShoesでGUIの将棋ソフトを作った時は&lt;a href=&quot;http://morizyun.github.io/blog/ruby-design-pattern-03-Observer/&quot;&gt;Observerパターン&lt;/a&gt;を使ってソフト同士の対戦を眺めて楽しめるように作った&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;のですが、三目並べは一瞬で勝負がつくし見学しても楽しくないのでCUIでループで回してソフト同士対戦させて学習効果がどの程度出るのか確認してみました。&lt;br /&gt;
　乱数で手を選択する弱いプログラムと、これまでに&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;記事で紹介していたDFS探索アルゴリズム（αβ法）を使った最強プログラム&lt;/a&gt;（絶対負けることがない）との対戦結果です。１００回の対戦を１回として１０回戦までの結果が以下の通りです。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;回 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝91敗 9分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;42勝44敗14分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝88敗12分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;51勝35敗14分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝83敗17分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;41勝42敗17分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝74敗26分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;41勝49敗10分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝62敗38分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;44勝49敗 7分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝60敗40分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;51勝41敗 8分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;36勝53敗11分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;44勝42敗14分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;42勝40敗18分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;48勝43敗 9分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　まず表の右側の乱数プログラムとの対戦結果を見ると、それほど勝率は上がってなさそうですが、上記１０００回の対戦後に初期盤面のscore配列の値を確認すると&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
 [94, 32, 137, 98, 160, 95, 98, 84, 97] 
&lt;/div&gt;

&lt;p&gt;になっていました。９箇所のマス目の真ん中の値が160と最大になっていて、初期盤面で真ん中を選べば有利なことを学習しているように見えます。それでも勝率が伸びていないのは弱い相手と戦ってもあまり学習効果が得られないということでしょうか？&lt;br /&gt;
　それに対して左側の最強プログラムとの対戦ではどんどん負け数が減って強くなっている（三目並べはお互いに最善手を差し続ければ引き分けになるゲームなので、最強プログラムに対して０勝なのは仕方ありません）のがわかります。でも６回戦の途中から出現頻度の高い局面の石の数（score配列の値）が足りなくなっていたようで、動きがおかしくなったので中断しました。&lt;br /&gt;
　石の初期値が１０個で足りなくなるのなら増やせばいいじゃないかという話ですが、石の数を増やすと分母が大きくなるわけですから学習効果が薄くなります。初期値を１０個にしていたからこそ早く学習効果が出たとも言えるわけなので、この辺りはどうするのが一番いいのかわからなかったのですが、これについては後で書きます。&lt;br /&gt;
　ちなみに石の数（score配列）のどれかが０になるのがよくないわけではありません。[0,0,200,0,0,0,0,0,0]のような一箇所に石が集中した状態でも、その局面で唯一絶対の手だと学習したということなので問題ありません。極端な話、一箇所だけに一個しか石がない状態[0,0,1,0,0,0,0,0,0]でもそれが学習した結果であればいいのですが、すべてが0だと手の選びようがなくなるのでよくありません。&lt;br /&gt;
　とりあえずTreeクラスのコンストラクタに石の個数の引数を加えて、出現頻度が高い局面（初期盤面と一手目の局面）だけは石の初期値を５０にして、石が足りなくならないようにして、学習データを削除（trees.dumpファイルを削除）してからあらためて今度は２０００回対戦させてみました。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;回 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝88敗12分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;41勝50敗9分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝86敗14分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;44勝44敗12分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝90敗10分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42勝40敗18分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝83敗17分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;40勝38敗22分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝87敗13分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42勝43敗15分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝89敗11分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;47勝41敗12分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝81敗19分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;47勝46敗7分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝79敗21分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;45勝42敗13分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝88敗17分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;45勝45敗10分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝75敗25分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;45勝44敗11分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１１回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝68敗32分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42勝45敗13分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１２回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝64敗36分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;41勝45敗14分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１３回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝70敗30分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;51勝37敗12分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１４回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝64敗36分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;49勝45敗6分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１５回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝68敗32分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;51勝30敗19分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１６回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝70敗30分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;41勝50敗9分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１７回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝54敗46分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;42勝41敗17分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１８回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝63敗37分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;53勝41敗6分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１９回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝57敗43分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;41勝44敗15分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２０回戦　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0勝55敗45分&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;50勝34敗16分&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　最強プログラムとの対戦ではやはり良好な学習効果が得られているように見えます。&lt;br /&gt;
ちなみにこの２０００回対戦後の初期盤面の石の数（score配列の値）は、乱数プログラムの方は  &lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
[282, 135, 219, 252, 357, 132, 270, 96, 277]  
&lt;/div&gt;
&lt;p&gt;で、やはり真ん中が最大値になっていました。&lt;br /&gt;
　最強プログラムの方は  &lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
[14, 165, 8, 22, 81, 20, 5, 92, 1]  
&lt;/div&gt;
&lt;p&gt;で真ん中は３番目で、なぜか上辺（２の位置）が一番大きな値になっていたのですが、理由はよくわかりません。  &lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;最後に&lt;/h3&gt;
&lt;p&gt;　石が無くならないようにするために、出現頻度の高い初期盤面（１局面）と一手目の局面（９局面）の石の数を５０にしたわけですが、５０という値には根拠がないですし、なんとなくすっきりしないので、負けたら−１という仕様を変更して、&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;本&lt;/a&gt;の主張とは少し違ってきますが、負けても罰しない仕様（勝ちは＋３、引き分けは＋１、負けたら±０）で試してみました。これなら石が無くなる心配もないしマジックナンバーが減ります。初期値は一応１０で試しましたが、石が無くなる心配がないので１以上ならなんでもいいと思います。デスクトップPCで一晩かけて１０万回対戦させてみました（もちろんtrees.dumpファイルを削除してから開始しています）。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;項目 \ 対戦相手&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　最強プログラム　　&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;　乱数プログラム　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;対戦成績　&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0勝18,234敗81,766分&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;58,971勝30,103敗10,926分&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面の石の数&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[537, 27512, 55, 4045, 9444, 297, 50, 3927, 37]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[10779, 2666, 16245, 11403, 22578, 7644, 25519, 6646, 5529]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　最強プログラムとの対戦成績は８割以上引き分けるようになりました。負けを−１しなくても学習効果は今までのプログラムと同様の効果が出ているように見えます。乱数プログラムとの対戦成績も６割近くに伸びているのでもっと回数を増やせばいいのかもしれません。&lt;br /&gt;
　学習機能の説明のところで勝負に負けたからといって一律に全ての局面から減点（石を減らす）していくという仕様に違和感を感じた人もいると思いますが、私も&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;本&lt;/a&gt;に書いていたから最初はそうしてみたけど勝負に負けたからといって初手にどれほどの影響力があるのか疑問です。その意味でも負けた時は±０というのは理にかなっていると思います。但し、直接負けに繋がった一手は罰するべきかもしれません。&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;本&lt;/a&gt;にも序盤より終盤の手を重視する方法が紹介されています。まだまだ学習効果を上げる方法も学習機能の仕様を変える余地も大きく、検証方法もいろいろ考えられるので、また何かアイデアを思いつけばこのプログラムを使って記事を書くかもしれません。&lt;br /&gt;
　今回のソースは別ブランチ（machinelearning）を作りました。以下のコマンドでブランチ指定してソースを取得することが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone -b machinelearning https://github.com/happyclam/tictactoe_ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;本来の使い方とは違うかもしれませんが、一方が一手指したらその通知を受け取ってもう一方が一手指すというような作りにしていました。またもう一箇所、双方が手を指した通知を受け取って棋譜を更新する部分もObserverを使用していました、これは本来の使い方と言えるでしょう。一つのプログラムで２種類のオブザーバーが問題なく動きました。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/software/2015-10-25/machine_learning</link>
                <guid>http://happyclam.github.io/software/2015-10-25/machine_learning</guid>
                <pubDate>2015-10-25T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>対戦型ソフトでの幅優先探索（BFS）の使い途</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;無作為選択を人工知能に&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;「Statistics Hacks」&lt;/a&gt;という本の中でココナッツの殻と石ころを使って、学習機能を持つ三目並べプログラムが作れるという話が書かれていました。無人島に漂流して何もすることがない人の暇つぶしのためにどうぞという感じで、非常に砕けた調子で書かれているのです（この本全体がそんな感じです）が、一応裏を取った根拠のある話が書かれている真面目な本だと思います。そして&lt;a href=&quot;/project/2015-10-10/tictactoe_bfs/&quot;&gt;前回の記事&lt;/a&gt;で書いたようにBFSアルゴリズムの使い途を考えていた私は「これは使える」と思いました。この本で三目並べについてに書かれている部分はほんの数ページだけなのですが、難しい数式を使っていないので、書かれている内容（アイデア）だけでプログラム作成に必要な情報は十分にあると自分には思われました。但し、その結果強いプログラムが完成するかどうかはやってみないとわからないし、強くなるとしてもどの程度強くなるのか興味が湧いてきたので試してみることにしました。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;多分木構造に全局面データを格納&lt;/h3&gt;
&lt;p&gt;　とりあえずBFSで全局面を探索しながら多分木構造のデータを生成し、DBは使わずそのデータをシリアライズして保存（RubyのMarshal.dump）して利用するという方針だけ決めて作業にかかりました。&lt;br /&gt;
　以下のようなTreeクラスを用意して既に使っているBoardオブジェクト（１局面分のデータ）を格納していきます。メンバー変数valueにデータ（今回はBoardオブジェクト）を格納して、分岐する局面をメンバー変数childに格納していきます。メンバー変数scoreというのは手の良し悪しを評価する得点のことで、&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;上記の本&lt;/a&gt;に書いてある石ころの報酬にあたります。それぞれの局面で三目並べの９個のマスに得点（石ころの数）をつけて初期値としてとりあえず１０をセットしています。そして勝ち負けに応じて数（石ころの数）を増やしたり減らしたりして良い手悪い手を学習させるつもりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;class Tree
  attr_reader :value, :child, :score
  def initialize(v, c=[])
    @value = v
    @child = c
    @score = v.clone
    @score.map!{|v|
      unless v
        v = 10
      else
        v = 0
      end
    }
  end

  #一つ目のパラメータで指定された局面データ（親）を探して、その子ノードとしてオブジェクトを追加する
  def add(target, obj)
    ret = nil
    @child.each_with_index { |c, i|
      if c.value == target
        ret = c.child.push(obj)
      else
        ret = c.add(target, obj)
      end
      break if ret
    }
    return ret
  end
  #指定された局面のノードを返す
  def search(v)
    ret = nil
    @child.each { |c|
      if c.value == v
        ret = c.value
      else
        ret = c.search(v)
      end
      break if ret
    }
    return ret
  end
  #動作確認用
  def parent(v)
    ret = nil
    @child.each { |c|
      if c.value == v
        ret = @value
      else
        ret = c.parent(v)
      end
      break if ret
    }
    return ret
  end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　データを作る段階で９箇所のうち駒が打てない場所（すでに駒が存在する場所）のscoreは０をセット（石ころを置かない）しておいて、プラス評価（石ころを増やす）の上限は無いが、マイナス評価（石ころを海に向かって投げる）するときは０未満のマイナス値にはならないように作ります。こうした方が石ころをマイナス個置くなんて現実にはあり得ないということで、本の物語にも沿っていて理解しやすいかもしれません。&lt;br /&gt;
　データを操作するのは常に木構造の根（ルート,root）から再帰関数を呼び出す形になるので特徴的でシンプルなコードになります。今回はscoreという特殊な要素も付加したのでこのTreeクラスは汎用的なものではなくなってますが、使用するメソッドは多分木を使う時は常に似たような感じ（再帰関数ばかり）になるんじゃ無いでしょうか。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;いい加減な数値検証&lt;/h3&gt;
&lt;p&gt;　手始めに&lt;a href=&quot;/project/2015-10-10/tictactoe_bfs/&quot;&gt;前回の記事&lt;/a&gt;で作成したbfsメソッドと上記Treeクラスを使って三目並べの局面がどれほどの数になるのか数えようと思い重複チェック（check_dupメソッド）を外して試してみたところ、いつまで経っても処理が終わりません。  &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;    board = Board.new([nil, nil, nil, nil, nil, nil, nil, nil, nil])
    trees = Tree.new(board)
    while queue != [] do
      buf = queue.shift
      layer = 9 - buf.select{|b| !b}.size
      buf.each_with_index {|b, i|
        next if b
        temp = buf.clone
        temp[i] = buf.teban
#        next if check_dup(temp)
        case layer
        when 0
          trees.child.push(Tree.new(temp))
        else
          trees.add(buf, Tree.new(temp))
        end
        temp.teban = (buf.teban == CROSS) ? NOUGHT : CROSS
        set_dup(temp); queue.push(temp)
      }
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　仕方なくオブジェクトの作成（newするところ）をコメントにしてカウンターだけ回してみたところ局面の数はなんと986,409となりました。なんとなく最大でも9!（=362,880）で収まると思っていたのですが、この986409という数はどうやら&lt;script type=&quot;math/tex&quot;&gt;{}_9 P _1 + {}_9 P _2 + {}_9 P _3 \\ &lt;/script&gt;…&lt;script type=&quot;math/tex&quot;&gt;{}_9 P _9 \\&lt;/script&gt;＝（9 + 72 + 504 + 3024 + 15120 + 60480 + 181440 + 362880 + 362880）ということのようです。三目並べ程度のゲームなら静的な配列でもいいかなと思っていたのですがとんでもなかったです。&lt;br /&gt;
　重複局面を省いて（check_dupメソッドを有効にして）ツリーを生成したところ、局面の総数は初期局面を含めて6,046個になりました。詳細は以下の通りです。  &lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;手数 \ 重複チェック&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　有り　　&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;　無し　　&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;初期盤面&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;１手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;２手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;72&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;３手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;252&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;504&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;４手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;756&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3,024&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;５手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15,120&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;６手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,680&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;60,480&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;７手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,260&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;181,440&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;８手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;630&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;362,880&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;９手目　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;126&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;362,880&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;計　&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6,046&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;986,410&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;それにしても986,410から6,046に減るというのもかなりの差で、かなり歪な形のツリー構造になっている感じです。それと下膨れのピラミッド型にならずに手数が増えると空いているマス目が減って重複局面が増えるので、中膨れ状態になるのもやってみなければわからないなぁって感じでした。&lt;br /&gt;
　世界中で調べ尽くされているであろうゲームなので、いろんなケースの数値を導き出しているサイト&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;と同じ数値が出せれば検証終了ってことにしようと思ったのですが、なかなかピッタリくるサイトがありませんでした。でも上の表の数値と「tictactoe」という単語で検索するとかなりの数のサイトが引っかかるのでおそらく問題ないでしょう^^;&lt;br /&gt;
　それと&lt;a href=&quot;http://www.amazon.co.jp/Statistics-Hacks-―統計の基本と世界を測るテクニック-Bruce-Frey/dp/4873113350/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1444873224&amp;amp;sr=1-1&amp;amp;keywords=statistics+hacks&quot;&gt;上記の本&lt;/a&gt;には２８７個のココナッツを用意すれば足りると書いてあり、上下左右の対称形を省けばゲームの局面の数は６０４６ではなくその数にまで絞れるのかもしれませんが、そこまでやるとプログラムが追いにくくなると思ったのでやってません。但し、その数字を出すためにはどうすればいいのか、どうやればその数字で収まることを検証できるか興味はあるので、気が向けば挑戦するかもしれませんが、とりあえず今はまず学習機能作成を進めていこうと思います。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;局面を遡るメソッド&lt;/h3&gt;
&lt;p&gt;　本来のBFSの使い途というか迷路の解法の際には、出口に到達した時に入り口まで遡る方法を用意しておかなくてはいけないので、この三目並べのツリーでも最終局面から初手まで遡れるように自分の親を辿るparentメソッドを用意しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#verify.rb

require &quot;./constant.rb&quot;
require &quot;./game.rb&quot;
sente_player = Player.new(CROSS, false)
sente_player.init

target = Board.new([-1, 1, 1, -1, -1, -1, 1, nil, 1])
target.display

buf = target
begin
  buf = trees.parent(buf)
  buf.display
end until buf == nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　上のようにサンプル局面を作ってparentメソッドを呼び出すと下の画面のように手の経過を初手まで辿ることができます。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/goback.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/goback.png&quot; alt=&quot;スクリプト実行結果&quot; title=&quot;スクリプト実行結果&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　自分でも作ってから気がついたのですが、迷路の場合なら解答の表示に使えそうなこのメソッドですが、上にも書いてきたように、この多分木データは局面を省略してかなり歪なツリー構造になっているので、parentメソッドを呼び出して自分の局面の一つ前の局面（親データ）に戻ることが出来るといっても、この局面に至った一例を示しているにすぎないということに気をつけなければいけません。三目並べで出現する可能性があるすべての局面データをツリー状態で保持していることは間違いないのですが、その局面に至る手順は本当は幾通りもあるけどデータとして持っているのは一通りだけということです。  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;img src=&quot;/images/terminal_ex1.png&quot; alt=&quot;例１&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;/images/terminal_ex2.png&quot; alt=&quot;例２&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　１も２も右端の局面は同じで重複データなので一つしか持ってません。だから、１の経過を辿ったのか２の経過を辿ったのか多分木データだけでは知りようがないのですが、それは別途実際に打った手を一つの配列で保持することにします。とにかく出来上がった多分木データはこの例のような子ノードを省いた状態の親ノードが非常に多いということです。&lt;br /&gt;
　ということで必要になるだろうと思って用意したメソッドですが、parentメソッドは三目並べ機械学習プログラムでは使う必要がなさそうです。ここでも前回同様に迷路の解法と三目並べプログラム作成の違いが出ました。&lt;br /&gt;
　次の記事で機械学習機能を付けるに当たって新たに必要となった機能について書いていきます。完成したら&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;githubのソース&lt;/a&gt;を更新するつもりです。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.se16.info/hgb/tictactoe.htm&quot;&gt;How many Tic-Tac-Toe (noughts and crosses) games are possible?&lt;/a&gt;、&lt;a href=&quot;https://www.jesperjuul.net/ludologist/255168-ways-of-playing-tic-tac-toe&quot;&gt;The Ludologist&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Tic-tac-toe&quot;&gt;Wikipedia Tic-tac-toe&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/software/2015-10-19/multi_branched_tree</link>
                <guid>http://happyclam.github.io/software/2015-10-19/multi_branched_tree</guid>
                <pubDate>2015-10-19T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>幅優先探索(BFS)で対戦型ソフトを強くできるのか？</title>
                <description>&lt;p&gt;Project: &lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;幅優先探索のメリット&lt;/h3&gt;
&lt;p&gt;　アルゴリズムに関する本なんかを読んでいると、オセロゲーム、三目並べ、将棋などのいわゆる&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E4%BA%8C%E4%BA%BA%E9%9B%B6%E5%92%8C%E6%9C%89%E9%99%90%E7%A2%BA%E5%AE%9A%E5%AE%8C%E5%85%A8%E6%83%85%E5%A0%B1%E3%82%B2%E3%83%BC%E3%83%A0&quot;&gt;二人零和有限確定完全情報ゲーム&lt;/a&gt;のソフトを作る時によく使用される「深さ優先探索（Depth First Search, DFS）」アルゴリズムとの対比で、「幅優先探索（Breadth First Search, BFS）」というアルゴリズムが紹介されていることが多いですが、かなり昔に読んだ本の中で強い対戦型ソフトを作るために幅優先探索（BFS）を使うと以下のようなメリットがあると書いてあった記憶があります。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;思考時間に制限があるような場合は、深さ優先探索（DFS）だと偏った候補手しか読めないので時間に追われて悪手を選ぶことがあるが、幅優先探索（BFS）を使えばいつ読みを中断されてもそれなりに有効な一手を選ぶことが出来る。&lt;/li&gt;
  &lt;li&gt;序盤はBFSを使って広く浅く読み、終盤はDFSを使ってゲームの終局（詰み）まで読み切るように作れば強いソフトが作れる&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　なるほどそういうものかと納得し、今までずっと気にはなっていながらも、試してみる機会がありませんでした。また、自分が見てきた限りでは、書籍で紹介されているオセロや将棋のソフトでは、深さ優先探索（DFS）を紹介しているものばかり（いきなりαβ法とNEGMAX法を用いた最適解を紹介しているものがほとんど）で幅優先探索（BFS）を紹介しているものは見かけなかったので、今回自分で試してみることにしました。オセロや将棋ではなく例によって以前作った三目並べプログラムを題材にして試してみます。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;対戦型ソフトと迷路は違う？&lt;/h3&gt;
&lt;p&gt;　よく「最短経路の発見」、「迷路の解法」などを題材にしてBFSを使った解法とDFSを使った解法２つを比較しながら紹介している本を見かけるので、まずは現在DFSを使って動作している三目並べプログラムをBFSに置き換えただけのものを作ることにしました。一般にDFSとBFSの違いはデータ構造の違い（スタックを使うかキューを使うか）だけだと言われています。再帰関数を使って次々と局面をスタック（stack）に積み上げて先読みしていた部分を、同一局面を間引きながらキュー（queue）に追加＆取得を繰り返すように変更することで実現できると巷の本には書いてあります。そして以下のような感じで、幅優先探索を使って全局面を辿っていく手順は実現出来た（実際に動作確認したい人は&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;github&lt;/a&gt;からソースコードを取得してください）のですが、局面を評価して手を選ぶ処理を書こうと思った時にちょっとおかしいと気がつきました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def bfs(board, turn)
    init_dup
    queue = Array.new
    board.teban = turn
    set_dup(board); queue.push(board)

    locate = nil
    while queue != [] do
      buf = queue.shift
      #キューから一局面を取り出して一手ずつ打つ
      buf.each_with_index {|b, i|
        #既に駒があれば次の場所へ
        next if b
        temp = buf.clone
        temp[i] = buf.teban
        #同一局面があれば次の局面へ
        next if check_dup(temp)
        temp.teban = (buf.teban == CROSS) ? NOUGHT : CROSS
        #DFSならここで評価関数を呼んで手を選択する
        ??????
        set_dup(temp); queue.push(temp)
      }
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　DFSの場合なら、勝ちか負けか引分けかの３値のうちどれかを返す読み切り用の評価関数を呼び出して、先手なら評価値が大きい方後手なら小さい方を選ぶという処理を書くだけで、先手番の局面・後手番の局面と実際に人間がゲームを進める時のように交互に局面を評価しながら辿っていくのに対して、BFSで同じようにコードを書くと、一手目に現われ得る全局面を評価＆比較し、それが終わったら二手目の全局面を評価＆比較するという順序で局面を辿っていくため、お互いに最善手を打つという&lt;a href=&quot;/software/2014-09-16/ab_method/&quot;&gt;MIN-MAX法&lt;/a&gt;のロジックが働いていません。とりあえずBFSで書き換えたものを実際に動かしてみても非常に弱いプログラムになります。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFSの先読み順序&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:600px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/dfs_tree.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/dfs_tree.png&quot; alt=&quot;DFSの先読み順序&quot; title=&quot;DFSの先読み順序&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;BFSの先読み順序&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:600px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/bfs_tree.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/bfs_tree.png&quot; alt=&quot;BFSの先読み順序&quot; title=&quot;BFSの先読み順序&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　なぜBFSだと弱いのか考えてみると、まず一手目、二手目という勝負がつかないところの評価はDFSもBFSも同じですが、勝負がついた時の評価がDFSだと局面を評価した後に一手前に戻った時（スタックからpopupした時）に評価値を比較して相手に有利だった場合にその手を避けることが出来るのに対して、BFSだと勝ちなら勝ち、負けなら負けの評価のまま上書き（比較する時に等号があれば上書き、無ければ無視）し続けることになります。それに一手前に戻って選択した手を変えることがないということは、BFSで勝ちの評価を得た局面に至ったとしても、それは相手が自分にとって有利な手を打ってくれたからこそその局面になった可能性が高いわけです。この点が迷路を解くのと違うところだと思いますが、迷路の場合は普通は正解が一つでその正解手順を発見した時点で先読みを打ち切ればいいわけですが、三目並べ等の対戦ゲームの場合は勝ち局面に至る手順が一通りではなくかなりの数になリ、勝ち局面に至ったといっても相手がお手伝いしてくれている場合が多いのです。将棋で「二人掛かりで玉を詰める」などとヘボ将棋を揶揄することがありますが、まさにそういう状態で勝ち局面を発見して「自分の勝ちだ」と評価して手を選んでいる状態がBFSの手順になります。&lt;br /&gt;
　また、上の図の先読み順序の違いを見れば、時間制限があるような時にBFSだと確かに思考をいきなり中断された時に安定した評価を得られそうですが、その評価が独りよがりの評価になっているのでは意味がありません。仕方がないので、使用する評価関数を勝ち、負け、引分けの３値を返すものから、重み（真ん中が２点、角が１点、辺が０点）による評価関数に変えて序盤（３手目まで）をBFSで読み、３手目以降はDFSで読んで手を決定するようにしました。でもこれは重みによる評価関数を使用すればBFSによる先読みが有効に働くというわけではなく、BFSを使用している限り独りよがりの読みになっている点は同じなのですが、以前&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;記事&lt;/a&gt;に書いたように初手からDFSで読み切ると勝つことを諦めてしまって、勝つ可能性が高くなるにもかかわらず初手に真ん中を選んでくれないので、重みによる評価関数を使って初手に真ん中を選ぶようにしているだけです。でも初手に真ん中を選ぶようにするだけなら評価関数だけを変えればいいことで、先読みアルゴリズムをDFSからBFSに変更する必要はありません。つまり今&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;github&lt;/a&gt;にアップされているソースはせっかく作ったからBFSのロジックを組み込んでいるだけと言えます&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　結局、冒頭に書いた幅優先探索のメリット１も２も一見正しいように思えるけど、BFSだけでこのメリットを実現することは無理そうです。もう昔のことでこのメリットについてどこで読んだのかも覚えていないのですが、まずBFSで局面を絞った後で、その絞った局面から&lt;a href=&quot;/software/2014-09-16/ab_method/&quot;&gt;MIN-MAX法&lt;/a&gt;を使って先読みを続けて手を決めるというような趣旨だったかもしれません。でもまぁ今回実際にプログラムを書くことによって、迷路を解くのとは違う問題があることを知ることが出来ました。&lt;br /&gt;
　ネットで検索してみると幅優先探索を使用していて尚且つ強い（であろう）オセロプログラムについての記述を見つけることができました&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;が、どのように強くしているか詳細はわかりません。でも「定石」と「学習」という単語が出てきているのでBFSで形成したツリー構造に定跡データを格納して利用するということかもしれません。単に定跡データを格納しておくだけなら起動時にデータとして読み込めばよく動的にツリー構造を辿る必要はないので、学習しながら保存するということなのでしょう。確かにそういう使い方なら納得できます。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;もう一つのまとめ&lt;/h3&gt;
&lt;p&gt;　アルゴリズムに関する本には「DFSとBFSは使用するデータ構造が違うだけ」なんて書いてあるからDFSで出来ることは当然BFSでも同様に出来るはずだと私が思い込んでいたせいもありますが、そもそもBFSは探索アルゴリズムなので勝ち局面に至る最短の手順を探索出来ていると考えるべきかもしれないと、ここまで書いてから思い始めました。BFSだと独りよがりの評価しか出来ないなんて言われる筋合いのものではなく、双方が協力した場合の最短の経路（勝ち手順）を探すことが出来ていると考えるべきなのでしょう。確かにBFSだけで対戦ゲームプログラムを強くするのは難しそうですが、逆にDFSアルゴリズムを使ってBFS同様の独りよがりの評価をする弱い状態（「二人掛かりで玉を詰める」状態）に変更するのは簡単です。&lt;br /&gt;
　そう考えると、DFSという単なる探索アルゴリズムを使って人間が考えるような「相手が有利になる手を避ける」、「双方が最善手を打つ」というロジックを簡単に実現出来ることの方が例外的なことなのかもしれません。単なる探索アルゴリズムでしかないはずなのにあたかも人間が思考しているようなプログラムの振る舞いを実現できるからこそ、DFSを使ったプログラムがAI（人工知能）と称される&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;のかもしれません。&lt;br /&gt;
　私は学者じゃないので詳しくはわかりませんが、ちょっと穿った見方をすれば、人工知能という単語を使った方が予算が獲得し易いとか本を売り易いとかいう事情があって、少々大げさなのは承知の上で積極的に「人工知能」という単語が使われてきたのかもしれません。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;実は序盤をBFSで読むように変更することで、JavaScriptのブラウザアプリに置き換えた時にスタックオーバーフローを避けることが出来るという意味があったのですが、最近のブラウザだと三目並べの全局面探索をした程度ではオーバーフローを起こさないようです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://uguisu.skr.jp/othello/5-3.html&quot;&gt;オセロ（リバーシ）の作り方&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;経験上、タイトルに「人工知能」「ＡＩ」という単語が含まれる本の多くが、単にDFSアルゴリズムの説明しかしていないものが多かったです。但し最近は事情が違ってきているようで&lt;a href=&quot;http://www.amazon.co.jp/gp/product/B00UAAK07S?psc=1&amp;amp;redirect=true&amp;amp;ref_=oh_aui_d_detailpage_o02_&quot;&gt;この本&lt;/a&gt;は参考になりました。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/project/2015-10-10/tictactoe_bfs</link>
                <guid>http://happyclam.github.io/project/2015-10-10/tictactoe_bfs</guid>
                <pubDate>2015-10-10T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>WithingsのAPIで遊ぶ</title>
                <description>&lt;p&gt;Project: 「&lt;a href=&quot;http://nocturia.herokuapp.com&quot;&gt;&lt;strong&gt;夜間頻尿診断&lt;/strong&gt;&lt;/a&gt;」: &lt;a href=&quot;https://github.com/happyclam/nocturia&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;何か作ってみたい&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/hardware/2015-08-16/withings/&quot;&gt;前回の記事&lt;/a&gt;の続きでWithingsのAPIを使って何か作るものはないかと無理やり考えてみた結果、&lt;a href=&quot;http://nocturia.herokuapp.com&quot;&gt;夜間頻尿判定サイト&lt;/a&gt;を作ってみました。睡眠中の「目覚め」回数をトイレに起きた回数と考えて、夜間頻尿状態かどうかを判断するサイトです。Withingsのサイトで表示される睡眠トラッキングのグラフには「目覚め」回数は数字で表示されていますが、グラフ化されていないので睡眠トラッキングと同じグラフ上に描画しようという魂胆です。Withingsの週単位のグラフは、縦軸に時間、横軸に曜日（日付）となっていますが、睡眠時間を小数表示にして「目覚め」の回数を同じグラフ上にプロットしています。無理やりなんて書きましたが、Withingsのグラフは週単位でしか表示できなくて、もっと長い期間のグラフをまとめて表示したいという不満があったので、その不満を解消する目的もあります。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Withingsのグラフ&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/withings_screenshot.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/withings_screenshot.png&quot; alt=&quot;Withingsのグラフ&quot; title=&quot;Withingsのグラフ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;今回作成したグラフ&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/nocturia_screenshot.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/nocturia_screenshot.png&quot; alt=&quot;夜間頻尿診断グラフ&quot; title=&quot;夜間頻尿診断グラフ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;開発時に気になったこと&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;アクセストークン／シークレットの保存先&lt;br /&gt;
　昔からbot作ったりしてTwitterでOAuth認証（認証ではない？）やRails2時代にgoogleのOpenIDによる認証を使ったりしたことはありますが、そういう認証方式を取るのは、ユーザー登録という手間を省きたい、ユーザー情報を管理したくない、使いたい人は自己責任で勝手に使ってください、個人情報を入力させたりして余計な責任負いたくないという理由があるわけですが、今回のアプリの場合扱うデータが結構秘匿性が高いというか、人によっては知られたくないデータだと思うのでちょっといろいろ考えさせられました&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。というのも&lt;a href=&quot;/hardware/2015-08-16/withings/&quot;&gt;前回の記事&lt;/a&gt;でoauth_signatureを作成する方法をネットで調べていた際に、一度取得したアクセストークン／シークレットはDBに保存すればいいという書き込みをよく見かけたからです。でも、自社サーバーでコストかけて運用している企業ならいざ知らず、そんなことをして何かの原因で全ユーザーのIDとセットで漏洩したらマズイと思ったので、DBには保存せずセッションに保存することにしました。「クライアントにデータが渡る方が危険」、「盗聴されたら同じ」、「セッションが残ったままになる可能性が有る」とかいろいろ意見はありそうですが、無料枠のherokuで適当に運用する以上DBに保存するよりセッション（cookieに保存）の方が安全だと思いました。WithingsのUserIDはDB内で管理し、クライアントに渡るのはRailsが付加するUserIDとアクセストークン（暗号化済み）という感じで、Withings社のUserIDとアクセストークン／シークレットが別々に格納されているほうが安全でしょう。&lt;br /&gt;
　結局、DBに保存するかセッションに保存するかはサイトのポリシー次第と言えると思いますが、私の場合ソースも公開するから心配ならローカルで動かして使ってくださいっていうポリシーでいきます。&lt;br /&gt;
　と、長々と書きましたが実際には利用する人なんてほとんどいないと思われるので、心配する必要もないのですが苦労性な性格なんです。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ユーザー情報が入っていない&lt;br /&gt;
　Twitterの場合認証を済ませてアクセストークンを取得する時にユーザー名などのユーザー情報（infoデータ）を返してくれます（Facebookもそのようです）が、Withings社のAPIの場合ユーザー情報が何も返ってきません。そのためユーザー認証を済ませた直後にいきなりユーザー情報を取得するためのAPIを発行するという重たい処理をしてWelcome表示しています。&lt;a href=&quot;/hardware/2015-08-16/withings/&quot;&gt;前回の記事&lt;/a&gt;でも愚痴っぽいことを書きましたが、ネットを検索している最中にもWithings社のAPIの仕様に文句を言っている海外の書き込みを見かけました。自社のWebAPIを公開する企業の姿勢というのは開発者としてもユーザーとしても応援したいのですが、そのことで企業のイメージを悪くするのであれば状況が変わってくる可能性もありそうです。日本でも自社サービスのAPIを公開している企業があると思いますが、どうなのでしょう、あまり利用されてないのかもしれませんが。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;withings-activit&quot;&gt;その他、Withings Activitéを使ってみて気づいたこと&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;毎日スマホと同期しないとデータが抜け落ちる&lt;br /&gt;
　時計本体に保存しておけるのは1日分のデータだけのようです。言われてみれば活動量計の針も深夜０時になると０（ゼロ）の位置にリセットされるので当然かもしれませんが、Withingsのグラフでデータが抜けている日を見つけてはじめて気がつきました。CSVファイルでアップロードすることは可能なようですが試していません。&lt;/li&gt;
  &lt;li&gt;睡眠中の一時的な「目覚め」か、もう起きたのか？&lt;br /&gt;
　基本的には「目覚め」回数とは睡眠中に一時的に起きた回数で、本当に起きた回数は数えないようです&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;が、朝起きて布団の中でウダウダしていると「目覚め」回数に数えられるようです。朝起きてすぐに活動を開始した日は「目覚め」回数は０になるようですが、私の場合サイレントアラームで目覚めてももう一つの時計のアラームが鳴るまで起きないためか、夜中にトイレに起きたわけでも無いのにほとんどの日が「目覚め」回数が１回以上になっています。&lt;/li&gt;
  &lt;li&gt;サイレントアラームの止め方&lt;br /&gt;
　ネットの情報によるとWithings Activitéのサイレントアラームは「１２回の振動が終わるまで待たないといけない&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;」とか「There’s no way of stopping the ‘silent alarm’ which is a series of 12 vibrations.&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;」なんて書いてあるのですが、ダブルタップ（アラーム時刻の設定確認をする時と同様のはず）で私は振動を止めることが出来ています。製造時期によるのでしょうか？ネットでそれらしき書き込みを見かけないので私が持っているものが壊れている可能性もありますね^^;でもその止め方のコツはなかなか掴めず、うまくいけば１、２回振動させたところで止められるのですが、未だにポンポン叩いて結局１２回振動させる日があります。確かに時計自身が起こす振動とタップによる振動を区別するのは仕様に無理があるのかも。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.sakimura.org/2011/05/1087/&quot; title=&quot;非技術者のためのOAuth認証(?)とOpenIDの違い入門&quot;&gt;非技術者のためのOAuth認証(?)とOpenIDの違い入門&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;立位・伏臥状態等の姿勢を判定しているのか、仕様がどうなっているのかわかりませんが、技術的には可能なようです→&lt;a href=&quot;http://www.dreamnews.jp/press/0000096134/&quot; title=&quot;睡眠を測る！スリープモニターFS-760販売開始&quot;&gt;睡眠を測る！スリープモニターFS-760販売開始&lt;/a&gt;、&lt;a href=&quot;http://www.kicnet.co.jp/medical/biosignal/posturevisualizer/spec.html&quot; title=&quot;姿勢判定プログラム：PostureVisualizer&quot;&gt;姿勢判定プログラム：PostureVisualizer&lt;/a&gt;、&lt;a href=&quot;http://sakidori.co/article/11599&quot; title=&quot;オムロン？それともタニタ？おすすめの睡眠計7選！リストバンドタイプから目覚まし機能付きまで睡眠計測器特集&quot;&gt;オムロン？それともタニタ？おすすめの睡眠計7選！リストバンドタイプから目覚まし機能付きまで睡眠計測器特集&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.leesfitness.com/jp/withings-activite-pop-review.html&quot; title=&quot;フランスメーカーWithingsのお洒落な活動量Activité Popのレビュー&quot;&gt;フランスメーカーWithingsのお洒落な活動量Activité Popのレビュー&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.pcadvisor.co.uk/review/activity-trackers/withings-activite-watch-review-uk-3596819/&quot; title=&quot;Withings Activité watch review&quot;&gt;Withings Activité watch review&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/project/2015-09-19/activite</link>
                <guid>http://happyclam.github.io/project/2015-09-19/activite</guid>
                <pubDate>2015-09-19T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>Withings Activité購入</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;普通の腕時計を買うつもりが、スマートウォッチになったわけ&lt;/h3&gt;
&lt;p&gt;　もう１０年以上前から腕時計をする習慣が無くなっていたのですが、携帯電話からスマホに変わってからは胸ポケットに入れられないスマホを鞄から取り出すのが面倒なため腕時計をする機会が多くなっていました。でも今はロードバイク用に買ったアウトドア用のソーラー電波時計しか無いので、一つビジネスにも使えるようなものを買ってみようかと思って&lt;a href=&quot;https://www.facebook.com/powerwatch.fan/posts/840855109296593&quot;&gt;「予算１０万円台までで購入できる　最強スポーツウオッチ選手権」&lt;/a&gt;と銘打った時計雑誌を購入しました。&lt;br /&gt;
　雑誌の中ではいろいろ欲しくなる時計は紹介されていたのですが、小さく紹介されていた「Withings Activité」のデザインが気に入ってネットで調べてみるとスマートウォッチというカテゴリーに分類される時計のようです。Apple Watchにもほとんど興味が湧かなかった自分にとっては、すでに世の中にいろいろなスマートウォッチと呼ばれる時計が出回っていることを知って驚きでした。&lt;br /&gt;
　そして、&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;サイレントアラーム（音ではなく振動で目覚まし）を体験したい&lt;/li&gt;
  &lt;li&gt;せっかく身に付けるものが増えるなら万歩計の機能も欲しい&lt;/li&gt;
  &lt;li&gt;ちょうど体重計を買い換えようと思っていたので、&lt;a href=&quot;http://www.amazon.co.jp/【日本正規代理店品】-Withings-ネットワーク対応-Bluetooth-70046001/dp/B00V35HEIC/ref=pd_cp_23_4?ie=UTF8&amp;amp;refRID=1ZPPMCN7P96YPJKSNHAP&quot;&gt;Withing製品&lt;/a&gt;で揃えよう&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　というビジネス時計を買うという当初の目的に無かった余計な欲が出てきて、スマホと連携して遊べそうな「Withings Activité」が欲しくなってきました。昔ロードバイクを初めて購入した時に&lt;a href=&quot;http://www.amazon.co.jp/Holux-M-241-HOLUX-ワイヤレスGPSロガー/dp/B00C85RH8S&quot;&gt;HOLUXのGPSロガー&lt;/a&gt;を購入しロードバイクで彼方此方走った記録を後からニヤニヤしながら地図上で記録をなぞっていくのを楽しんでいた時期がありましたが、それに近いものがあるような気がします。自転車乗るのも好きだけど、後からGPSデータを眺めるのも好き。腕時計も好きだけど、付加された遊び機能も好き、みたいな。それに何と言っても「Withings Activité」のデザインやサファイアガラスを使っている点などは時計としての魅力もたっぷりで、スマートウォッチの機能に飽きたとしても長く使っていけそうだと思ったことが購入を決めた大きな理由です（電池を自分で交換できる点もいい）。&lt;br /&gt;
　ちなみにGPSロガーはすぐに飽きて使わなくなったのですが、初めて買ったロードバイクは今でもお気に入りで乗り続けています。  &lt;/p&gt;

&lt;div style=&quot;width:160px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/activite_setup.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/activite_setup.png&quot; alt=&quot;セットアップ完了&quot; title=&quot;セットアップ完了&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　それにしても購入を決めた当初は、自分のように時計を物色していてこの機種を購入するに至った人は珍しいんじゃないかと思っていたのですが、その後もスマートウォッチの情報をネットで漁っているとApple Watchのような如何にも今までの腕時計とは異質のものではなく、見た目は本格的な腕時計のままスマホとの連携機能を持つスタイルのスマートウォッチのほうが主流になる可能性があることを知りました&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。時計雑誌で紹介されていたスマートウォッチはこの機種だけだったので、浮いている感じを受けましたが、今後は普通の時計雑誌でスマートウォッチが紹介される機会が増えてくるのかもしれません。&lt;br /&gt;
　セットアップは&lt;a href=&quot;http://uxlayman.hatenablog.com/entry/2015/04/28/073100&quot;&gt;こちらのサイト&lt;/a&gt;を参考にしました。&lt;/p&gt;

&lt;div style=&quot;width:160px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/activite_sleeping.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/activite_sleeping.png&quot; alt=&quot;日毎の睡眠パターン&quot; title=&quot;日毎の睡眠パターン&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　上のグラフのように浅い眠りと深い眠りを判別出来るようです。寝起きに「あ〜よく寝た」と感じた時は濃い青のグラフの帯が大きかったので結構正確かもしれません。それと当たり前かもしれませんが朝方トイレに起きた履歴もちゃんと残っていて、いつか自分の記憶にない記録が残っていたりしないかと密かに期待しています（夢遊病か!?）。&lt;/p&gt;

&lt;h3 id=&quot;web-api&quot;&gt;Web APIを使ってみる&lt;/h3&gt;
&lt;p&gt;　APIが公開されていたので少し触ってみました。&lt;a href=&quot;http://blog.hopkins.io/2013/07/25/withings-api/&quot;&gt;Withings API Quickstart Guide&lt;/a&gt;と銘打ったサイトの通りwithings用のgemを使えばすぐに自分が登録したデータを取得することが出来ましたが、最新のAPIに対応しているか分からなかったし使い方もよくわからないし、アクセストークンを取得した後は&lt;a href=&quot;http://oauth.withings.com/api&quot;&gt;WithingsのAPIドキュメント&lt;/a&gt;を見ながら自分でパラメータをセットしていろんなデータの取得を試してみたかったので、特別なgemを使用せずにjsonデータを取得するスクリプトを書いてみました。&lt;br /&gt;
　このスクリプトを実行するにはTwitterアプリを作る時なんかと同様に&lt;a href=&quot;https://oauth.withings.com/en/partner/add&quot;&gt;Withingsにアプリを登録&lt;/a&gt;してAPI Key、API Secretを取得する必要があります。そしてWithings API のページの&lt;a href=&quot;http://oauth.withings.com/api&quot;&gt;FIRST STEP&lt;/a&gt;に従って操作し、OAuth認証完了後userid、oauth_token、oauth_token_secretの値を取得してスクリプトにセットしておく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#sleep.rb
require &#39;pp&#39;
require &#39;openssl&#39;
require &#39;time&#39;
require &#39;json&#39;
require &#39;net/http&#39;
require &#39;cgi&#39;
require &#39;base64&#39;

BASE_URI=&#39;https://wbsapi.withings.net&#39;
WITHINGS_OAUTH_CONSUMER_KEY=&#39;xxxxx&#39;
WITHINGS_OAUTH_CONSUMER_SECRET=&#39;yyyyy&#39;

user_id = 1234567
oauth_token = &quot;aiueo&quot;
oauth_token_secret = &quot;iroha&quot;

params = {:action =&amp;gt; :get, :userid =&amp;gt; 1234567}
#params = {:action =&amp;gt; :getworkouts, :userid =&amp;gt; 1234567}
#params = {:action =&amp;gt; :getsummary, :userid =&amp;gt; 1234567}
#params = {:action =&amp;gt; :getactivity, :userid =&amp;gt; 1234567}
#params = {:action =&amp;gt; :getbyuserid, :userid =&amp;gt; 1234567}

url = BASE_URI + &#39;/v2/sleep&#39;
#url = BASE_URI + &#39;/v2/measure&#39;
#url = BASE_URI + &#39;/user&#39;
#url = BASE_URI + &#39;/v2/user&#39;

params.merge!({
                :oauth_consumer_key =&amp;gt; WITHINGS_OAUTH_CONSUMER_KEY,
                :startdate =&amp;gt; Time.parse(&quot;2015-08-07 12:00:00&quot;).to_i,
                :enddate =&amp;gt; Time.parse(&quot;2015-08-08 12:00:00&quot;).to_i,
#                :startdateymd =&amp;gt; &#39;2015-08-09&#39;,
#                :enddateymd =&amp;gt; &#39;2015-08-09&#39;,
#                :startdateymd =&amp;gt; Time.parse(&quot;2015-08-03 12:00:00&quot;).to_i,
#                :enddateymd =&amp;gt; Time.parse(&quot;2015-08-09 12:00:00&quot;).to_i,
#                :lastupdate =&amp;gt; Time.parse(&quot;2015-08-08 12:00:00&quot;).to_i,
                :oauth_nonce =&amp;gt; rand(10 ** 30).to_s(16),
                :oauth_signature_method =&amp;gt; &#39;HMAC-SHA1&#39;,
                :oauth_timestamp =&amp;gt; Time.now.to_i,
                :oauth_version =&amp;gt; &#39;1.0&#39;,
                :oauth_token =&amp;gt; oauth_token
              })
params = params.to_a.map() do |item|
  [item.first.to_s, CGI.escape(item.last.to_s)]
end.sort
param_string = params.map() {|key, value| &quot;#{key}=#{value}&quot;}.join(&#39;&amp;amp;&#39;)
base_string = [&#39;GET&#39;, CGI.escape(url), CGI.escape(param_string)].join(&#39;&amp;amp;&#39;)
secret = [WITHINGS_OAUTH_CONSUMER_SECRET, oauth_token_secret].join(&#39;&amp;amp;&#39;)
digest = OpenSSL::HMAC.digest(&#39;sha1&#39;, secret, base_string)
signature = Base64.encode64(digest).chomp.gsub( /\n/, &#39;&#39; )
uri_string = url + &#39;?&#39; + param_string + &#39;&amp;amp;oauth_signature=&#39; + CGI.escape(signature)
#p uri_string

Net::HTTP.version_1_2
uri = URI.parse(uri_string)
json = Net::HTTP.get(uri)
result = JSON.parse(json)
pp result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　要するにリクエスト毎に変わるOAuth1.0の署名（oauth_signature）の生成を自動化するためのスクリプトです。&lt;a href=&quot;http://blog.hopkins.io/2013/07/25/withings-api/&quot;&gt;gem のソースコード&lt;/a&gt;と&lt;a href=&quot;http://syncer.jp/how-to-make-signature-of-oauth-1&quot;&gt;このサイト&lt;/a&gt;を参考にしました。RailsでTwitterのAPI使う時はgemが勝手にやってくれるので今までこの作業を自前でやったことはなかったため、サーバーからのエラーが無くなるまで結構手間取りました。サーバーがステータスコード「342 : The signature (using Oauth) is invalid」を返してくるわけですが、必ずしも署名の作成の仕方が悪いわけではないようです&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。サーバー側でもう少しパラメータのチェックを優先して、それに沿ったエラーを返して欲しいところですがどうなのでしょう。  &lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/activite_screenshot.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/activite_screenshot.png&quot; alt=&quot;スクリプト実行結果&quot; title=&quot;スクリプト実行結果&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　とにかくこれで準備はできたので後はアイデアだけ。気が向けばこのWithings APIを使ったアプリを作ってみようと思ってます。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.dream-seed.com/weblog/archives/2015/02/55372/&quot;&gt;複数のスイス時計メーカーがスマートウォッチを発表&lt;/a&gt;、&lt;a href=&quot;http://weekly.ascii.jp/elem/000/000/328/328470/&quot;&gt;腕時計好きもグッとくる絶品スマートウォッチ特選編&lt;/a&gt;、&lt;a href=&quot;http://matome.naver.jp/odai/2142691305853056801&quot;&gt;グッチも！？有名ブランドが続々発売するスマートウォッチ市場が熱い！！&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;例として上記スクリプトのstartdateパラメータをセットしている行で.to_iを削除すると{“status” =&amp;gt; 342}が返ってきます。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/hardware/2015-08-16/withings</link>
                <guid>http://happyclam.github.io/hardware/2015-08-16/withings</guid>
                <pubDate>2015-08-16T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>kobo aura購入</title>
                <description>&lt;h3 id=&quot;kobo&quot;&gt;今更だけどkobo購入&lt;/h3&gt;
&lt;p&gt;　前々から試してみたかった E-Ink端末を買ってみました。Kindleではなく&lt;a href=&quot;http://books.rakuten.co.jp/event/e-book/ereaders/koboaura/&quot;&gt;Kobo&lt;/a&gt;を買ったのは、日用品や書籍の購入は昔からAmazonばかり利用しているので少しAmazonに偏りすぎている気がしていたのと、koboはKindleと違ってSDカードが使えることや個人出版する場合Amazonのkindle direct publishing（KDP）から出版するより&lt;a href=&quot;http://books.rakuten.co.jp/e-book/rakutenkwl/&quot;&gt;koboライティングライフ(KWL)&lt;/a&gt;から出版した方が&lt;a href=&quot;http://internet.watch.impress.co.jp/docs/news/20150430_700205.html&quot;&gt;ロイヤルティが高い&lt;/a&gt;と聞いたので、楽天のことも少しは使って知っておこうと思ったのが動機です。まぁ電子出版に関して今後どうするか決めていませんが、とりあえずkobo auraを使ってみた感想を書いてみたいと思います。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;セットアップ&lt;/h3&gt;
&lt;p&gt;　本体を取り出してWi-Fiでセットアップしようと思いましたが、自宅のフレッツ光のルーターはMACアドレスフィルタリングを設定しているので、まずはkoboのMACアドレスを知りたいのですが取説にシールが貼ってある気配もないし、外箱にもそれらしい値は書いてありません。セットアップの途中でキャンセルして設定を見ることが出来るかもと思いながらメニューを進めたり戻ったりしましたがどうもセットアップを完了するまで何も操作できないようになっているようで、MACアドレスを確認することはできませんでした。仕方がないのでUSBで接続してセットアップを完了させましたが、先々月購入したMacBookは外箱にちゃんとMACアドレスが記載されていたことを思うと、さすがAppleは抜かりないなって感じです。&lt;br /&gt;
　ちなみにUSB接続してセットアップ完了後は、koboの設定メニューからMACアドレスを確認することは出来たので問題なくWi-Fi接続も出来ました。&lt;/p&gt;

&lt;h3 id=&quot;epubkobo&quot;&gt;自分で作成したepubファイルをkoboで読んでみる&lt;/h3&gt;
&lt;p&gt;　DVDや音楽データと違ってAmazonで購入した電子書籍のDRMを解除してkoboで読むことに現時点では法的な問題はないもののAmazonとの契約上は問題があるようです&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;br /&gt;
　ということで、まず自分で作成したepubファイルをkoboにコピーして動作確認してみました。USBで接続したらkoboがストレージとして認識されるので、そこに自作のepubファイルをコピーするだけでkoboで読むことができました。コピー後初めて開いた時は日本語が文字化けしていたのですが&lt;a href=&quot;http://iphone.f-tools.net/Book-Reader/EPUB-MojiBake.html&quot;&gt;このサイト&lt;/a&gt;に書いてある通り「ドキュメントデフォルト」となっているフォントを別のものに指定し直せば問題なく表示されました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;table rules=&quot;groups&quot;&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;a href=&quot;/images/defaultfont_img.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/defaultfont_img.png&quot; alt=&quot;ドキュメントデフォルト&quot; title=&quot;ドキュメントデフォルトの文字化け状態&quot; /&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;&lt;a href=&quot;/images/fixedfont_img.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/fixedfont_img.png&quot; alt=&quot;モリサワゴシック&quot; title=&quot;モリサワゴシックフォント選択後&quot; /&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;　epub上のリンクをクリックするとブラウザが起動してWebサイトも見れるようですし、思ったより動作も速いし、E-Ink端末初体験の自分にとってはこんなものかと納得していましたが、ネットで検索してみると他のE-Ink端末の方がいいという意見もいろいろあるようで、特に文字の表示が薄い&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;という指摘は確かにその通りだと思うし残念です。&lt;br /&gt;
　一つ気になったのが、自作のepub内でWikipediaへのリンクを記述している部分があるのですが、タップすると「指定されたページ名が無効な文字を含んでいます」とエラーページに飛ばされました。PC上でこのepubファイルを開いてクリックすれば正常に表示されるのにkoboで操作するとダメです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/encoding_error.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/encoding_error.png&quot; alt=&quot;Wikipediaのエラーページ&quot; title=&quot;koboで表示されたWikipediaのエラーページ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　メッセージに「無効な文字”%E4”を含んでいます」と書かれています。&lt;br /&gt;
　元のリンクのソースは&lt;code&gt;&amp;lt;a href=&quot;http://ja.wikipedia.org/wiki/二人零和有限確定完全情報ゲーム&quot;&amp;gt;Wikipedia&amp;lt;/a&amp;gt;&lt;/code&gt;なのですが、”%E4”ってのはこれをURLエスケープ（&lt;a href=&quot;http://ja.wikipedia.org/wiki/パーセントエンコーディング&quot;&gt;パーセントエンコーディング&lt;/a&gt;、URLエンコード）した後の日本語部分の最初の文字です。ブラウザを起動する前の、koboでリンクをタップした時に出るダイアログは以下のように既にエスケープされています。  &lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/browser_launch.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/browser_launch.png&quot; alt=&quot;リンクをタップした時のダイアログ&quot; title=&quot;koboでリンクをタップした時のダイアログ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　つまりkoboのepubリーダーでURLエスケープした後、koboのブラウザでもさらに二重にエスケープしてWikipediaにリクエストしたものだから、Wikipediaサーバー側でunescapeしても”%”が入ってきちゃってるよ、オイオイってことです。&lt;br /&gt;
　ちなみに元のURL文字列を手動で二重にエスケープしてPCで試してみたところ、koboと同じ画面をPCでも出すことが出来ました。&lt;br /&gt;
&lt;a href=&quot;http://ja.wikipedia.org/wiki/%25E4%25BA%258C%25E4%25BA%25BA%25E9%259B%25B6%25E5%2592%258C%25E6%259C%2589%25E9%2599%2590%25E7%25A2%25BA%25E5%25AE%259A%25E5%25AE%258C%25E5%2585%25A8%25E6%2583%2585%25E5%25A0%25B1%25E3%2582%25B2%25E3%2583%25BC%25E3%2583%25A0&quot; target=&quot;_blank&quot;&gt;このリンク&lt;/a&gt;です。&lt;br /&gt;
　これって問題になっていないのでしょうか？URLに２バイト文字を使っているところは少ないかもしれませんが、Wikipediaを参照するepub本って結構あると思うのですがそうでも無いのでしょうか？&lt;br /&gt;
　ちなみにもともとエンコードしてaタグに書いていたのものをエラーになったから日本語直書きで試したわけですが、FirefoxでもiBooksでもフリーのandroidアプリ数種類でも、そしてaタグは日本語直書きでもエンコード済みでも正常にリンク出来ました。おまけに楽天koboのandroidアプリでも問題なくリンクが動作しました。koboのepubリーダーソフトの方はブラウザを起動する際に表示するダイアログを見る限り二重にエンコードするわけでは無いようなので、koboのブラウザがエンコード済みかどうかに関わらずURLエンコードしてサーバーにリクエストするようになっているのが問題のようです。&lt;br /&gt;
　う〜む、発売から一年以上経っているのでこのバグが知られていないとは思えないのですが、ネットで検索してもそれらしい書き込みは見当たりませんでした。不具合を指摘しているこちらが不安になるぐらいです。とりあえず自作のepub本以外で日本語URLを参照しているepub本を見つけたらkoboで動作確認をしてみようと思います。たとえ自作epub本じゃなくても、kobo側が対応してくれないとどうしようも無いと思うので、私のepubの作成の仕方が悪いってことでは無いと思いますが、電子書籍の世界は思っていたより奥が深そうなので私が知らない仕掛け（ルール）があるのかも知れません。あっ一応epubcheckでもエラーは出ていません。&lt;br /&gt;
　それとフリーのepubリーダーを何種類か試した時、リーダーソフトによってこれほど本の表示のされ方が違うのかって驚いてその混沌とした世界を垣間見た気がしたので、もしかしたらepubリーダーの世界ではこれぐらいの不具合は小さなことって感じかも知れません。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　購入後ちょっと弄っただけで複数のブログネタを提供してくれるあたりポテンシャルを感じます(^^)ネットでkoboの情報を漁っているとユーザの不満の声をあちこちで見かけるので、Amazonに偏り過ぎているなんて考えずに今後も楽天とは関わらない方が幸せになれるのかもとか考えてしまいました。&lt;br /&gt;
　それと、技術書のリファレンスとしても使おうとか思っていましたが、検索等の操作は遅いし調べ物はやっぱりPCの大画面で参照する方が効率的だし、本のサンプルコードを見ながらプログラミングとかするときもPCの大画面の方が便利で、やっぱり読書専用というかじっくり集中して本を読むための道具かなって感じです。本当は目に優しいE-Ink端末でいろんなことをしたいのですが、動作が遅いので用途が限られます（これでも速くなったそうなので、発売当時に手を出さなくてよかったと思います）。&lt;br /&gt;
　購入前は専門書はkoboのSDにまとめていこうかとか考えていましたが、新書や小説や、専門書でもプログラムコードが載っていない本の読書専用端末になりそうです。というか私が遅れて体験しただけで、世間ではすでにそういう評価になっているのかも知れませんが。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://herooftheday.net/backup-and-epub-converting-on-kindle-for-mac&quot;&gt;「Kindle for Mac日本語版が出たのでePub変換とかバックアップとかイロイロ試してみた」&lt;/a&gt;に詳しく書かれています。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://blog.livedoor.jp/harpsichord1980/archives/51900585.html&quot;&gt;Kobo AuraのWebブラウザを触ってきたよ！&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/hardware/2015-06-12/kobo_aura</link>
                <guid>http://happyclam.github.io/hardware/2015-06-12/kobo_aura</guid>
                <pubDate>2015-06-12T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>markdownファイルを元に電子出版</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;無料で出版してもダウンロードさえして貰えないと聞くけど&lt;/h3&gt;
&lt;p&gt;　最近自分が購入する本に占める電子書籍の割合が高くなってきました。単に購入する電子書籍の数が増えてきているだけでなく、昔は購入する電子書籍といえばマンガや雑誌のようなどうでもいいと思える本が多かったのに、最近は何度も読み返すようなお気に入りの技術系の本の中に電子書籍が混じっています。そして、電子書籍に触れる機会が増えてきたのと出版へのハードルが下がってきたこともあって、電子書籍を作るほう（出版）にも興味が湧いてきました。でも、原稿用紙に鉛筆で文章を書いて出版したいわけじゃなく、今このブログを書いているスタイル（markdownで書く）のまま書いたものを流用したいという拘りがあります。&lt;br /&gt;
　だから、書きたいことはあるけど、わざわざMacのpagesを使ったりWindowsの一太郎を使ったりネット上のサービス&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;を利用してepubファイルを作成して出版したいわけじゃないってことです。こういう方法論に拘るタイプは作家としては大成できないことは分かっていますが、あくまでmarkdownファイルを元にして電子書籍出版するにはどうすればいいのか、最近試行錯誤したことを書いてみたいと思います。&lt;/p&gt;

&lt;h3 id=&quot;markdown&quot;&gt;markdownから電子書籍ファイルに変換する色々な方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;markdown-pdfコマンドで変換しPDF出力&lt;br /&gt;
markdown-pdfコマンドを使用してPDFファイルに変換します。CSSも使えるし改ページ処理も可能です、リンクが有効に出来ないようなので目次が使えません。でも、左サイドにサムネイル表示すれば不要な気もするので、PCで読むことだけを考えるのならこれでいいような気もします。&lt;br /&gt;
例.&lt;br /&gt;
&lt;code&gt;npm install -g markdown-pdf&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;markdown-pdf -f &#39;A4&#39; -s github.css hoge.md -o hoge.pdf&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pandocで変換、PDF出力&lt;br /&gt;
ややこしいLaTeXのclsファイルを弄りながらpandocでPDFを出力してみましたが、文字化けしたりよくわからないトラブルに見舞われましたので自分としてはお勧めしません。&lt;br /&gt;
例1.&lt;br /&gt;
&lt;code&gt;pandoc hoge.md -o hoge.pdf -V documentclass=myltjsarticle --latex-engine=lualatex&lt;/code&gt;&lt;br /&gt;
例2（一度TeXに変換してからPDFに変換）&lt;br /&gt;
&lt;code&gt;pandoc hoge.md -f markdown_github -o hoge.tex&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;pandoc hoge.tex -o hoge.pdf -V documentclass=myltjsarticle --latex-engine=lualatex&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pandocで変換、epub出力&lt;br /&gt;
ほぼ満足のいく出来でしたが強制改ページの方法がわからないのと、epubcheckでエラーが出て原因がわからないので使うのを止めました。&lt;br /&gt;
例1.&lt;br /&gt;
&lt;code&gt;pandoc -t epub3 -o hoge.epub title.txt hoge.md -s --mathjax --epub-cover-image=images/title.png --epub-stylesheet=github.css --epub-metadata=metadata.xml&lt;/code&gt;&lt;br /&gt;
例2.（一度TeXに変換してからPDFに変換）&lt;br /&gt;
&lt;code&gt;pandoc hoge.md -f markdown_github -o hoge.tex&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;pandoc -s hoge.tex -o hoge.epub&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;epubの仕様に沿って定義ファイルを自前で用意してコンパイル（zip化）してepub出力。&lt;br /&gt;
他の変換ツールを使った方法と違って、変換ツールの制限を受けないので調べながらやれば出来上がりに不満が出ることは無いと思うのですが手間がかかります。&lt;br /&gt;
例.&lt;br /&gt;
&lt;code&gt;zip -q0X hoge.zip mimetype&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;zip -qXr9D hoge.zip *&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;cp hoge.zip hoge.epub&lt;/code&gt;&lt;br /&gt;
用意するディレクトリとファイルの例&lt;br /&gt;
&lt;a href=&quot;https://epubcafe.googlecode.com/svn/trunk/tutorial/OEBPS/Text/Chapter020201.xhtml&quot;&gt;参考サイト&lt;/a&gt;  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;Packeage/
├── META-INF
│   └── container.xml
├── mimetype
├── hoge
│   ├── cover.xhtml
│   ├── css
│   │   └── stylesheet.css
│   ├── images
│   │   └── title.png
│   ├── main01.xhtml
│   ├── main02.xhtml
│   ├── main03.xhtml
│   ├── nav.ncx
│   ├── nav.xhtml
│   └── hoge.opf
├── hoge.epub
└── hoge.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pdfepub&quot;&gt;PDFかepubか&lt;/h3&gt;
&lt;p&gt;　出版するための形態をどちらにするか一般的にはepubの方が正式な出版物という扱いだと思いますが、自分としては最初&lt;a href=&quot;https://gumroad.com&quot;&gt;Gumroad&lt;/a&gt;にPDFで公開するのが一番簡単そうだったのでそうしようと思っていたのです。でもpandocを使ってmarkdownからPDFに出力すると色々と不満が出てきたのでepubにも手を出してみたという経緯があります。pandocを使えばPDFにもepubにも出力出来るはずですが、一部の文字が化けたり、細かなトラブルに見舞われたのでPDF出力するならmarkdown-pdfを使った方が良さそうだとか、epub出力するならこのオプションが良さそうだとかいうノウハウが色々試行錯誤しているうちにわかってきました。そして、最終的には1.markdown-pdfを使ってPDF出力する、2.pandocを使ってepub出力する、3.epubの仕様に沿って自前で定義ファイルを書きepubを作成する、の３つの方法に絞りました。以下にそれぞれのメリットデメリットを書きます（不満点に書いている内容は、あくまで自分がうまく出来なかっただけで、よく理解している人がやれば可能なのかもしれません）。  &lt;/p&gt;

&lt;table rules=&quot;groups&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;メリット&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;不満点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;markdown-pdf&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;簡単。PCで読むことだけを考えればこれで十分かも&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・脚注が使えない&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・数式が出せない？&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・リンクが効かない？&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pandoc&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;多くの電子書籍リーダーで利用できるepub形式&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・epubcheck（後述）エラーの検証で手も足も出せなくなる&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;自力epub&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;変換ツールの仕様やバグの制限を受けない&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;・markdownから直接ではなく、一度HTMLに変換する必要がある&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　上記のようなファイル出力が思うように出来るか出来ないかという観点とは別に、PDFならDRMとしての簡易透かし機能が使えるとか、epubだとISBNのような識別IDをどうするのかとか手続き面のメリット・デメリット、epubだと大きな市場に投入出来るけどPDFだと電子書籍市場で不利だとかビジネス面でのメリット・デメリットもあると思います。&lt;/p&gt;

&lt;h3 id=&quot;epubcheck&quot;&gt;epubcheckとは&lt;/h3&gt;
&lt;p&gt;　実はpandocで自分にとってはほぼ満足いくepub形式のファイルに変換できてcalibre等で動作確認も出来たのですが、AppleのiBooksだと&lt;a href=&quot;https://github.com/idpf/epubcheck&quot;&gt;epubcheck&lt;/a&gt;というepub検証ツールを通過しないと出版できないという話を聞いたので試したところ原因不明のエラーが出ました。そしてエラーメッセージだけからでは原因がわからず、いろいろ推測しながら編集してエラーの原因を探ることに疲れたので、一から自前で定義ファイルを書く（自力epub）ことにしたのです。その結果epubcheckでエラーも出ないし自分で満足のいくepubファイルが作れることはわかったのですが、markdownファイルから直接epubファイルに変換しているわけではないので不満もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar ~/Downloads/epubcheck-4.0.0-alpha11/epubcheck.jar ./hoge.epub
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　結局現時点での自分なりの結論はpandocに頼らずepubの仕様に沿って自前で定義ファイルを書いてコンパイルする（自力epub）のが一番良さそうだと思います。でもこの方法はmarkdownファイルから直接変換しているわけではなく、jekyll等でmarkdownからHTMLを生成し、それを定義にあわせて編集しているので一手間かかるのでまだ不満が残ります。ただこのやり方はepubで出力することを考慮しながらmarkdownの書き方を工夫するという余地もあるので、まだまだ試行錯誤が続きそうです。&lt;br /&gt;
　こんなことに時間を費やしているより出版したい文章を仕上げることを優先すべきなのですが、pandocの機能アップに期待しながら出版するのはもう少し先になりそうです。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;markdownに拘らなければAmazonやAppleや楽天ブックス以外にも&lt;a href=&quot;http://bccks.jp&quot;&gt;個人出版を助けるネットサービス&lt;/a&gt;があるようですし、&lt;a href=&quot;http://www7b.biglobe.ne.jp/~yama88/make.html&quot;&gt;変換ツール&lt;/a&gt;も色々あります。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/miscellaneous/2015-06-09/pandoc_epub</link>
                <guid>http://happyclam.github.io/miscellaneous/2015-06-09/pandoc_epub</guid>
                <pubDate>2015-06-09T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>ハイブリッド開発（HTML5 + JavaScript）でハマったこと</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;やはりそんなにうまい話はなかった&lt;/h3&gt;
&lt;p&gt;　ObjectiveC++も使わずJavaのコードも一切書かずにiOSとandroidのアプリが一つのソースコードで作成できるというハイブリッドアプリ開発ですが、&lt;a href=&quot;/programming/2015-04-25/mongo_upsert/&quot;&gt;前回の記事&lt;/a&gt;で書いた通りとりあえず&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;androidアプリ&lt;/a&gt;をリリースしたのはいいけど、いろいろなトラブルに遭遇しました。そこでcordovaを使ったandroidアプリ開発に関してネット上に出回っている一般的なトラブルは除いて、特に自分だけかもしれない嵌り方をした点について書いてみようと思います。  &lt;/p&gt;

&lt;p&gt;　開発環境：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jquery-1.11.2&lt;/li&gt;
  &lt;li&gt;jquery.mobile-1.4.5&lt;/li&gt;
  &lt;li&gt;cordova 5.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;android23ginger-breadclick&quot;&gt;android2.3(ginger bread)でclickイベントが発火しない&lt;/h3&gt;
&lt;p&gt;　これは定番のトラブルであんただけではなくネット上によく出回ってる話じゃないかと思われた方も多いと思います、そしてclickイベントは使わないってのが基本だと仰る方も多いでしょうが、clickイベントに関するネット上で見かけるトラブルはその動作が重いから避けろというものだと思います。私は先人の教えの通りfastclick.jsを最初から使用していたので特に重いと感じることもなく普通に動いているから問題無いと思っていたのですが、エミュレータも含めてandroid4.1だと問題なくclickイベントが発生するけど、android2.3（おそらくそれ以前も）だとclickイベントが発生しないというトラブルに出くわしました。&lt;br /&gt;
　&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;私のアプリ&lt;/a&gt;はダイアログを表示する箇所が２箇所あるのですが、cordovaのプラグインを使っている方は問題ないのですが、もう一方の自前のwindow（SinglePageApplicationなのでdata-role=”page”を付加したページ）を呼ぶ出す部分のclickイベントが発火しないという現象でした。エミュレータ上でマウスでクリックしようが、実機にインストールして指でタップしようがうんともすんともいいません。なんでこんなことが起こるのか分からなかったのですが、JQueryMobile(JQM)を使用しているのが原因（jQueryは問題ない）のようで、試しにJQMの読み込みをコメントにするとレイアウトは崩れますが正常に動きました。でも、JQMを使わずにレイアウトを定義し直すのは面倒だし、JQMの中まで追って行って原因を追究するのも大変そうなのでネットで検索しながらいろいろ試してみた（vclickイベント、touchイベント等に置き換える）のですが効果はなく、tappable.jsというものを見つけてそれを使ってclickイベントをtappable.jsで置き換えてみてエミュレータで動いた時は喜んだのですが、エミュレータと同じandroid-10（ginger bread）の実機（IS05）で試すと相変わらずイベントが発生しないというおかしな状況になりました。どうも複数の原因が関わっているようでエミュレータで動いたのは偶々だったようです。イベントの発生順序にも関係してそうだったのでclickイベント（というかtapイベント）のcallback設定をいろんな場所（deviceready, DOMContentLoaded, load, pageinit, $document.ready）に書いて確認したのですが動いたり動かなかったりという泥沼に陥りました。しつこいようですがandroid2.3の場合だけです。&lt;br /&gt;
　いくつか&lt;a href=&quot;https://forum.jquery.com/topic/javascript-function-not-called-on-button-click-event-android-app-using-jquery-mobile&quot;&gt;ヒントになるサイト&lt;/a&gt;はあったのですがJQMがやっている処理をandroidのバージョンによって切り分ける作業が必要そうで、それは大変なので結局ダイアログの表示内容を簡素化してpluginのダイアログ（navigator.notification）を使うことで回避しました。&lt;br /&gt;
　ネットや本ではjQueryMobileは重いのでzepto.jsを使いましょう、という助言はよく見かけていたのですが、PCサイトから作り始めた私は特に問題なく動いているしパフォーマンスを気にするようなものでもなく試しに作ってみたようなシンプルなテーブルゲームアプリなのでそのままJQMを使っていたのですが、古いandroid機でも動作させるつもりなら今でもzeptoを使ったほうがいいのかもしれません。私の場合はginger breadのシェアも落ちてきているのでJQMのままで良しとしました。&lt;/p&gt;

&lt;h3 id=&quot;android41jellybeanadmob&quot;&gt;android4.1(JellyBean)でadmobを使うと広告表示のタイミングで落ちる&lt;/h3&gt;
&lt;p&gt;　エミュレータを作成して試している限りでは正常に広告が表示されるのですが、実機で試すと広告が表示されるタイミングでアプリが落ちるという現象に悩まされました。android4.1.xだけで発生するバグのよう（私の持っている実機が4.1.2です!?）で、onAdFailedToLoadイベント等でも拾うことも出来ずにいきなりアプリ毎終了します。&lt;a href=&quot;https://github.com/floatinghotpot/cordova-plugin-admob/issues/92&quot;&gt;admobのオプションでoverlap:trueにするとこのバグを回避できる&lt;/a&gt;ようなのでとりあえずそうしましたが時間を取られました。リンク先にも書かれているようにandroidのバージョンによって処理を分けるのが良さそうです。&lt;/p&gt;

&lt;h3 id=&quot;android23ginger-breadjsonp&quot;&gt;android2.3(ginger bread)だとJSONPでデータが取得できない？？？&lt;/h3&gt;
&lt;p&gt;　これもまた古いandroidの場合だけでしたが、ランキング表示ダイアログを別のhtmlファイルで作成していたものをSPA(SinglePageApplication)にするために、同じhtmlファイル内にJQMのページ（data-role=”page”）に変更したら、ダイアログ表示時にサーバーにアクセスに行かないようになってしまいました。別ファイルを読み込んだ時にscriptタグ内のJavaScriptでサーバーからデータを取得するようにしていた処理を、JQMの場合はpageinitかpageshowイベントでやるように変更しなければいけないのかと思ってpageshowイベント内に書いてみてもpageshowイベントが発生しません。android4.1の場合は何も書き換えなくてもデータ取得できるにも拘らずです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;        function cb(u){
            //省略
        }
        function ranking_regist(username){
            location.href = &quot;#win_show_ranking&quot;;

            //以下JSONPデータ取得処理
            var s = document.createElement(&#39;script&#39;);
            s.src = URL;  // http://hogehoge?callback=cb&amp;amp;…省略
            document.getElementsByTagName(&quot;head&quot;)[0].appendChild(s);
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　
　上記コードで&lt;code&gt;location.href = &quot;#win_show_ranking&quot;&lt;/code&gt;とやっているところは非同期で実行され、ページ遷移の完了を待たずにその後のコードが実行されるわけですが、その後のコードが実行される間にページ遷移の処理が何処かでキャンセルされてしまってページが表示されずサーバーへのアクセス自体も発生しなくなりました。JSONPレスポンスを受け取るのにandroidのバージョンが関係あるわけないと思いながらも、古いandroidだと何か理由があるのか？と思い、データ取得の部分をajaxに書き換えてpageshowイベントに書いて試したりしましたが、android2.3では相変わらず動きませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;            $.ajax({
                type: &#39;GET&#39;,
                url: URL,
                dataType: &quot;jsonp&quot;,
                jsonpCallback: &quot;callback&quot;,
                async : true,
                success: function(u) {
                    cb(u);
                }
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　android4.1では動くというのが混乱の元のような気がしますが、問題は&lt;code&gt;location.href = &quot;#win_show_ranking&quot;&lt;/code&gt;の部分でした。&lt;a href=&quot;http://www.buildinsider.net/web/jquerymobileref/34&quot;&gt;このサイト&lt;/a&gt;に書いてあるようにjavascriptを使って画面遷移するのではなく、JQMのchangeメソッドを使って画面遷移しなければいけないようです。&lt;code&gt;location.href = &quot;#win_show_ranking&quot;&lt;/code&gt;と書いている部分を&lt;code&gt;pagecontainer(&#39;change&#39;, &#39;#win_show_ranking&#39;, {allowSamePageTransition: false});&lt;/code&gt;と書き換えれば問題なく動作しました。&lt;br /&gt;
　逆に何で新しいandroidだと動くのかについてはよくわかりませんが、JQMはajaxを無効にして使うことも出来るようなので、古いandroidについては面倒を見るのを止めてサポートを切り捨てたけど、新し目のバージョンに関してはどちらでも動くようになっているということでしょうか？それとも偶々動いただけかもしれません。&lt;br /&gt;
　JQMのことをよく調べずに使い始めたのがよくなかったみたいです。それに現在はJQMを使っているといってもほとんど画面レイアウトにしか使っていない状態なのでJQMの機能をもう少し取り込んで行こうと思っているのですが、そうするとまた新たな問題が出て来るのでしょう。&lt;/p&gt;

&lt;hr /&gt;

</description>
                <link>http://happyclam.github.io/programming/2015-05-29/android_app1</link>
                <guid>http://happyclam.github.io/programming/2015-05-29/android_app1</guid>
                <pubDate>2015-05-29T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>HerokuでNodeとMongoDBを使う</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;スマホアプリからサーバに接続してデータ取得&lt;/h3&gt;
&lt;p&gt;　以前から記事に書いている三目並べプログラムをとりあえず&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.herokuapp.tictactoe_cf&quot;&gt;androidアプリ&lt;/a&gt;にしてみたのですが、単なる三目並べだとつまらないので一手の時間制限を設けて連続無敗記録を保存するように変更しました。そして今度はその記録をユーザ間で競ってもらおうと思い、サーバーを用意してスマホ上でランキング表示する機能をつけることにしました。&lt;br /&gt;
　ユーザ認証などの機能をつけると利用者側にとって敷居が高くなるので、適当なハンドルネームを登録してランキング表示するだけの機能です。単純な機能（スマホからハンドルネームを登録し、JSONPでランキングデータを取得する）なのでどうせなら今までやったことない方法でと思いNode.jsとMongoDBを使うことにしました。いろいろ印象に残ったことを書いてみます。&lt;/p&gt;

&lt;h3 id=&quot;upsert&quot;&gt;今までにもあっても良さそうなのに無かったupsert&lt;/h3&gt;
&lt;p&gt;　いや、昔からどこかで使われていた機能かもしれませんが私は知りませんでした。InsertとUpdateを合わせてUpsert。document（recordとは言わないらしい）が存在していれば更新し、なければ新規登録する機能です。私の経験ではOracleにもSybaseにもSQL Serverにもなかったはずです。さすがNoSQLです。&lt;br /&gt;
　で、使ってみると新規にInsertした場合のid値をどうやって取得するのか悩みましたが、先にid値を生成してからUpsertを呼び出すようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      //uidで検索する例
      //新規とわかっている場合はuidにnullを入れてid生成
      var doc = {uid:null, name:username, score:unbeaten, date: null};
      var collection = db.collection(&quot;tictactoe&quot;);
      temp_id = new ObjectID(uid);
      collection.update({_id: temp_id}, {name:username, score:unbeaten, date: new Date()}, {upsert:true, w: 1}, function(err, result) {
        if (err) { throw err; }
        collection.findOne({_id: temp_id}, function(err, item) {
          if (err) { throw err; }
          if (item) {
            doc._id = item._id;
            doc.date = item.date;
          }
        });
      });
         
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;出来るだけ新しいバージョンで開発環境を作る&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://www.oreilly.co.jp/books/9784873116068/&quot;&gt;Nodeクックブック&lt;/a&gt;という本を参考にしていたのですが、ネット上に転がっていた古いコードから書き始めたのが間違いの元で、本のサンプルコードが動かない環境で一通り作った後に何度も同じ箇所を書き換えなければいけない羽目に陥りました。古いバージョンのままでも動けばいいのですが、何かトラブルに見舞われた時に「もしかしてバージョンが古いせいか？新しくしてみよう」となって直接トラブルとは関係ないのに書き直す羽目に陥ったということです。皆さんも気をつけて下さい。特にExpressはバージョンによって書式（構文）の変化が激しくて、バージョンが変わるともうそれは必要がなくなったというコードが多かったです。依存関係で深刻なものは無かったのですが、自分が使っているパッケージのバージョンは把握しておいた方が右往左往しなくて済みそうです。以下が現時点で使っているパッケージ（package.json）ファイルの一部です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  , &quot;dependencies&quot;: {
      &quot;express&quot;: &quot;4.12.1&quot;
    , &quot;jade&quot;: &quot;&amp;gt;= 0.0.1&quot;
    , &quot;mongodb&quot;: &quot;2.0.27&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;0.10.20&quot;,
    &quot;npm&quot;: &quot;2.8.3&quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　Expressで悩まされた一例として、本に記載されている通り以下のようにlessファイルを指定したのですが&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//app.js
app.use(require(&#39;less-middleware&#39;)({
   src: __dirname + &#39;/views&#39;,
   dest: __dirname + &#39;/public&#39;,
   compress: true
}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　上手くいかなくて、&lt;a href=&quot;http://stackoverflow.com/questions/22274832/public-static-directory-typeerror-arguments-to-path-join-must-be-strings&quot;&gt;ここ&lt;/a&gt;に書いてある通り以下のように修正すれば動きました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//app.js
app.use(require(&#39;less-middleware&#39;)(__dirname + &#39;/public&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　src:とdest:を分けて指定するのではなく、一つ（/public）だけ指定すればそこにあるlessファイルを読み込んで同じディレクトリにcssファイルを出力するという形で上手く機能しています。よく調べればオプションがあるのかも知れません。&lt;br /&gt;
　あと、Rubyのrvm環境同様にNodeも最初からnvmを使って複数のバージョンを切り替えられるようにしておいたほうがよさそうです。&lt;/p&gt;

&lt;h3 id=&quot;heroku&quot;&gt;ローカルで動くのにHeroku上で動かない&lt;/h3&gt;
&lt;p&gt;　herokuで動かないのはMongoDBへの接続が出来ていないようだということはすぐわかったのですが、&lt;a href=&quot;http://d.hatena.ne.jp/koda_hd28v/20120512/1336799056&quot;&gt;この記事&lt;/a&gt;を見つけるまで理由がわかりませんでした。ローカルではDBオブジェクトをnewしてServer.open、herokuではconnectを使うということのようです。ローカル環境にデータベースが存在しているわけじゃないんだからopen出来ると考える方がおかしいと言われそうですが、herokuもMongoDBもどこまで私の面倒を見てくれるのかわからないんだから、ローカルで動くんだからそのまま動くと考えてしまっても仕方がないと思います。&lt;br /&gt;
　で、記事の中で説明してくれているように、以下のようにDB接続モジュールだけ分割して&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// lib/MongoBuilder.js
var mongo = require(&#39;mongodb&#39;);

module.exports.ready = function(db_name, callback){
  if ( process.env.MONGOLAB_URI ){
    mongo.connect(process.env.MONGOLAB_URI, {}, function(err, db){
      callback(db);
    });
  }else{
    new mongo.Db(&#39;tictactoe&#39;, new mongo.Server(&#39;localhost&#39;, 27017), {safe: false}).open(function(err,db){
      callback(db);
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　以下のように使用すれば、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// routes/index.js
var MB = require(&quot;../lib/MongoBuilder&quot;);
var users = new Array();
exports.mypage = function(req, res){
  MB.ready(&#39;tictactoe&#39;, function(db){
    var collection = db.collection(&quot;tictactoe&quot;);
    collection.find().sort({score: -1}).limit(100).toArray(function(err, users){
      res.render(&#39;index&#39;, {title: &#39;Tictactoe Unbeaten&#39;, users: users});
    });
  });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　ローカル環境でもheroku環境でも動くように出来ました。&lt;/p&gt;

&lt;hr /&gt;
</description>
                <link>http://happyclam.github.io/programming/2015-04-25/mongo_upsert</link>
                <guid>http://happyclam.github.io/programming/2015-04-25/mongo_upsert</guid>
                <pubDate>2015-04-25T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>新Macbook購入</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;発売日翌日にゲット&lt;/h3&gt;
&lt;p&gt;　発売日（４月１０日）にはアップルストアでも入手できた人はいなかったようなので、ダメモトで梅田のヨドバシに朝一番で行ってみると幸運なことに買うことができました。開店早々Appleのブースに行くと男ばかり１４、５人がたむろしていて３台の展示機に何人か並んでいました。自分は既に買うことは決めていたので試用する気もなくすぐに店員に「買えるんですか？欲しいんですけどっ」と伝えると「はい、今在庫を確認しているところです」と他の客からも質問されているらしく慌てている感じで、どういう風に対応すべきか迷っている感じでした。結局、他からも店員がワラワラと集まってきて、客たちが希望する機種を個別に聞いて在庫確認のために消えていくって感じで店に来た順番とかは関係ない感じで進んでいました。確かに購入を決めている客ばかりでも無さそうだったので順番に並んでくださいと誘導するわけにもいかなかったのでしょう。目の前で購入できている人がいるのに目当ての機種が買えなかったら辛いなぁと思いながらもラッキーなことにほどなく購入（MacBookスペースグレイ512GB）することが出来ました。自分が購入できた後はすぐに店を出たのでわかりませんが、購入できた人とできなかった人で揉めたりしたのでは無いかとちょっと心配になりました。ヨドバシとしては新MacBookに人が集まるのが意外だったのかもしれません。店に着いたとき外に行列（確認してみたところ妖怪メダル目当ての行列だったそうです）が出来ていて店員が誘導して整列させていたんですが、ヨドバシ全体の取扱商品から考えたら新MacBookなんてものはかなりマイナーなものでしかないんでしょう。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/macbook_samp0.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/macbook_samp0.png&quot; alt=&quot;MacBook 12-inch Space Gray 512GB&quot; title=&quot;MacBook 12-inch Space Gray 512GB&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/macbook_samp1.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/macbook_samp1.png&quot; alt=&quot;MacBook 12-inch Space Gray 512GB&quot; title=&quot;MacBook 12-inch Space Gray 512GB&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;vaio-type-ppc&quot;&gt;Vaio type Pは今までで一番気に入ったモバイルPC&lt;/h3&gt;
&lt;p&gt;　2009年に発売されたソニーのVAIO type P（&lt;a href=&quot;http://www.vaio.sony.co.jp/Products/P1/&quot;&gt;VGN-P90S&lt;/a&gt;）を今でも使用している人はかなり少数派だと思いますが、サードパーティから購入した中国製の予備のバッテリーを駆使しながら今まで使ってきました。キーボードは打ち易いし解像度はUWXGA（1600×768）というMacBookAirより広い環境でRailsを使ったWebアプリ開発機としてもドキュメント作成用としても結構満足して使っていましたが、CPUが非力なのでEclipseを使ったりandroidアプリ開発（エミュレータが重い）には使えないなと感じていました。&lt;br /&gt;
　私の場合Vaioは購入当初からUbuntuやLinuxMintやlubuntuに入れ替えて使っていたので、Windowsの新作モバイルPCが出る度に気は進まないけどまた購入してすぐにWindowsを削除して使おうかなんてことも考えていましたが、そこまでするほどVaioよりいいと思えるモバイルPCはなかったしiPhoneアプリの開発もやってみたいって理由もあってMacBookAirの高解像度版が出れば乗り換えようと思いながら今まで使ってきました。MacBookAir買えばいいじゃないかという人がいると思いますが、過去の経験からMacBookAir11の解像度では開発は出来ないと思っていたし、MacBookAir13は持ち歩く気はしないというか、正確に言うと持ち歩くのはまだいいんですが出先で使うときの占有面積が広いのでちょっと邪魔だなって感じです。以上のような結果として自分にとってVaioPは今までで一番長期にわたって使い尽くしたモバイルPCになりました。&lt;br /&gt;
　そこであまり他の人の役には立たないと思いますがあくまで自分目線でVaioPとの勝敗表を作ってみました。上の項目ほど自分が重視する点です。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MacBook&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;解像度&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;○&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;キーボード&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;◎&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CPU・SSD&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;◎&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;バッテリーの持ち&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;◎&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ポインティングデバイス&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;○&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;重さ&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;邪魔さ&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;熱（ファンレス）&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;△&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;周辺機器・アクセサリー&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;×&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;◎…大差で勝ち、◯…勝ち、△…引き分け、×…負け&lt;/p&gt;

&lt;p&gt;USB機器やアクセサリー類は今後時間とともに解決していくことでしょう。まずはVaioPで使っていたような&lt;a href=&quot;http://www.sony.jp/vaio/products/VGP-CKP1/&quot;&gt;革製のケース&lt;/a&gt;が欲しいです。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/comp_vaio.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/comp_vaio.png&quot; alt=&quot;MacBook 12-inch and Vaio P&quot; title=&quot;VaioPとの比較&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;macbook&quot;&gt;新MacBookの使用感&lt;/h3&gt;
&lt;dl&gt;
  &lt;dt&gt;解像度&lt;/dt&gt;
  &lt;dd&gt;ハードウェアに関しては詳しく無いのですがRetinaディスプレイになればもっと高解像度になると思っていたので1440x900は少々残念です。これならVaioP（1600x768）と大差ありません。&lt;/dd&gt;
  &lt;dt&gt;キーボード&lt;/dt&gt;
  &lt;dd&gt;新開発のバラフライキーボードは快適です。ストロークが浅いなんて聞いていたけどまさかDELLのXPS11（型番は知りませんがフィルムタイプ？のストローク無しのキーボード）ほど酷いものでは無いだろうと思っていた通り、自分にとっては十分すぎる打ち易さです。言われてみれば確かにちょっと浅いかなって感じで、違和感はありませんでした。VaioPも小さな筐体の割には良く出来た打ち易いキーボードだと思いますが、やはりMacBookを触った後にVaioPのキーボードを打つとその違いを痛感します。あと、キーストローク音がVaioPがペチッペチッって感じなのですが、MacBookはコトコトコトって感じで高級感があります。&lt;/dd&gt;
  &lt;dt&gt;CPU・SSDスペック&lt;/dt&gt;
  &lt;dd&gt;VaioPでそこそこ満足していた自分にとっては十分過ぎる速さです。比較する意味も無いのですが、同じandroidアプリをビルドしてエミュレータ画面に起動するまでVaioPだと１５分!?（エミュレータは実機より遅いんです）かかる処理がMacBookだと２分で済みました。&lt;/dd&gt;
  &lt;dt&gt;バッテリー&lt;/dt&gt;
  &lt;dd&gt;今までは電源を確保するために仕方なくスタバを選択することも多かったので今回の買い替えでようやく電源の確保から解放されると思っていますがいつまで持つか不安です。今のところまだ出先での通常の使い方をしていないのでチェックしきれてませんが、新品の今でも動画を見るとすごい勢いでバッテリーが減っていきますので1年後には出先で電源を気にしなくていけなくなるような気がします。&lt;br /&gt;
　発熱に関してはもっとCPUを酷使してもいいのではないかと思うほどPC底面の温度は低いです。VaioPと比べても断然低くてまったく熱くなりません。冷たいといってもいいぐらいです。&lt;/dd&gt;
  &lt;dt&gt;トラックパッド&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/dt&gt;
  &lt;dd&gt;今までタッチパッドと言われる入力デバイス付きのノートPCを所有していた時期もありますが、ほとんどパッドを使ったことはなくマウスを外付して使っていました。モバイルPCを買うときにThinkPad,Libretto,C1R,VaioPと選択してきたのもトラックポイント（メーカーによって呼び名が違うようですが）が使えることが大きな要因でもありました。トラックポイントのほうが使いやすい面もありますがMacのトラックパッドは機能が豊富でこれなら外付けマウスを付けなくてもよさそうです。&lt;/dd&gt;
&lt;/dl&gt;

&lt;h3 id=&quot;section-1&quot;&gt;まとめ&lt;/h3&gt;
&lt;p&gt;　レビューというより日記なので皆さんの役には立たなかったかもしれませんが、今のところVaioP以上に使い続けたくなるモバイルPCになるような気がしています。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;トラックパッドについてとVaioPとの比較写真を追加しました &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/hardware/2015-04-14/macbook</link>
                <guid>http://happyclam.github.io/hardware/2015-04-14/macbook</guid>
                <pubDate>2015-04-14T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>HTML5でアニメーション</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;タイマーを使わない&lt;/h3&gt;
&lt;p&gt;　HTML5でアニメーションを実現する方法を調べてみたら、タイマーを使う必要が無くなったらしい（タイマー間隔をブラウザ任せに出来る）のでやってみました。それぞれのブラウザ用にAPIが分かれているようで今後どうなるかわかりません（HTML5自体がまだまだ流動的だと思いますが）が、結構以前（HTML5リリース当初）からこのやり方は定着しているらしいです。手元のAndroid4.1.2の端末（GL07S）でも問題なく動きました。IEでHTML5を利用するにはIE9以上が必要です。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二点の座標をクリックして直線を引くサンプル&lt;/h3&gt;
&lt;p&gt;　要するにRequestAnimationFrameというAPIを使えばいいという話なのですがネットでandroidの対応状況は4.1以上でも全滅という書き込みをちらほら見かけます。でも、実際にやってみると以下のCoffeeScriptをコンパイルしたanimation.jsとanimation.htmlをandroid端末（GL07s）にコピーしてURL指定すれば標準ブラウザでふつうに動作しました。ネットではjQueryといっしょに使用することで問題が出るという書き込みも見かけましたが無視することにしました。知らないうちに解決されたのでしょう&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;(^^)&lt;br /&gt;
　実際にアニメーションを駆使するスマホアプリを作るときは、既存のいろんなライブラリを使うことが多いのかもしれませんがHTML5だけで出来るほうがシンプルでいいですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CoffeeScript&quot;&gt;#animation.coffee
$ -&amp;gt;

    return new Animation()
    
class Animation
    constructor: -&amp;gt;
        @canvas = document.getElementById(&quot;canvasMain&quot;)
        @areaStartX = document.getElementById(&quot;spanStartX&quot;)
        @areaStartY = document.getElementById(&quot;spanStartY&quot;)
        @areaEndX = document.getElementById(&quot;spanEndX&quot;)
        @areaEndY = document.getElementById(&quot;spanEndY&quot;)
        @start = {x:0, y:0}
        @end = {x:100, y:100}
        @request = null
        @amount = 0
        @startflg = true
        @setEventListener()
        @touch(@start.x, @start.y)
        @touch(@end.x, @end.y)

    touch: (clientX, clientY) =&amp;gt;
        if @startflg
            @startflg = false
            @start.x = clientX; @areaStartX.innerHTML = clientX
            @start.y = clientY; @areaStartY.innerHTML = clientY
        else
            @startflg = true
            @end.x = clientX; @areaEndX.innerHTML = clientX
            @end.y = clientY; @areaEndY.innerHTML = clientY
        
    setEventListener: =&amp;gt;
        $(&#39;#canvasMain&#39;).on &#39;click&#39;, (e) =&amp;gt;
            @touch(e.clientX, e.clientY)

        $(&#39;#btnStart&#39;).on &#39;click&#39;, (e) =&amp;gt;
            @animate()
        
    animate: =&amp;gt;
        @request = requestAnimFrame(@animate, @canvas)
        @drawanimation()

    drawanimation: =&amp;gt;
        @context = @canvas.getContext(&#39;2d&#39;)
        @context.clearRect(0, 0, @canvas.width, @canvas.height)
        @amount += 0.02
        @amount = 1 if @amount &amp;gt; 1
        @context.beginPath()
        @context.moveTo @start.x, @start.y
        @context.strokeStyle = &#39;rgba(255, 105, 180, 0.7)&#39;
        @context.lineWidth = 12
        newX = @start.x + (@end.x - @start.x) * @amount
        newY = @start.y + (@end.y - @start.y) * @amount
        @context.lineTo newX, newY
        @context.stroke()
        if newX is @end.x and newY is @end.y
            cancelRequestAnimFrame @request
            @request = null
            @amount = 0

window.Animation = window.Animation || Animation

window.requestAnimFrame = (-&amp;gt;
  window.requestAnimationFrame or window.webkitRequestAnimationFrame or window.mozRequestAnimationFrame or window.oRequestAnimationFrame or window.msRequestAnimationFrame or (callback, element) -&amp;gt;
    window.setTimeout callback, 1000 / 60
)()
window.cancelRequestAnimFrame = (-&amp;gt;
  window.cancelAnimationFrame or window.webkitCancelRequestAnimationFrame or window.mozCancelRequestAnimationFrame or window.oCancelRequestAnimationFrame or window.msCancelRequestAnimationFrame or clearTimeout
)()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-HTML&quot;&gt;&amp;lt;!-- animation.html --&amp;gt;

&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.2.min.js&quot;&amp;gt; &amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;animation.js&quot;&amp;gt; &amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;アニメーションのテスト&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;canvas id=&quot;canvasMain&quot; width=&quot;400&quot; height=&quot;400&quot; style=&quot;background-color: #2f4f4f;&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
    &amp;lt;form&amp;gt;
      &amp;lt;p&amp;gt;
      開始点　X=&amp;lt;span id=&quot;spanStartX&quot;&amp;gt;&amp;lt;/span&amp;gt;:
      Y=&amp;lt;span id=&quot;spanStartY&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;br /&amp;gt;
      終了点　X=&amp;lt;span id=&quot;spanEndX&quot;&amp;gt;&amp;lt;/span&amp;gt;:
      Y=&amp;lt;span id=&quot;spanEndY&quot;&amp;gt;&amp;lt;/span&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;input id=&quot;btnStart&quot; type=&quot;button&quot; value=&quot;描画&quot;&amp;gt;
      &amp;lt;/p&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;黒板に赤チョークのイメージです（赤チョークって確かこういうピンクっぽい色だった記憶があります）&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/animation.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/animation.png&quot; alt=&quot;実機画面&quot; title=&quot;実機（gl07s）で動作確認&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/project/2015-02-01/first_cordova/&quot;&gt;前回記事&lt;/a&gt;で作成した&lt;a href=&quot;http://tictactoe-cf.herokuapp.com&quot;&gt;サイト&lt;/a&gt;にも適用。白線もチョークっぽく掠れた感じにしようかと思いましたが暗くなるので止めました&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/3mokunarabe.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/3mokunarabe.png&quot; alt=&quot;三目並べアプリ画面&quot; title=&quot;実機（gl07s）で三目並べアプリ&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;RequestAnimationFrame APIの対応状況は&lt;a href=&quot;http://caniuse.com/#feat=requestanimationframe&quot;&gt;ここ&lt;/a&gt;です。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/programming/2015-03-26/html5_anim</link>
                <guid>http://happyclam.github.io/programming/2015-03-26/html5_anim</guid>
                <pubDate>2015-03-26T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>iOS/Androidハイブリッドアプリ開発</title>
                <description>&lt;p&gt;Project: 「&lt;a href=&quot;http://tictactoe-cf.herokuapp.com&quot;&gt;&lt;strong&gt;CoffeeScript版三目並べ&lt;/strong&gt;&lt;/a&gt;」: &lt;a href=&quot;https://github.com/happyclam/tictactoe-cf&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;web&quot;&gt;まずは通常のWebサイトを作成&lt;/h3&gt;
&lt;p&gt;　ハイブリッド開発と言っても私は現時点ではiPhoneを持っていないのでAndroidでしか確認できませんが、HTML5とJavaScript（CoffeeScript）でPC上で開発しそれをAndroidとiPhoneで利用出来るなんて虫のいい話があるのなら是非やってみたくなります。HTML5のローカルストレージなんかもいろいろ可能性が広がる気がしますがとりあえず以前作ったRuby製コンソールアプリを使ってHTML5のCanvas機能を試してみたいと思います。&lt;br /&gt;
　まずは&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;以前の記事&lt;/a&gt;で作成した&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;Ruby製のコンソールプログラム&lt;/a&gt;をCoffeeScriptに書き換えていきます。&lt;a href=&quot;/programming/2015-01-28/ruby_to_js2/&quot;&gt;前回の記事&lt;/a&gt;以降特に苦労は無かったのですがRubyからCoffeeScriptへのコンバート作業に関しては触れずに、今回はAndroidアプリ化に関して書きます。&lt;/p&gt;

&lt;h3 id=&quot;cordovaphonegap&quot;&gt;cordova（PhoneGap）プロジェクトの作成&lt;/h3&gt;
&lt;p&gt;　作成したCoffeeScriptをコンパイル（&lt;code&gt;coffee -c tictactoe.coffee&lt;/code&gt;）したjsファイルとindex.htmlだけのサイトですが、Androidアプリ化するためにした作業は以下の通りです。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通常のWebサイトとして動作確認&lt;/li&gt;
  &lt;li&gt;cordovaコマンドを使ってプロジェクト作成&lt;/li&gt;
  &lt;li&gt;作成したプロジェクトのwwwディレクトリ内のindex.htmlファイル内のbodyタグの中身をPCサイトのindex.htmlの内容に置き換える＆作成したJavaScriptファイルを読み込むscriptタグを追記。&lt;/li&gt;
  &lt;li&gt;エミュレータ上で動作確認&lt;/li&gt;
  &lt;li&gt;実機で動作確認&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;tree
.
├── index.html
├── js
│   └── jquery-1.11.1.min.js
├── tictactoe.coffee
└── tictactoe.js

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;cordova create Tictactoe com.herokuapp.tictactoe Tictactoe -d
cd Tictactoe
cordova platform add android
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　cordovaコマンドで生成したindex.htmlの雛形にPCサイト用のindex.htmlの中身をコピペ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#index.html
#header部は省略
    &amp;lt;body&amp;gt;
      &amp;lt;p id=&quot;title&quot;&amp;gt;三目並べ（TicTacToe）&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;canvas id=&quot;canvasMain&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;div id=&quot;orders&quot;&amp;gt;
          &amp;lt;input type=&quot;radio&quot; name=&quot;optOrders&quot; id=&quot;optOrder1&quot; value=&quot;-1&quot; checked=&quot;checked&quot;&amp;gt;First
          &amp;lt;input type=&quot;radio&quot; name=&quot;optOrders&quot; id=&quot;optOrder2&quot; value=&quot;1&quot;&amp;gt;Second
        &amp;lt;/div&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;input id=&quot;btnStart&quot; type=&quot;button&quot; value=&quot;Start!&quot;&amp;gt;
        &amp;lt;span id=&quot;spanStatus&quot;&amp;gt;&amp;lt;/span&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script src=&quot;js/jquery-1.11.1.min.js&quot;&amp;gt; &amp;lt;/script&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot; src=&quot;tictactoe.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;cordova emulate android -d
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/tictactoe_emulator.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/tictactoe_emulator.png&quot; alt=&quot;エミュレータ画面&quot; title=&quot;エミュレータで動作確認&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;cordova run android
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/tictactoe_gl07s.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/tictactoe_gl07s.png&quot; alt=&quot;実機画面&quot; title=&quot;実機（gl07s）で動作確認&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　cordovaプロジェクト下のwww内のファイルを修正してcordovaコマンドを実行すると、platforms/android/以下にAndroid用のファイルが出力されるようです。ビルドしてエミュレータや実機にインストールして実行するまで一気に行うので上記のようにあっという間に完成しました。このビルド作業を行う環境構築の方が時間がかかるかもしれません。環境構築については&lt;a href=&quot;http://www.amazon.co.jp/Android%E5%AF%BE%E5%BF%9C-HTML5-%E3%83%8F%E3%82%A4%E3%83%96%E3%83%AA%E3%83%83%E3%83%89%E3%82%A2%E3%83%97%E3%83%AA%E9%96%8B%E7%99%BA-Software-Design/dp/4774162116/ref=tmm_pap_title_0?ie=UTF8&amp;amp;qid=1421726606&amp;amp;sr=1-1&quot;&gt;この本&lt;/a&gt;を参考にしましたが、個人的にはRubyの開発環境と同じく、ユーザ領域に構築（sudoを使わない）する方がいいのではないかと思ってます。&lt;br /&gt;
　それにしても以前droidgapコマンド（cordovaの前身？）の時はeclipseを使わなければいけなかったり、いろいろトラブルに見舞われた記憶があるのですが、思った以上に簡単でした。でも、このままだと見た目もUIも貧弱過ぎるのでjquery mobileを使って追加・修正していくことになると思いますが、そうするとPCサイト用とは別物になっていくのでしょう。そのあたりも今後確認していこうと思います。&lt;/p&gt;

&lt;hr /&gt;

</description>
                <link>http://happyclam.github.io/project/2015-02-01/first_cordova</link>
                <guid>http://happyclam.github.io/project/2015-02-01/first_cordova</guid>
                <pubDate>2015-02-01T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>Ruby製プログラムをCoffeeScript（JavaScript）に書き換える</title>
                <description>&lt;h3 id=&quot;javascript&quot;&gt;クライアントサイドの入力チェック用だったJavaScriptが今は主役&lt;/h3&gt;
&lt;p&gt;　以前Titaniumを弄ったときはどうしてもJavaScriptに積極的に取り組む気にはなれなかったのですが、cordova（PhoneGap）の存在を知り&lt;a href=&quot;http://www.amazon.co.jp/Android%E5%AF%BE%E5%BF%9C-HTML5-%E3%83%8F%E3%82%A4%E3%83%96%E3%83%AA%E3%83%83%E3%83%89%E3%82%A2%E3%83%97%E3%83%AA%E9%96%8B%E7%99%BA-Software-Design/dp/4774162116/ref=tmm_pap_title_0?ie=UTF8&amp;amp;qid=1421726606&amp;amp;sr=1-1&quot;&gt;[iOS/Android対応] HTML5 ハイブリッドアプリ開発[実践]入門&lt;/a&gt;という本を読んで、またJavaScriptを使ったandroidアプリ開発への興味が戻って来ました。Titaniumを弄ったときと違って自分にとってはCoffeeScriptの存在が大きい、JavaScriptは嫌いだけどCoffeeScriptならやる気が湧きます。なので試しに以前記事を書いたRuby製の三目並べのプログラムをCoffeeScript（最終的にはJavaScriptを使ったandroidアプリ）に移植して見ようと思い取り組み始めたらいきなり問題に遭遇したのでTips的に記事を書いてみます。&lt;br /&gt;
　それにしても昔のWebシステムはブラウザのJavaScript機能がOffでも使えることを要求されたものなのに、リッチなUIを要求するユーザーの声がどんどん大きくなり、最近ではJavaScript（jQuery,Ajax）無しは考えられない感じですね。そしてどうせJavaScriptを避けることが出来ないのなら、どうにかしてJavaScriptを楽に生成しようという流れが続いてます。&lt;/p&gt;

&lt;h3 id=&quot;arrayrubyjavascript&quot;&gt;Arrayクラスを継承したRubyのクラスをJavaScriptに&lt;/h3&gt;
&lt;p&gt;　三目並べの盤を表現するArrayクラスを継承した以下のコードを&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#tictactoe.rb
class Board &amp;lt; Array
  def initialize(*args, &amp;amp;block)
    super(*args, &amp;amp;block)
  end
end

b = Board.new([1, 2, 3, 4, 5, 6, 7, 8, 9])
p b[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のようにCoffeeScriptに書き換えて実行したところ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;#tictactoe.coffee
class Board extends Array
    constructor: (args) -&amp;gt;
        super(args)

b = new Board([1, 2, 3, 4, 5, 6, 7, 8, 9])
console.log b[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画面には&lt;code&gt;undefined&lt;/code&gt;と表示されました。エラーにもなりません。コンストラクタに渡されたargsパラメータはどこに行ったのでしょうか？&lt;code&gt;super(args)&lt;/code&gt;の行を&lt;code&gt;@ = args&lt;/code&gt;とやったらエラーになります&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;br /&gt;
　以下のようにパラメータを可変個引数にして、配列要素をバラバラのパラメータにして渡しても同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#tictactoe.coffee
class Board extends Array
    constructor: (args...) -&amp;gt;
        super(args...)

b = new Board(1, 2, 3, 4, 5, 6, 7, 8, 9)
console.log b[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　試しにArrayクラスに新しいプロパティを追加してあげるとそちらの方はちゃんと代入出来ました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;#tictactoe.coffee
Array::data = []
class Board extends Array
    constructor: (args) -&amp;gt;
        super(args)
        @.data = args

b = new Board([1, 2, 3, 4, 5, 6, 7, 8, 9])
console.log b[3]
console.log b.data[3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;まず、JavaScriptでもクラスの拡張（オープンクラス？）が簡単に出来ることに驚きました。Rubyと同様にオブジェクト指向出来るんですね。でもこのCoffeeScriptをJavaScriptに変換した中身を見てみると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$coffee -c tictactoe.coffee
$cat tictactoe.js
// Generated by CoffeeScript 1.6.3
(function() {
  var Board, b,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Array.prototype.data = [];
  Board = (function(_super) {
    __extends(Board, _super);
    function Board(args) {
      Board.__super__.constructor.call(this, args);
      this.data = args;
    }
    return Board;
  })(Array);
  b = new Board([1, 2, 3, 4, 5, 6, 7, 8, 9]);
  console.log(b.data[3]);
  console.log(b[3]);
}).call(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんじゃこりゃ〜。CoffeeScriptを介さずに元のRubyのコードからこのJavaScriptのコードを書ける気がしない。慣れの問題もあるでしょうが、CoffeeScriptが見事に抽象化してくれているのがわかります。&lt;br /&gt;
　で、問題のコンストラクタに渡された引数の部分ですが、&lt;code&gt;Board.__super__.constructor.call(this, args);&lt;/code&gt;こうなっていて値を置き換えてくれても良さそうですが入りません。追加したdataプロパティの方は&lt;code&gt;Array.prototype.data = [];&lt;/code&gt;と定義されていて、JavaScriptではprototypeプロパティを介してデータを参照しているようです。なので&lt;code&gt;@.prototype = args&lt;/code&gt;とやったりしましたが値はセットされませんしエラーにもなりません。&lt;code&gt;@ = args&lt;/code&gt;はエラーになりますがpushメソッドは呼べるので、結局コンストラクタで&lt;code&gt;@.push(args[i]) for i in [0...args.length]&lt;/code&gt;とすることでRubyからCoffeeScriptを介してJavaScriptに移植することが出来ました。  &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;#tictactoe.coffee
class Board extends Array
    constructor: (args) -&amp;gt;
        @.push(args[i]) for i in [0...args.length]

b = new Board([1, 2, 3, 4, 5, 6, 7, 8, 9])
console.log b[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　配列の大括弧（[]、bracket）さえもメソッドとして実装しているRubyとの違いかもしれませんが、とりあえず移植できてなによりです。今までJavaScriptに関して真剣に取り組んだことが無かったのですが、&lt;a href=&quot;http://www.amazon.co.jp/%E9%96%8B%E7%9C%BC-JavaScript-%E2%80%95%E8%A8%80%E8%AA%9E%E4%BB%95%E6%A7%98%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B6JavaScript%E3%81%AE%E6%9C%AC%E8%B3%AA-Cody-Lindley/dp/487311621X/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1421851059&amp;amp;sr=1-1&amp;amp;keywords=%E9%96%8B%E7%9C%BC%EF%BC%81javascript&quot;&gt;買ってきた本&lt;/a&gt;を見ながら移植を進めて、また何か問題が発生すれば記事を書いてみます。&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;CoffeeScriptでは@はthisの別名、::はprototypeの別名）。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/programming/2015-01-25/ruby_to_js</link>
                <guid>http://happyclam.github.io/programming/2015-01-25/ruby_to_js</guid>
                <pubDate>2015-01-25T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>checkboxでAjaxで更新（PATCH）処理</title>
                <description>&lt;h3 id=&quot;jqueryajaxcoffeescript&quot;&gt;jQuery,Ajax,CoffeeScript覚えること多過ぎ&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://my-posi.herokuapp.com/&quot;&gt;先物・オプションのシミュレーションサイト&lt;/a&gt;のポジション編集画面で、チェックボックスをクリックすることでグラフのタイプを切り替える処理（データ更新後リダイレクトしている）をしているのですが、これをAjaxで実現しようとしたところ思わぬエラーに遭遇したので、新規サンプルプロジェクトを作って改めて動作を確認することにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rails _4.1.6_ new chkbox                ←バージョンを指定して新規プロジェクト作成
cd chkbox
rails g scaffold memo body:string chk:boolean
bundle install
rake db:migrate
rails s
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/scaffold_edit.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/scaffold_edit.png&quot; alt=&quot;scaffold 編集画面&quot; title=&quot;scaffold 編集画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　あと、turbolinksを有効にしているとAjaxの動作状況が分かりにくいので&lt;a href=&quot;http://qiita.com/kazz187/items/12737363d62b9c91993c&quot;&gt;このサイト&lt;/a&gt;を参考にしてturbolinksを無効にしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/views/memos/_form.html.erb
 &amp;lt;%= form_for(@memo, remote: true) do |f| %&amp;gt;
   &amp;lt;div class=&quot;field&quot;&amp;gt;
     &amp;lt;%= f.label :body %&amp;gt;&amp;lt;br&amp;gt;
     &amp;lt;%= f.text_field :body %&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div class=&quot;field&quot;&amp;gt;
     &amp;lt;%= f.label :chk %&amp;gt;&amp;lt;br&amp;gt;
     &amp;lt;%= f.check_box :chk %&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div class=&quot;actions&quot;&amp;gt;
     &amp;lt;%= f.submit %&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div id=&quot;status&quot;&amp;gt;&amp;lt;/div&amp;gt;
 &amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/controllers/memos_controller.rb
  def update
    if @memo.update(memo_params)
      @status = &quot;O.K.&quot;
    else
      @status = &quot;N.G.&quot;
    end
    render
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/views/memos/update.js.erb
$(&#39;#status&#39;).html(&quot;&amp;lt;%= j(@status) %&amp;gt;&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　scaffoldで生成された状態からformに&lt;code&gt;remote: true&lt;/code&gt;を追加してcontrollerをすこし弄ってupdate.js.erbを新規作成しただけですが、フォームのボタンをクリックするとAjax通信でデータの更新処理が完了し、コントローラから渡された文字列をビューに表示出来ます。フレームワークが用意してくれた仕組みを素直に使えば非常に簡単にAjax更新処理が実現できました。&lt;br /&gt;
　そこで今度はフォームのsubmitボタンではなく、チェックボックスをクリックすることで同じことをやろうとしてフォームのcheck_boxの行を&lt;code&gt;&amp;lt;%= f.check_box(:chk, {:onchange =&amp;gt; &quot;this.form.submit();&quot;}, &quot;t&quot;, &quot;f&quot;) %&amp;gt;&lt;/code&gt;と書き換えて、チェックボックスをクリックするとInvalidAuthenticityTokenエラーが出ました。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/invalidauthenticitytoken.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/invalidauthenticitytoken.png&quot; alt=&quot;InvalidAuthenticityTokenエラー画面&quot; title=&quot;InvalidAuthenticityTokenエラー画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　javascriptでsubmitしてしまうとcsrf-tokenが送られないということでしょう。ユーザ認証（ログイン処理）していなくてもPOST（この場合PATCH）リクエストを送る場合は必要なのか？と思いながらフォーム内に&lt;code&gt; &amp;lt;%= hidden_field_tag(:authenticity_token, form_authenticity_token) %&amp;gt;&lt;/code&gt;を記述して再度チェックボックスをクリックすると今度はTemplate is missingエラー。&lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/templatemissing.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/templatemissing.png&quot; alt=&quot;Template Missing エラー画面&quot; title=&quot;Template Missing エラー画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　フォームのPATH指定時にformatを指定してこのように&lt;code&gt;&amp;lt;%= form_for(@memo, url: memo_path(@memo, format: :js), remote: true) do |f| %&amp;gt;&lt;/code&gt;書き換えて、再度チェックボックスをクリックすると、ブラウザにupdate.js.erbファイルの中身が文字として表示されました。  &lt;/p&gt;

&lt;div style=&quot;width:320px; margin: 0 auto;&quot;&gt;

  &lt;p&gt;&lt;a href=&quot;/images/browser_disp.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/browser_disp.png&quot; alt=&quot;Text Response 画面&quot; title=&quot;Text Response 画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　ここまで来てもすぐには自分の間違いに気が付きませんでした。上でも自分で書いているけど、javascriptで普通にsubmitしているのだからAjax通信出来ていないようです。remote: true を書くことでフォームがAjax用になっているからform.submit()でAjax通信が出来るような錯覚をしていました。冒頭で思わぬエラーに遭遇したと書いたのはこのことです^^;&lt;br /&gt;
　HTMLのソースを見てみるとフォームには&lt;code&gt;data-remote=&quot;true&quot;&lt;/code&gt;の属性が付加されていたので、onchangeでthis.form.submit()するのではなくjavascriptの関数を作ってその中で&lt;code&gt;form.setAttribute(&#39;data-remote&#39;, true);&lt;/code&gt;とやってcheckboxに無理やり&lt;code&gt;data-remote=&quot;true&quot;&lt;/code&gt;の属性を付加してみましたが効果ありませんでした^^; Railsがどういう仕組みでAjaxを実現しているのかよくわかってませんが、Railsで予定していない使い方であることは確かなようです。 &lt;br /&gt;
　で、form.submit()ではダメだとわかったので次のようにcheckboxのonchange=のイベントを削除して、jQueryでイベントを登録してそのイベント内でAjax通信するようにしました。Ajax送信後のCallback処理もそこに記述したのでjs.erbは使いません。&lt;code&gt;render :text =&amp;gt; @status&lt;/code&gt;とすれば.doneイベント（コールバック関数）のdata引数に@statusの内容が入って来るので。&lt;code&gt;$(&#39;#status&#39;).html(data);&lt;/code&gt;として画面に表示します。これで一応UnobtrusiveなJavascriptというかHTMLとスクリプトの分離が出来たのは目出度いことです。&lt;br /&gt;
　それと、先ほどエラー回避のためにフォーム内のPATHを変更しましたが、_form.html.erbはupdateのときだけでなくcreateのときも使用しているので元に戻しておきます。そうすればチェックボックスでの更新処理はあくまで追加の機能として作成できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/views/memos/_form.html.erb
&amp;lt;%= javascript_tag do %&amp;gt;
jQuery(function ($){
    $(&quot;#memo_chk&quot;).on(&#39;change&#39;, function(){
        body = $(&quot;#memo_body&quot;).val();
        authenticity_token = $(&quot;#authenticity_token&quot;).val();
        $.ajax({
            url: &#39;&amp;lt;%= memo_path(id: @memo.id, format: :js) %&amp;gt;&#39;,
            type: &#39;PATCH&#39;,
            dataType: &#39;html&#39;,
            data: {
                id: &#39;&amp;lt;%= @memo.id %&amp;gt;&#39;,
                authenticity_token: authenticity_token,
                memo: {
                    body: body,
                    chk: (this.checked) ? &#39;t&#39; : &#39;f&#39;
                    }
            }
        }).done(function(data, status, xhr) {
            $(&#39;#status&#39;).html(data);
        }).fail(function(xhr, status, error) {
            alert(&#39;Error Occured(&#39; + error + &#39;)&#39;);
        });
     });
});
&amp;lt;% end %&amp;gt;

&amp;lt;%= form_for(@memo, remote: true, html:{name: &quot;frm_chkbox&quot;}) do |f| %&amp;gt;
  &amp;lt;%= hidden_field_tag(:authenticity_token, form_authenticity_token) %&amp;gt;
  &amp;lt;div class=&quot;field&quot;&amp;gt;
    &amp;lt;%= f.label :body %&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;%= f.text_field :body %&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;field&quot;&amp;gt;
    &amp;lt;%= f.label :chk %&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;%= f.check_box(:chk) %&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;actions&quot;&amp;gt;
    &amp;lt;%= f.submit %&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div id=&quot;status&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/controllers/memos_controller.rb
  render :text =&amp;gt; @status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　これで一応checkboxのクリック時は動くのですが、render部分を変更したために更新ボタンをクリックした場合に何も表示されません。はじめはcheckboxイベント用の別メソッドをコントローラに追加したのですが、更新処理自体は同じものなので既存のupdateメソッドをそのまま使って表示の際に分岐するようにします。&lt;br /&gt;
　それからテンプレートとjavascriptは分けておこうと思ってjavascript部分をapp/asset/javascript/ディレクトリに別ファイル（chkbox.js）として移動したのですが、ajax呼び出し時のurl:パラメータが上手く展開されませんでした。拡張子に「erb」を追加すればRailsがちゃんと展開してくれるとどこかに書かれていたので.jsからerb.jsに拡張子を変えてみましたが上手くいきませんでした。&lt;br /&gt;
　それとRails4から新規プロジェクトを作成すると勝手にコントローラ毎のjs.coffeeファイルが作られるので、どうせならそちらに移動しようと思いcoffeescriptに書き換えて&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;最終的には以下のようにしました。  &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-coffeescript&quot;&gt;#app/assets/javascripts/memos.js.coffee
jQuery ($) -&amp;gt;
    $(&quot;#memo_chk&quot;).on &quot;change&quot;, -&amp;gt;
        id = $(&quot;#memo_id&quot;).val()
        body = $(&quot;#memo_body&quot;).val()
        chk = $(this).is(&quot;:checked&quot;) ? &quot;t&quot; : &quot;f&quot;
        authenticity_token = $(&quot;#authenticity_token&quot;).val()
        $.ajax(
            url: &quot;/memos/&quot; + id + &quot;.js&quot;
            type: &quot;PATCH&quot;
            dataType: &quot;text&quot;
            data:
                id: id
                authenticity_token: authenticity_token
                memo:
                    body: body
                    chk: (if chk then &quot;t&quot; else &quot;f&quot;)
        ).done((data, status, xhr) -&amp;gt;
            $(&quot;#status&quot;).html data
            return
        ).fail (xhr, status, error) -&amp;gt;
            alert &quot;Error Occured(&quot; + error + &quot;)&quot;
            return

        return

    return
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/views/memos/_form.html.erb
&amp;lt;%= form_for(@memo, remote: true, html:{name: &quot;frm_memo&quot;}) do |f| %&amp;gt;↓
  &amp;lt;%= hidden_field_tag(:memo_id, @memo.id) %&amp;gt;↓
  &amp;lt;%= hidden_field_tag(:authenticity_token, form_authenticity_token) %&amp;gt;
  &amp;lt;div class=&quot;field&quot;&amp;gt;↓
    &amp;lt;%= f.label :body %&amp;gt;&amp;lt;br&amp;gt;↓
    &amp;lt;%= f.text_field :body %↓
  &amp;lt;/div&amp;gt;↓
  &amp;lt;div class=&quot;field&quot;&amp;gt;↓
    &amp;lt;%= f.label :chk %&amp;gt;&amp;lt;br&amp;gt;↓
    &amp;lt;%= f.check_box(:chk) %&amp;gt;↓
  &amp;lt;/div&amp;gt;↓
  &amp;lt;div class=&quot;actions&quot;&amp;gt;↓
    &amp;lt;%= f.submit %&amp;gt;↓
  &amp;lt;/div&amp;gt;↓
  &amp;lt;div id=&quot;status&quot;&amp;gt;&amp;lt;/div&amp;gt;↓
&amp;lt;% end %&amp;gt;↓
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#app/controllers/memos_controller.rb
  def update
    if @memo.update(memo_params)
      @status = &quot;O.K.&quot;
    else
      @status = &quot;N.G.&quot;
    end
    if request.method == &quot;PATCH&quot;
      render :text =&amp;gt; @status
    else
      render template: &quot;memos/update.js.erb&quot;
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;urlパラメータはRailsの_PATH表記から文字列に変更&lt;/li&gt;
  &lt;li&gt;memo.idをview内のhiddenフィールドに保存して、jQueryでその値を取得するように変更&lt;/li&gt;
  &lt;li&gt;Railsのフォームから呼ばれた場合とjQueryから呼ばれた場合でrenderするものを変更する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　これで一応checkboxでの更新＆表示処理が完成しましたが、Railsで生成したフォームからupdateメソッドを呼び出す場合とjQueryからupdateメソッドを呼び出す場合で、画面出力処理が２種類（js.erbと.doneイベント）に分かれています。このサンプルの場合@status変数に格納した文字列を画面に表示するだけの処理ですが、それでも同じ処理をするコードが２ヶ所に存在しているのはよくないでしょう。Javascript側からAjax通信を開始（request.send、$.ajax）するときにコールバック関数としてjs.erbを指定することが出来たり（もしかして出来る？）、RailsのフォームからAjax通信するときにcoffeescript（Javascript、jQuery）のコールバック関数を指定出来たりしたら出力関数を統一出来そうですがそれはそれでややこしそうです。&lt;br /&gt;
　あと、request.methodで分岐していますが、これでいいのかどうか分かりませんしこういうコードは見かけたことが無いような気がします。&lt;br /&gt;
　ということで結局実際に使用するアプリではformから更新ボタンを無くしてjs.erbは使わないやり方に統一することにしました。こんなことになるなら最初からjs.erbは使わずにjQueryとCoffeeScriptで作ることに決めておけばよかったような気がします。&lt;br /&gt;
　それと実際に使用するサイトでやりたかったことはlazy_high_chartsを使ったグラフ表示なのでdataTypeはtextでなくjsonでやりとりしています。とてつもなく&lt;a href=&quot;https://github.com/happyclam/my-posi&quot;&gt;汚いソース&lt;/a&gt;ですが興味のある方はそちらで確認出来ます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;修正前（左）と修正後（右）&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; height:240px; float: left;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/my-posi-update-old.png&quot; alt=&quot;修正前グラフ編集画面&quot; title=&quot;修正前グラフ編集画面&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;width:20px; height:240px; float: left;&quot;&gt;&lt;/div&gt;

&lt;div style=&quot;width:320px; height:240px; float: left;&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/images/my-posi-update-new.png&quot; alt=&quot;修正後グラフ編集画面&quot; title=&quot;修正後グラフ編集画面&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div style=&quot;width:320px; height:280px; margin: 0 auto;&quot;&gt;&lt;/div&gt;

&lt;p&gt;　注意点としてこのアプリの場合、編集画面と新規登録画面が別々なのでよかったのですが、説明に使用したサンプルプロジェクトでは編集画面と新規登録画面で同じフォームを利用しているので新規登録画面でcheckboxをクリックしたときはjQueryイベントが発動しないようにするかフォームを分ける必要があると思います。&lt;br /&gt;
　そもそもcheckboxクリックで更新処理というのが特殊なUIなのかもしれませんが…。  &lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;javascriptをcoffeescriptに書き換えるのは&lt;a href=&quot;http://js2coffee.org/&quot;&gt;こちらのサイト&lt;/a&gt;を利用しました &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/programming/2014-12-26/csrf</link>
                <guid>http://happyclam.github.io/programming/2014-12-26/csrf</guid>
                <pubDate>2014-12-26T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>自動でコードレビュー</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;当面は無料で提供されるらしいのでやってみて損はないかな？&lt;/h3&gt;
&lt;p&gt;　セキュリティホールをふせぐという謳い文句に惹かれて&lt;a href=&quot;http://jp.techcrunch.com/2014/04/30/%E3%82%A2%E3%82%AF%E3%83%88%E3%82%AD%E3%83%A3%E3%83%83%E3%83%88%E3%81%AE%E3%80%8Csideci%E3%80%8D%E3%81%AF%E3%80%81%E3%82%B3%E3%83%BC%E3%83%89%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E3%82%92%E8%87%AA/&quot;&gt;「SideCI」&lt;/a&gt;使ってみました。レビューの対象に使ったプロジェクトは&lt;a href=&quot;/programming/2014-10-27/my-posi-chart/&quot;&gt;前回の記事&lt;/a&gt;でRails4にバージョンアップしたばかりの&lt;a href=&quot;https://github.com/happyclam/my-posi&quot;&gt;これ&lt;/a&gt;です。&lt;br /&gt;
　使っている人の感想とか探せばもっと見つかると思いますが自分が参考にしたのは&lt;a href=&quot;http://blog.mah-lab.com/2014/05/14/rails-side-ci/&quot;&gt;ここ&lt;/a&gt;です。中身は&lt;a href=&quot;http://brakemanscanner.org/&quot;&gt;Brakeman&lt;/a&gt;や&lt;a href=&quot;https://github.com/railsbp/rails_best_practices&quot;&gt;Rails Best Practice&lt;/a&gt;などのツールを組み合わせたものらしいけど、統合メニューで操作できるのは確かに有難いかも。色々メニュー項目がありますが自分が使ってみたものについて感想と、指摘された改善点についてざっと書きます。&lt;br /&gt;
　自分が書いたプログラムにどのような難癖を付けられるのか気になる人もいると思いますので参考にしてください(^^)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ニュースフィード&lt;/strong&gt;&lt;br /&gt;
　Test&amp;amp;Deployの機能や通知機能を使う気がない自分にとってはあまり必要がないメニューかも&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dashboard&lt;/strong&gt;  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;width:320px; height:240px; float: left;&quot;&gt;

  &lt;p&gt;&lt;img src=&quot;/images/dashboard_org_my-posi.png&quot; alt=&quot;ダッシュボード画面初期状態&quot; title=&quot;初レビュー時のダッシュボード画面&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div style=&quot;width:320px; height:240px; float: left;&quot;&gt;

  &lt;p&gt;&lt;img src=&quot;/images/dashboard_new_my-posi.png&quot; alt=&quot;ダッシュボード画面コード改修後&quot; title=&quot;コード改修後のダッシュボード画面&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div style=&quot;width:320px; height:280px; margin: 0 auto;&quot;&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;セキュリティ&lt;/strong&gt;&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://brakemanscanner.org/docs/warning_types/link_to_href/&quot;&gt;Cross Site Scripting: Link to HREF&lt;/a&gt;&lt;br /&gt;
twitterで呟くための文字列をAPIに渡す以下のコードでセキュリティ警告が出ました。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;&amp;lt;%= link_to(&quot;結果をTwitterでつぶやく&quot;, &quot;https://twitter.com/intent/tweet?text=#{u(@strategy.get_message_str)}&amp;amp;url=&quot; + request.url) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;　たしかRails3以降は自動で文字列をエスケープしてくれるはずと思って検索したら&lt;a href=&quot;http://www.rubylife.jp/rails/template/index7.html&quot;&gt;ここ&lt;/a&gt;にもそう書いてあります。それなのに警告が出るのはおそらくSideCI上の&lt;a href=&quot;https://github.com/railsbp/rails_best_practices&quot;&gt;Rails Best Practice&lt;/a&gt;のオプション設定の問題だと思います。もしそうだとしたらGemfileに使用しているRailsのバージョンが書いてあるのだからオプション設定もそれに合わせてほしいところですが、一応以下のように修正して警告を出さないようにすることは出来ました。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;&amp;lt;%= link_to(&quot;結果をTwitterでつぶやく&quot;, &quot;https://twitter.com/intent/tweet?text=#{h(@strategy.get_message_str)}&amp;amp;url=#{h(request.url)}&quot;) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;念のためhtmlタグやシングルクォートを出力して確認しましたがh()で囲まなくてもちゃんとエスケープされていました。無駄な時間を取られましたが、まぁ確認する機会を得られたと前向きに考えるべきなのでしょうかヽ(~〜~　)ノ\ ハテ?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;コード品質&lt;/strong&gt;&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;http://rails-bestpractices.com/posts/148-protect-mass-assignment&quot;&gt;Protect mass assignment&lt;/a&gt;&lt;br /&gt;
このサイト（&lt;a href=&quot;http://qiita.com/aquamikan/items/57c6c95b39f961a18453&quot;&gt;Rails4はattr_accessibleが使えない&lt;/a&gt;）に書いてある通り、Rails4だとエラーになるからRailsをバージョンアップした時に削除したのに、そこが悪いと指摘されました。これはどういうことでしょう？これもセキュリティの警告と同じで&lt;a href=&quot;https://github.com/railsbp/rails_best_practices&quot;&gt;Rails Best Practice&lt;/a&gt;がRails4に対応していないものを使っているのか、オプション設定が厳しめになっているのかそんなところでしょう。よく分からないけど無視することにしました。こうなってくるとコードレビューしたことが混乱を引き起こすという本末転倒になってる気もしますが^^;本気でこのツールを使う気があるなら運営元に質問すればおそらく解決するでしょう。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;http://rails-bestpractices.com/posts/7-move-model-logic-into-the-model&quot;&gt;Move Model Logic into the Model&lt;/a&gt;&lt;br /&gt;
自分が納得したとこだけ修正しました。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;http://rails-bestpractices.com/posts/72-remove-empty-helpers&quot;&gt;Remove empty helpers&lt;/a&gt;&lt;br /&gt;
中身が空のヘルパーファイルがありますよ。自動生成したくなかったら&lt;code&gt;config.generators.helper = false&lt;/code&gt;しておけということですね。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;http://rails-bestpractices.com/posts/27-replace-instance-variable-with-local-variable&quot;&gt;Replace instance variable with local variable&lt;/a&gt;&lt;br /&gt;
納得。Rails2の頃からのソースで、よく理解していないまま書いていたコードがそのままでした。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;http://rails-bestpractices.com/posts/86-restrict-auto-generated-routes&quot;&gt;restrict auto-generated&lt;/a&gt; routes strategies (except: [:new])&lt;br /&gt;
以下のように定義していたルートに対して、&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;resources :strategies do
  collection do
    get :children
  end
  member do
    get :paint
    post :copy
  end
  resources :positions, :only =&amp;gt; [&quot;destroy&quot;, &quot;update&quot;, &quot;create&quot;, &quot;edit&quot;]
end
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;　「newが使われていませんよ」と指摘してくれたわけです。これはいいかも。以下のように修正しました。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;resources :strategies, :except =&amp;gt; [&quot;new&quot;] do
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://rails-bestpractices.com/posts/62-simplify-render-in-controllers&quot;&gt;Simplify render in controllers&lt;/a&gt;&lt;br /&gt;
このプロジェクトはModel用のテストスクリプト（Model用のspecファイル）しか書いていなくて、Railsのバージョンアップをした時に以下のようなRailsが出力する雛形のコードに対するテストが不十分でしたが、バグ出しツールとして役に立ちました。saveに失敗したら’new’テンプレートをrenderするとコードでは書いていますが、newテンプレートは存在していませんでした。但しファイルが存在しないことを指摘してくれたわけではありません。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;  respond_to do |format|
    if @user.save
      format.html { redirect_to @user, notice: &#39;User was successfully created.&#39; }
      format.json { render action: &#39;show&#39;, status: :created, location: @user }
    else
      format.html { render action: &#39;new&#39; }
      format.json { render json: @user.errors, status: :unprocessable_entity }
    end
  end
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;http://rails-bestpractices.com/posts/61-simplify-render-in-views&quot;&gt;Simplify render in views&lt;/a&gt;&lt;br /&gt;
部分テンプレートを使うとき&lt;code&gt;:partial&lt;/code&gt;というオプションを使わなければならない機会っていうのは無いってことなのか？と、新たな疑問が湧きましたが、リンク先に書いてある通りに修正しました。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;http://rails-bestpractices.com/posts/60-remove-trailing-whitespace&quot;&gt;remove trailing whitespace&lt;/a&gt;&lt;br /&gt;
行末のスペースを削除しろってことだけど、これは細かい！まぁチームで開発するときには一応統一しておいたほうがいいでしょうね。&lt;br /&gt;
あと、一つのファイルで最初に見つかった行だけを指摘するみたいなので、他の場所にも存在しないかよく確認してからcommitしましょう。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;remove unused methods&lt;br /&gt;
また使うかもしれないから残しておこうなんて思ったコードが結構残っていました。自分一人のプロジェクトなので他人を混乱させる心配はないのですが、せっかくgitでバージョン管理しているのだからバッサリ削除すべきですね。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;テスト &amp;amp; デプロイ設定&lt;/strong&gt;&lt;br /&gt;
　自分が使用しているtwitterAPI用の環境変数とかSSH Keyを登録するのが不安なので使用するのは止めておきました。まぁherokuではなんの警戒もせずtwitterの認証コードを環境変数にセットして使っているのに、なんで使わないのかと問われれば返答に困りますが、仕事で使う機会があれば使ってみたいと思います。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

</description>
                <link>http://happyclam.github.io/programming/2014-11-05/sideci_review</link>
                <guid>http://happyclam.github.io/programming/2014-11-05/sideci_review</guid>
                <pubDate>2014-11-05T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>gruffからlazy_high_chartへ</title>
                <description>&lt;h3 id=&quot;rails3rails4&quot;&gt;Rails3からRails4への移行&lt;/h3&gt;
&lt;p&gt;　一応&lt;a href=&quot;http://my-posi.herokuapp.com/&quot;&gt;herokuで公開&lt;/a&gt;してますがほとんど誰も使っていないようだし(^^)自分が使うときはローカル環境で動かすだけなのでRails4に移行する必要も無いのですが、&lt;a href=&quot;/project/2014-05-30/tweetwatch/&quot;&gt;TweetWatch&lt;/a&gt;を作ったときにLazyHighChartが気に入ったのでグラフ描画機能を変更する目的でついでにRailsもバージョンアップしました。Rails3からRails4への以降に関しては特に大きな変更は必要なかったのでgruffからlazy_high_chartへの移行に関して書きます。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;使い方&lt;/h3&gt;
&lt;p&gt;　その前に&lt;a href=&quot;https://www.ruby-toolbox.com/categories/graphing&quot;&gt;ここのサイト&lt;/a&gt;でいろんなグラフ描画ツールが紹介されています。以前googlechartsは試したことがあるのですが、何か気に入らないことがあってgruffに戻しました。でも、その理由が何であったのか忘れてしまいました(^^)  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Gemfileに追記
　&lt;code&gt;gem &#39;lazy_high_charts&#39;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Controllerでインスタンス変数にデータをセット&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;      @graphs = LazyHighCharts::HighChart.new(&quot;graph&quot;) do |f|
        f.chart(:type =&amp;gt; &quot;line&quot;)
        f.title(:text =&amp;gt; strategy.name)
        f.tooltip(:pointFormat =&amp;gt; &#39;{series.name}: {point.y}&amp;lt;br /&amp;gt;&#39;,
                  :shared =&amp;gt; true,
                  :useHTML =&amp;gt; true,
                  :style =&amp;gt; {margin: 0}
                  )
        f.xAxis(:title =&amp;gt; {:text =&amp;gt; &quot;先物価格&quot;}, :categories =&amp;gt; labels)
        f.yAxis(:title =&amp;gt; {:text =&amp;gt; &quot;収益&quot;})
        f.series(:name =&amp;gt; &quot;満期時計&quot;, :data =&amp;gt; total_data)
        f.series(:name =&amp;gt; &quot;理論値計&quot;, :data =&amp;gt; bm_data)
        distinct.each do |d|
          f.series(:name =&amp;gt; d.keys[0], :data =&amp;gt; d.values[0])
        end
      end
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Viewに出力&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;chart&quot; style=&quot;width:640px; height:480px; margin:0 auto;&quot;&amp;gt;
&amp;lt;%= high_chart(&quot;graph&quot;, @graphs) %&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　gruffを使っていた時のコードをほぼそのまま流用できましたが一点だけ引っかかったのが一つのキャンバスに複数の折れ線グラフを描画する方法。&lt;br /&gt;
　&lt;a href=&quot;http://www.highcharts.com/docs/getting-started/your-first-chart&quot;&gt;本家サイトのサンプル&lt;/a&gt;を見てHashの配列を渡すのかと思いきや上のコードのようにseriesメソッドを複数回呼ぶようにしないとグラフを描画してくれませんでした。本家のサンプルはもちろんそのまま動きましたので、これはlazy_high_chart gemの仕様ということでしょう。普通の人は引っかからないのかぁ？たぶん普通はgemのヘルプの方を見るんですね。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;グラフ描画ツールを変えたことによる影響&lt;/h3&gt;
&lt;dl&gt;
  &lt;dt&gt;画像（ドット絵）からベクターデータへ&lt;/dt&gt;
  &lt;dd&gt;gruffを使っていた以前のバージョンはpng画像を動的に生成していたのですが、lazy_high_chartではcanvasオブジェクトへの描画になるので、高速に描画出来るようになりました。以前は画像生成という重たい処理だったのでherokuの無料枠で運用していると処理が重すぎて画像生成に失敗してグラフ画像が表示されないことがありましたが、そういうことがなくなりそうです。それとクライアント側でJavaScriptで描画されたベクターデータなので、ブラウザを拡大・縮小するとそれに伴って画質を落とすこと無くグラフを拡大・縮小させることも出来るようになりました。まぁこのサイトの場合、画像を拡大・縮小しても縮尺を変えない限りあまり意味は無い（縮尺を変える機能はすでにある）ので、とりあえず今まで通りVGAサイズ（640×480）にしていますが、&lt;s&gt;サイズ変更するとしてもCSSで変更出来るから楽です。&lt;/s&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;ただ、古いブラウザ（HTML5に対応していない）だとグラフが描画出来ないことがあるかもしれません。&lt;/dd&gt;
  &lt;dt&gt;損益分岐線を描画する必要が無くなった&lt;/dt&gt;
  &lt;dd&gt;gruffの現状はよく知らないのですがgruffを使って開発した当初はメンテが行き届いていないようで縦軸のメモリを調整するのが簡単には出来なかったので、損益分岐線（0の値）のグラフをわざわざ自前で描画していたのですが、その必要がなくなりグラフがすっきりしました。  &lt;/dd&gt;
&lt;/dl&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;gruff&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;lazy_high_chart&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/my_posi_ex1.png&quot; alt=&quot;gruffの画像1&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/my_posi_chart1.png&quot; alt=&quot;lazy_high_chartの画像1&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/my_posi_ex2.png&quot; alt=&quot;gruffの画像2&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/images/my_posi_chart2.png&quot; alt=&quot;lazy_high_chartの画像2&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　それとグラフ上にマウスを持ってくるとグラフの数値をポップアップで表示してくれるのもいいですね。  &lt;/p&gt;

&lt;div style=&quot;width:320px; height:240px; margin:0 auto;&quot;&gt;

  &lt;p&gt;&lt;img src=&quot;/images/my_posi_chart3.png&quot; alt=&quot;マウスオーバーによるポップアップの画像&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　また、ググればいろいろ出て来ますが、gruffをruby1.9.3で使用するためとかLineメソッドを使うためにパッチを当てたりしなければいけませんでしたが、そういう無駄な作業からも開放されました。まあRubyだからモンキーパッチで簡単に出来る作業ではありましたが。&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;cssでwidthが変化するのでてっきり反映出来ているものと思っていましたが、&lt;a href=&quot;http://api.highcharts.com/highstock#chart.height&quot;&gt;highchartsのドキュメント&lt;/a&gt;に書いてある通りデフォルトの高さに関しては400pxのようです。ソースコードは修正済みです。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://happyclam.github.io/programming/2014-10-27/my-posi-chart</link>
                <guid>http://happyclam.github.io/programming/2014-10-27/my-posi-chart</guid>
                <pubDate>2014-10-27T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>三目並べ（tic tac toe）で遊んでみた（続き）</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;先読み手数を制限しても必勝の結論は出ないはず&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/software/2014-09-23/tictactoe_arrange/&quot;&gt;前回の記事&lt;/a&gt;で自分が作ったプログラムは千日手対応をしていないから先手必勝の結論が出ても信用できないって書きましたが、よく考えてみたら千日手対応していなくても先手必勝の評価が出てくるってことは、ArrangeLineってゲームが先手必勝であるか検証に使った自分のプログラムがバグっているかのどちらかであると気づきました。評価関数が返す値は一つの局面に関して勝ちか負けか引き分けかの三種類にしか分けていないので、千日手の局面は引き分けの一局面として評価しているはずで、引き分けに成り得るなら後手は引き分けになる手を選択し先手勝ちの評価にはならない。スタンダードの三目並べを調べた場合と違って、11手読みという手数を限定して先読みをしているわけだからそんなこともあるかと流してしまったけど、読み切っていないから勝ちか負けか決められない（引き分けになる）という評価が返ってくることはあっても、引き分けがあり得るのに必勝・必敗の評価を返してくるというのはバグっている可能性が高いのではないか。でも一応スタンダードな三目並べでは問題なさそうだし、バグの見当が付かなかったのでまずは先に千日手対応をしてみることにしました。&lt;br /&gt;
　その前にArrangeLineをダウンロードして自分のプログラムと対戦させて確認したのですが、ArrangeLineのLevel2で自分のプログラムが先手なのに千日手になり決着が付かないケースがありました。実際に千日手になることを確認していたためArrangeLineは双方最善手を打てば千日手になるゲームだと思ってしまったのですが、繰返しますが千日手になるのであればやっぱり先手必勝の結論が出るのはおかしい。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;千日手対応&lt;/h3&gt;
&lt;p&gt;　先読みの最中に過去に現れた局面が一定周期で続いて現れるかどうかを判定するってプログラムが重くなりそうだし、難しそうな気がして対応する気がしなかったのですが、よく考えてみると先読みの最中である必要は無く、実際に打った一手だけを局面毎に保存しておいて、先読みを開始する一手目の時だけ過去に同一局面があったかどうかを調べるだけで済みそうです。これなら重くなることもありません。&lt;br /&gt;
　※&lt;a href=&quot;/software/2014-09-23/tictactoe_arrange/&quot;&gt;前回の記事&lt;/a&gt;で必ず千日手になることを証明するのは難しいと書いたのは、完全読み切りが出来ない場合（将棋もその一つ）はたしかにその通りですが、先手必勝あるいは後手必勝という結論を返してくるということは完全読み切りが出来ているということなので、その時点で千日手は結論に関係無かったと言うことです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #過去に同一局面があったかどうか判定
  def check_dup(sengo)
    temp = self.dup
    temp.unshift(sengo)
    return @duplication.has_key?(temp.hash)
  end
  #局面データのハッシュ値だけ保存
  def set_dup(sengo)
    temp = self.dup
    temp.unshift(sengo)
    @duplication[(temp).hash] = temp
  end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　局面データと手番データからハッシュ値を生成して保存するメソッドと、そのハッシュ値を検索するメソッドを追加。&lt;br /&gt;
　過去に評価した局面を再現したりその時の評価値を再利用したりするわけでは無く、過去に同一局面があったかどうかを判断するだけなので保存するのはハッシュ値だけでもいいのですが、一応局面と手番のデータを保存しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if board.check_dup(turn)
          temp_v = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　そして局面を評価した後に過去に現れた局面なら強制的に評価値を引き分け（DRAW=0）にする処理を追加しただけです。引き分けでなく同じ局面を再現させたら負けとすることも考えられますが、それだとArrangeLineと対戦させたときにこのソフト側だけが不利なルールで戦うことになるのでよくありません。その他にも評価値を少し下げるとかいろいろ奥が深そうですが、将棋のように何らかの千日手に関するルールが無い限りは引き分けの評価（0）でよさそうです。&lt;br /&gt;
　ということで、同一局面を出現させたら引き分けという評価を返す状態で、前回の記事同様に一手打った状態から検証プログラムを動かしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|X|9|
2手目: 1 評価値: 9
2手目: 2 評価値: 9
2手目: 3 評価値: 9
2手目: 4 評価値: 9
2手目: 5 評価値: 9
2手目: 6 評価値: 9
2手目: 7 評価値: 9
2手目: 9 評価値: 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　前回と同じく初手に辺の部分に打てばやっぱり先手必勝になるという結果になります。そして実際のandroidアプリと対戦させて見たところ、以前は先手なのに必ず千日手になっていたケースでも千日手を避けるようになり、先手の場合に限っては必ず勝利することが出来るようです。なのでArrangeLineは先手必勝のゲームと言っていいでしょう。もし何か間違いに気づいた人がいれば連絡して下さい。景品を差し上げます…ウソです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;自作プログラムの対戦状況&lt;/em&gt;  &lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;先手・後手\ArrangeLineのLevel&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;Level 1&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;Level 2&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;Level 3&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;自作プログラムが先手&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;自作プログラムが後手&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;初手が辺&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;負け&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;^&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;初手が辺以外&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;勝ち&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;千日手&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　ArrangeLineは乱数を使っているようなのでこの表の結果はいつも同じではないはずですが、自作プログラムが先手の場合はいつも勝ちます。それと千日手対応したのに千日手になることがあるのは自作のプログラムが後手で、負けるはずなのにArrangeLine側が初手で辺の部分（2,4,6,8）を取らなかったために起きる現象です。自作ソフト側としては後手なので勝てないから千日手に持っていくしか無い状況ってことです。これは&lt;a href=&quot;/software/2014-09-23/tictactoe_arrange/&quot;&gt;前回の記事&lt;/a&gt;で初手から検証した時に以下の結果になったことと符合します。初手で辺の部分を取らない場合は、勝てるとは限らないということです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|8|9|
1手目: 1 評価値: 0
1手目: 2 評価値: 9
1手目: 3 評価値: 0
1手目: 4 評価値: 9
1手目: 5 評価値: 0
1手目: 6 評価値: 9
1手目: 7 評価値: 0
1手目: 8 評価値: 9
1手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;先手・後手が決まった段階で勝負は既に決まっている&lt;/h3&gt;
&lt;p&gt;　androidアプリのArrangeLine側は乱数を使っているようなので必ず再現するわけではないのですが、私のプログラムが先手の場合は必ず勝つのですが、後手の場合は最短の5手で負ける場合があります。  &lt;/p&gt;

&lt;div style=&quot;width:240px; height:287px; margin:0 auto;&quot;&gt;

  &lt;p&gt;&lt;img src=&quot;/images/arrangeline.png&quot; alt=&quot;負け画像&quot; /&gt;  &lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;　先手がリーチ（あと一手でラインが揃う）状態になっても揃うことを防ごうとしないことがあるのです。最初はバグか？と思いましたが、これもよく考えてみると私のソフト側は後手で尚且つ初手で辺の部分を取られていると、どう足掻いても負けることがわかっているので勝つことを諦めているわけです。&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;以前の記事&lt;/a&gt;に通常ルールの三目並べソフトが初手に有利なはずの真ん中を取らないことを書きましたが、初手にどこを取っても引き分けになることを読み切っている（初手にどこを選んでも引き分けの評価値が返ってくる）ので、1（左上隅）の場所から順に読み始めて最後に評価した9の場所（右下隅）を取る現象と同じです。ArrangeLineでも初手に辺の部分を取られているとその後どういう変化をしようが負けることがわかっている（先手勝ちの評価値MAX_VALUE=9が返ってくる）ため、相手がリーチをかけていようがいまいが関係なくたまたま最後に評価した場所を選んでしまいます。一回リーチを防いでも負けることが分かってるのですから…。&lt;br /&gt;
　この現象を防ぐにはどうすればいいのか、前にも書きましたが将棋にしろオセロにしろ局面の形勢判断用の評価関数と読み切り用（将棋で言えば詰将棋用）の評価関数を分けて使用するか、リーチを優先的に防ぐ処理（将棋で言えば王手放置を避ける）を用意すればいいのでしょうが、相手が間違えない限り手数を伸ばすだけで、勝敗は既に決まっています。将棋と違って完全読切りが完了しているゲームでこの処理を入れるのは虚しいだけでしょう。ただ、このArrangeLineに関して言えばandroid端末用のゲームなので完全読切りするにはマシンパワーの制限で難しいからそれなりに形勢判断用の評価関数を工夫する意味はあると思います。自分はあまり興味湧きませんが…&lt;br /&gt;
　今回の記事の中で「よく考えてみると」と何度も書いてますが、この手のソフトは自分の意図通りに動いているのかうまくいっていないのか結構悩まされます。最後の例でもそうですが、考えて納得して改良したあとにいきなり5手で負けたりするとさっぱり意味が分からなくなりました。でも、特別なアルゴリズムを使わなくても完全読み切りが出来るわけですから、将棋なんかに較べたら作り易いゲームではあると思います。今回、千日手回避のために他にもいろいろ試行錯誤したのでそれらの手法を使って将棋作りに活かしてみようと思っています。&lt;/p&gt;

</description>
                <link>http://happyclam.github.io/software/2014-10-04/arrange_line</link>
                <guid>http://happyclam.github.io/software/2014-10-04/arrange_line</guid>
                <pubDate>2014-10-04T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>三目並べ（tic tac toe）で遊んでみた</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;いろんなテストケース&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;以前作った三目並べのプログラム&lt;/a&gt;でいろいろ遊んでみました。&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;githubに公開&lt;/a&gt;しているので暇な人はソースをいじって試すこともできます。但し、短いソースとはいえ自分でコードを読んで編集する必要があります。もともとは対戦用プログラムとして作ったものですが、テスト用に9ヶ所の升目を順に取っていってその時の評価値を表示するように作った関数を使って、いろんなケースでプログラムの検証をしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NOUGHT = -1
CROSS = 1
DRAW = 0
MAX_VALUE = 9
MIN_VALUE = -9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　上記のように定数を定義しています。CROSSは×（バツ）NOUGHTは◯（マル）でCROSSが先手です。評価関数は先手勝ち（MAX_VALUE）、後手勝ち（MIN_VALUE）、引き分け（DRAW）の3値の内どれかを返すようになっています。&lt;br /&gt;
　テスト用の関数は先手から交互に1～9の升目を取っていって、その時に先読み関数から返ってくる評価値を順に画面に表示していくようになってます。三目並べはパスが無いので奇数手目は先手×で偶数手目は後手◯になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo@bar:~$ ruby play.rb 

 |1|2|3|
 |4|5|6|
 |7|8|9|
1手目: 1 評価値: 0
1手目: 2 評価値: 0
1手目: 3 評価値: 0
1手目: 4 評価値: 0
1手目: 5 評価値: 0
1手目: 6 評価値: 0
1手目: 7 評価値: 0
1手目: 8 評価値: 0
1手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　1手目に1の場所（先手は×）を取れば0の評価値が返ってきたという意味ですが、どこの場所を取っても評価値0が返ってきてます。どこの場所を取っても引き分けになると言うことを示していますが、これではプログラムがうまく動いているかどうかわかりません。初手に先手が5を取った局面から先読み開始してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|X|6|
 |7|8|9|
2手目: 1 評価値: 0
2手目: 2 評価値: 9
2手目: 3 評価値: 0
2手目: 4 評価値: 9
2手目: 6 評価値: 9
2手目: 7 評価値: 0
2手目: 8 評価値: 9
2手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　2手目に後手◯が奇数の場所1、3、7、9（隅）を取った場合の評価値はすべて0になっています。お互いに最善手を選択すれば引き分けになるということです。2手目に後手○が2、4、6、8の辺部分を取るとすべて最大値（9）の評価が返ってきています、その後双方が最善を尽くせば先手が勝つということです。最小値（-9）が返ってくれば後手が勝つという意味です。&lt;br /&gt;
　そういえば三目並べでは初手で真ん中を取って、相手が2手目で隅（角）以外の部分を取ると先手が勝つことを思い出しました。念のため確認してみましょう。&lt;br /&gt;
　初手で真ん中を取り、2手目で辺を取った場合と隅を取った場合を順に確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1手目5、2手目に辺（8）の場合：
       
 |1|2|3|
 |4|X|6|
 |7|O|9|
3手目: 1 評価値: 9
3手目: 2 評価値: 0
3手目: 3 評価値: 9
3手目: 4 評価値: 9
3手目: 6 評価値: 9
3手目: 7 評価値: 9
3手目: 9 評価値: 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　3手目に先手が2の場所を取った場合以外は先手が勝つ（評価値が9）となります。MIN-MAX法（αβ法）は互いに最善手を打つことが前提となっていますので、2手目で後手◯が辺を取った後、先手が最善手を打てば勝つことが出来るのですが、間違えて2の場所を取ると勝てないことを示しています。  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　ちなみに2手目に辺を取るとなぜ後手◯が負けるのかというと、先手が3手目に隅を取れば下図のように２ヶ所同時に、あと一つで揃う局面に出来るからです。後手は２ヶ所同時に防ぐことが出来ません。

|X| |O|
| |X| |
|X|O| |
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1手目5、2手目に隅（3）の場合：

 |1|2|O|
 |4|X|6|
 |7|8|9|
3手目: 1 評価値: 0
3手目: 2 評価値: 0
3手目: 4 評価値: 0
3手目: 6 評価値: 0
3手目: 7 評価値: 0
3手目: 8 評価値: 0
3手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　すべてのケースで引き分けになることを示していて、最初のテスト結果と符合しますので、一応プログラムは正常に動作しているようです。&lt;br /&gt;
　あと、&lt;a href=&quot;/software/2014-09-16/ab_method/&quot;&gt;前回の記事&lt;/a&gt;にも書きましたが、αβ法がうまく機能していれば最終的な評価値の結果がMIN-MAX法と一致するはずです。  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      if (temp_v &amp;gt;= value &amp;amp;&amp;amp; turn == CROSS) 
        value = temp_v 
        locate = i
#        break if threshold &amp;lt; temp_v
      elsif (temp_v &amp;lt;= value &amp;amp;&amp;amp; turn == NOUGHT)
        value = temp_v 
        locate = i
#        break if threshold &amp;gt; temp_v
      end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　上記のようにプログラム中の枝刈り部分のコード２行をコメントにして、上記のテスト結果と同じ結果が得られましたので枝刈りも正常に機能しているようです。ちなみに評価関数が呼び出される回数を数えて見たところ、すべての手を読み切るまでにMIN-MAX法では255,168回、αβ法では100,645回でした。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;ちょっと変わった三目並べ&lt;/h3&gt;
&lt;p&gt;　Twitter使っていると&lt;a href=&quot;https://androider.jp/official/app/4f0d853da0473562/&quot;&gt;「ちょっと変わった三目並べ Arrange Line」&lt;/a&gt;というアプリを見かけたのでルールを確認してみると、なんと今弄っている三目並べをほとんどそのまま流用出来そうじゃないですか？なんか神様から使命を授かったような気になったので作って見ました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Board.initializeに追加
    @c_q = Array.new
    @c_bk = Array.new
    @n_q = Array.new
    @n_bk = Array.new
#Board.initに追加    
    @c_q.clear
    @c_bk.clear
    @n_q.clear
    @n_bk.clear
#Boardクラスに追加
  def set(i, v)
    if self[i]
      raise &quot;Error!&quot;
    else
      self[i] = v
    end
    if v == CROSS
      @c_q &amp;lt;&amp;lt; i
      if @c_q.size &amp;gt; 3
        idx = @c_q.shift
        @c_bk.push([idx, self[idx]])
        self[idx] = nil
      end
    elsif v == NOUGHT
      @n_q &amp;lt;&amp;lt; i
      if @n_q.size &amp;gt; 3
        idx = @n_q.shift
        @n_bk.push([idx, self[idx]])
        self[idx] = nil
      end
    end
  end

  def unset(v)
    if v == CROSS
      if @c_bk.size &amp;gt; 0
        h = Hash[*(@c_bk.pop)]
        temp = h.each{|k, v| self[k] = v}
        @c_q.unshift(temp.keys[0])
      end
      idx = @c_q.pop
    elsif v == NOUGHT
      if @n_bk.size &amp;gt; 0
        h = Hash[*(@n_bk.pop)]
        temp = h.each{|k, v| self[k] = v}
        @n_q.unshift(temp.keys[0])
      end
      idx = @n_q.pop
    end
    self[idx] = nil
  end

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　評価関数や画面出力部分はまったく変更する必要は無く、Boardクラスに指し手を記憶するための配列を追加し、setメソッドとunsetメソッドを追加して、今まで&lt;code&gt;board[n] = CROSS&lt;/code&gt;等、配列に値を代入していたところを&lt;code&gt;board.set(n, CROSS)&lt;/code&gt;のように変更し、&lt;code&gt;board[n] = nil&lt;/code&gt;としていたところを&lt;code&gt;board.unset(CROSS)&lt;/code&gt;に変えるだけです。&lt;br /&gt;
　で、初手から読み切りさせて見たところ、敢えなくスタックオーバーフロー。でもこれは将棋でいうところの千日手になるケースがあるのだろうと思ったので、先読み手数を制限して9手読み、10手読みと試していきました。すると、10手読みのところまでは三目並べと同じように全部0の評価だったのですが、11手読みまで増やすと以下のような結果が出ました。  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|8|9|
1手目: 1 評価値: 0
1手目: 2 評価値: 9
1手目: 3 評価値: 0
1手目: 4 評価値: 9
1手目: 5 評価値: 0
1手目: 6 評価値: 9
1手目: 7 評価値: 0
1手目: 8 評価値: 9
1手目: 9 評価値: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　初手に偶数の場所つまり辺の部分に先手が着手すれば先手が勝つことが出来ると言ってます。普通の三目並べと違って真ん中を取るのはよくないようです。&lt;br /&gt;
　あと、10手読みまでは三目並べと同じように評価0ばかりだったと言っても、三目並べの場合は完全に読み切った上で引き分けになることを示しているのですが、この新しいルールの三目並べは先読み手数を制限しているので、制限手数内で先読みした限りでは勝負がつかないということを示しているだけです。&lt;br /&gt;
　次に辺の部分に初手を打てば勝てるということなのでその局面から先読み開始してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; |1|2|3|
 |4|5|6|
 |7|X|9|
2手目: 1 評価値: 9
2手目: 2 評価値: 9
2手目: 3 評価値: 9
2手目: 4 評価値: 9
2手目: 5 評価値: 9
2手目: 6 評価値: 9
2手目: 7 評価値: 9
2手目: 9 評価値: 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　全部先手勝ちとなりました。これで「ちょっと変わった三目並べ（Arrage Line）」というゲームは先手必勝のゲームであることが確認出来たと早合点して&lt;a href=&quot;https://twitter.com/SappierBoy/status/512377344582225920&quot;&gt;Twitterにも呟いてしまった&lt;/a&gt;んですが、千日手（同じ手の繰り返しで局面が進まない状態）に対応していないのでなんとも言えません。どうもこのゲームは互いに最善手を打ちつづけると千日手になるような気もしますが、それを証明するのは結構難しそうです。&lt;br /&gt;
　本来の三目並べやオセロゲームは指し手が盤上を埋めていき、選択肢がだんだん減っていくので読みやすくなっていきますが、このArrangeLineや将棋は盤上のスペースを埋めていくわけでは無いので、先読みプログラムを作る方は大変です。結局、前回の記事同様先読みプログラム作りの大変さを再認識する結果になってしまいました。おもしろい題材なのでArrangeLineについてはまた何か発見があれば記事を書いてみようと思います。&lt;/p&gt;

&lt;hr /&gt;

</description>
                <link>http://happyclam.github.io/software/2014-09-23/tictactoe_arrange</link>
                <guid>http://happyclam.github.io/software/2014-09-23/tictactoe_arrange</guid>
                <pubDate>2014-09-23T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>MIN-MAX法とαβ法</title>
                <description>&lt;h3 id=&quot;min-max&quot;&gt;MIN-MAX法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/tree_min-max.png&quot; alt=&quot;min-max法&quot; style=&quot;width: 800px; vertical-align:middle;&quot; /&gt;
　MIN-MAX法とは、オセロゲームなどのある局面で先手、後手、どちらが有利か判断する評価関数を用意し、先手、後手が互いに最善手を打つと仮定して先読みを行うアルゴリズムです。先手をプラス方向の値（MAX値）後手をマイナス方向の値（MIN値）で評価することが多いようです。&lt;br /&gt;
　上の図はオセロゲームで3手読みをする場合の例ですが、◯図形はオセロの一局面（ノード）で□内の数字が3手目を打ったときの評価値になります。3手目と書いてあるノードは先手が打つことが出来るすべての手を順番に評価していくためのループで、2手目となっているノードが後手が打つことが出来るすべての手を順番に評価していくためのループです。実際のプログラムではこのツリー構造を左から右の順に局面を評価していくことになります。&lt;br /&gt;
　全体図は1手目を先手が打った場合に後手が2手目を打つことが可能な手が2通りあり、その後先手が打てる手がそれぞれ3通り、2通りあることを表しています。まず左側のtreeを見ていくと、3手目に先手が打った局面で評価関数を呼ぶと15、22、-5という3つの評価値が得られたということです。で、先手は自分にとって最善手である一番評価値が高い22の局面を選び、取りあえずその評価値と指し手を記憶しておきます。次のノードで同様に3手目まで手を進めて14、25、9、33という4つの評価値を得て先手が選んだ最大値33と先ほどの評価値22を比較して、後手は自分に取って最善手である小さい方の22を選ぶという具合です。先手（3手目）では最大値、後手（2手目）では最小値を選択するというやり方で進めて、評価値が18という左側のtreeの2手目の評価が完了します。次に、右側のtreeでも先手（3手目）は最大値、後手（2手目）は最小値を選び-11という評価値が残ります。最終的には18と-11を比較して先手は大きい方の18を選び、1手目の先手の評価が完了します。&lt;br /&gt;
　最終的に指し手を決めるまでに、3手目の局面の数の分だけ評価関数を呼び出したことになるので、1手目の評価が完了するまでに14局面評価したことになります。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;αβ法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/tree_ab-method.png&quot; alt=&quot;αβ法&quot; style=&quot;width: 800px; vertical-align:middle;&quot; /&gt;
　αβ法はMIN-MAX法と同じ結果を得られるにもかかわらず、局面を枝刈りすることで時間短縮が出来るというすばらしいアルゴリズムです。なぜ局面の枝刈り（評価の回数を減らす）をしながら同じ結果が得られるのか見ていきましょう。&lt;br /&gt;
　まずMIN-MAX法と同様に左の3つの評価値から22という評価値が得られます。この22を基準値として読み進めると14、25という評価値を得ますがこの25という評価値を得た時点で、このノードは選ばれないことがわかります。なぜなら一つ上の後手のノードでは常に最小値を選ぶからです。この先読み進めて25より大きい評価値を得られたとしても一つ上の後手のノードで、22より大きな値が選ばれることはないので、ここで読みを打ち切っても問題ない（MIN-MAX法と同様の結果が得られる）わけです。これをβカットと言うそうです。その後同じく22を基準値として、次のノードに移り18という評価値を得ますが、18は22より小さいのでそのまま読み進みます。そして18と-12の大きい方である18が選ばれ、後手のノードで18と基準値の22を比較し小さい方の18が選ばれます。これで2手目の候補手が一つ決まりました。&lt;br /&gt;
　次に右サイドのtreeに移りますが、1手目の候補手から読み直すので、基準値は無く新たに末端ノードの3手目を順に評価することになります。得られた8と16を比較して先手（3手目）では最大値である16が選ばれます。16という後手の候補手が一つ得られたわけですが、後手の候補手はより小さい評価値が選ばれるわけですから、今のノードから分岐する3手目をいくら読み進んでいっても16以上になることはないということがわかります。そして一つ上の1手目の先手のノードでは先程の評価値18と比較して大きな方が選ばれることが分かっているわけです。つまり18より小さい評価値が後手（2手目）の候補手に一つでも現れた時点で、この後手のノードから分岐する先の手は読む必要がないことがわかります。これをαカットと言うそうです。ということで先程の18と今読みを打ち切った16を比較して、MIN-MAX法と同じ18が選ばれます。&lt;br /&gt;
　この例ではMIN-MAX法と比較して評価関数を呼び出す回数を5回減らすことが出来ただけで、それほど有り難みが伝わらないかもしれませんが、例えば一局面で選択できる手が3手だったとして3手先まで読むとMIN-MAX法だと&lt;script type=&quot;math/tex&quot;&gt;3^3&lt;/script&gt;回（27回）評価関数を呼ぶことになりますが、評価する局面の順番が理想的な場合αβ法だと&lt;script type=&quot;math/tex&quot;&gt;3^\frac{3}{2}&lt;/script&gt;回（約6回）で済むそうです。&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;前回記事&lt;/a&gt;で紹介した&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;三目並べのプログラム&lt;/a&gt;の例の場合、まさにこれぐらいの高い効果が得られたと思います。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;オセロと将棋の違い&lt;/h3&gt;
&lt;p&gt;　今までにいろんなプログラミング言語でオセロを作った経験があるのですが、オセロを作った同じやり方で三目並べを作るとうまく出来ませんでした。三目並べを作った顛末は&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;ここ&lt;/a&gt;に書いていますが、どのような問題があったかというと、オセロの局面の評価は末端ノード（葉）で行うため、三目並べで同様の作り方をすると途中でラインが揃って勝負がついているにも関わらず先読みを続けてしまうという不都合が起こり、間違った結果が返ってきます。各ノードで局面の評価を先にしてから先読みを続けるかどうか判断するという作り方にしなければなりません。その違いに気づくまで私は結構悩みました。&lt;br /&gt;
　将棋も三目並べと同じでゲームがいきなり終了する（詰み）ことがあるので、有限手数先を読みそこで評価する作り方をしているとあり得ない局面を読んでいて間違った評価をすることになります。では、オセロはゲームがいきなり終了することは無いのかというとそうでもなく、頻度は低いと思いますがオセロにもパーフェクトで勝負がつくケースというのがあるので、その対策は必要です。でも自分がオセロプログラムを作った経験から言うと、特にパーフェクト負けへの対応をしていなくても自然と回避されるケースが多いと思います。巷に出回っているオセロのソフトも偶々うまくいっているというケースが多いのではないでしょうか。&lt;br /&gt;
　もう20年以上前のことですが、自分が作ったオセロプログラムがどれほどの強さなのか他のプログラムと手動で対戦させていた頃、とても強くて自分が作ったソフトは歯が立たないフリーソフトがあったんですが、そのソフトに自分の作ったソフトが何度か序盤（オセロ盤に打つ場所がいっぱい残っている状態）でパーフェクト勝ちをしたことを思い出しました。その強いオセロソフトはパーフェクト負けへの対応をしていなかったのでしょう。三目並べを作って見るまではオセロも三目並べも将棋も同じようなゲームだと思っていたのに、そんな違いがあることに今更ながら驚きました。ちょっと大袈裟かもしれませんが自分にとっては新発見でした。  &lt;/p&gt;

</description>
                <link>http://happyclam.github.io/software/2014-09-16/ab_method</link>
                <guid>http://happyclam.github.io/software/2014-09-16/ab_method</guid>
                <pubDate>2014-09-16T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>将棋はやっぱり深く読まなくてはダメ</title>
                <description>&lt;h3 id=&quot;tictactoe&quot;&gt;三目並べ（tictactoe）作成後&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;前回の記事&lt;/a&gt;で自分で作った将棋ソフトが弱い原因を確認するために三目並べ（tictactoe）プログラムを作ったことを書きましたが、一応その後の結果を書いておこうと思います&lt;br /&gt;
　&lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;三目並べプログラム&lt;/a&gt;で先読み関数には問題ないと確認出来たので、将棋プログラムの先読み部分もそれと同じように修正してみました。将棋の前にオセロプログラムも作って確認したのですがここではその話は置いておきます。それと、三目並べと同じように修正したと言っても将棋には盤上の駒を動かす場合と持ち駒を打つ場合があったり、相手の駒を取ったりするので、三目並べと同じにはならないのですが、どういうパラメータを与えるかとかどこで評価関数を呼んでどこで再帰関数から抜けるのかとかそういう部分を同じにしたということです。将棋プログラムでは、評価関数を呼び出す場所を先読み再帰関数の先頭にしてみたりforループの中にしたり、評価部分の等号・不等号の違いや評価する局面の枝刈りをする場所変えたりいろいろ試行錯誤しているうちに正確に先読み・枝刈りが出来ているかどうかわからなくなってきたので、三目並べで確認したかったんです。&lt;br /&gt;
　この類のゲームを作ったことがある人なら分かると思いますが、自分の書いたプログラムが膨大な局面の評価値のtree構造をどのように遷移して結論を出したのか確認するのは結構面倒です。評価の遷移を出力して確認するためのテストコードを書くのが王道かもしれませんが、それより簡単そうで面白そうなので三目並べを作って確認し、それと同じ作りにしてしまおうということです。&lt;br /&gt;
　で、結論はどうだったかというと、先読み部分を三目並べと同じように変更しても将棋ソフトは全然強くなりませんでした。結局、先読み部分には大きな問題はなく、ソフトが弱い原因は先読み手順以外の部分（評価関数や読む深さ）にあるということがはっきりしたわけです。今の評価関数は駒の重み（飛車=85点、竜=100点、玉=9999点、金=50点、歩=10点…等）の合計値を使って局面を評価しているだけなので、いい結果が望めないのは当然といえばそうなのですが、&lt;a href=&quot;/project/2014-08-05/tictactoe/&quot;&gt;前回の記事&lt;/a&gt;で書いたように、駒の重みだけの評価関数でオセロを作った場合には非常に強いソフトになるのに将棋だとなんでこんなに弱いのか納得出来なかったので念のため確かめたって感じです。&lt;br /&gt;
　仕方がないので疑問手を指した局面で、何でこんな手を指すのか地道にコードを追っていって調べたところ何となくオセロとの違いが分かってきましたので、実際にソフトが指した手を示しながら説明したいと思います。&lt;br /&gt;
　というか本当に強い将棋ソフトを作りたいのなら、今のご時世ならソースコードが公開されているらしいBonanzaのソースコードを調べてそれに倣うのが一番手っ取り早いと思いますが、それでは面白く無いのであくまで自己流でやってます。  &lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;テスト局面の例&lt;/h3&gt;
&lt;p&gt;　本将棋もどうぶつ将棋もプレイ出来るような作りにしているのですが、本将棋（９×９）だと確認が大変なのでミニ将棋（５×５）で確認しました。  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ケース１&lt;br /&gt;
&lt;img src=&quot;/images/scr1-1.png&quot; alt=&quot;局面1-1&quot; /&gt;&lt;br /&gt;
　先手＝ソフト、後手＝人間で上の図の初期配置から先読みをせずに、というか１手先を読む設定でソフトに初手を指させると「１二飛」と指します&lt;br /&gt;
&lt;img src=&quot;/images/scr1-2.png&quot; alt=&quot;局面1-2&quot; /&gt;&lt;br /&gt;
　ソフトは自分が一手指した局面で評価（自分の駒の重みの合計点ー相手の駒の重みの合計点）を計算しますので、この局面では歩を一枚得をした状態なので自分が有利と判断します。次の一手で後手に飛車を取り返されて大損するにもかかわらずです。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ケース２&lt;br /&gt;
局面２ー１:&lt;br /&gt;
&lt;img src=&quot;/images/scr2-1.png&quot; alt=&quot;局面2-1&quot; /&gt;&lt;br /&gt;
　先手＝ソフト、後手＝人間で、既に後手有利な局面ですが、ここで５一の飛車を使うために４三角と指します。&lt;br /&gt;
局面２ー２:&lt;br /&gt;
&lt;img src=&quot;/images/scr2-2.png&quot; alt=&quot;局面2-2&quot; /&gt;&lt;br /&gt;
　もし、ソフトが角を取れば４五飛車の一手詰という仕掛けです。3手先を読む設定にしたソフトで、この局面で指させると下図のように堂々と４三金と角を取ってしまいます。&lt;br /&gt;
局面２ー３:
&lt;img src=&quot;/images/scr2-3.png&quot; alt=&quot;局面2-3&quot; /&gt;&lt;br /&gt;
　ソフトからすると４三金（1手目）、４五飛（2手目）と進んでも４五同玉（3手目）とすれば自分が有利と計算することになるからです。&lt;br /&gt;
局面２ー４:
&lt;img src=&quot;/images/scr2-4.png&quot; alt=&quot;局面2-4&quot; /&gt;&lt;br /&gt;
　４五同玉と取った時点の駒の重みの合計点は飛車の分が加算されて先手のソフト側の点数がかなり高くなります。この飛車を取ることが出来るというところまで読んで「局面２ー２」の時点で４三金と角を取る手を選んでしまうわけです。その次の一手で後手に４五同馬と玉を取られるにもかかわらずです。ソフトを4手先を読む設定にすれば、その先で自玉が取られて合計点が大幅に減ることが分かるので「局面２ー２」で４三金とは指しません。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;オセロとの違い&lt;/h3&gt;
&lt;p&gt;　ケース１では飛車が取られる、ケース２では玉が取られるという、序盤であれ終盤であれ一手違うだけで評価値が激変するのが将棋のオセロに無い特徴だと思います。将棋以外のゲームでも勝ちか負けかという局面では評価値が激変するのは当然ですが、将棋は一手毎に駒を打つ場所が少なくなるオセロや囲碁と違って、徐々にゲームの終わりが近づいているわけではありません。いつ終了するか（いつ玉が詰まされるか）わかっていないので常に局面を厳しく評価する必要があるのです。オセロの評価関数は序盤でいい加減な評価関数を使用していたとしても、ゲームの終盤で残り15手とか20手になったときに最後まで読み切ることが可能なので強いソフトが比較的簡単に作れるのでしょう。三目並べも同様です。将棋の場合、読み切りと言えば詰みを探すということになりますが、初手から詰みを探しても時間の無駄ですし、オセロのように一手毎に終わりが近づいているわけではないので、残り何手になったら詰みを探すという作りにも出来ません。常に局面を正確に評価し、詰みがある局面ではそれを逃さないような作りにする必要があります。&lt;br /&gt;
　それともう一つオセロや三目並べは、手が進むに連れて徐々に手の選択肢が少なくなるので深く読むことが容易になっていきますが、将棋にはそういうことがありません。むしろ持ち駒が増えると読む手が増えていきます。&lt;br /&gt;
　ということで、まずはもっと深く読むことが必要だと思うので、クラスの構成やデータ構造も見直して作り直そうかと思っています。駒の働きや玉の固さなども考慮した凝った評価関数を作るとなると、結局速度が必要になるのでデータ構造も出来るだけ単純にすべきなのですが、そもそもRubyで実効速度は期待出来ないと思っていたし、ミニ将棋ならオセロより駒の数も少ないし特に凝ったことしなくても自然と強いソフトになるだろうなんて甘い見通しだったのがいけなかったようです。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;おまけ&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://sdin.jp/browser/board/55shogi/&quot;&gt;SDIN将棋のサイト&lt;/a&gt;で自分が作ったソフトとCPU対戦したところ、4手読みの設定でいい加減な評価関数でもレベル２には常に勝てるようです。レベル３には勝てませんので、これに勝つことを当面の目標にしてみます。&lt;br /&gt;
　それと、つい最近まで開発の動機なども含めてgithubのwikiに書いて「Shoes de shogi」という名前でgithubで公開していたのですが、とりあえずもう少し強くできるまで一時的に削除することにしました。&lt;/p&gt;

</description>
                <link>http://happyclam.github.io/software/2014-09-09/pre_shogi</link>
                <guid>http://happyclam.github.io/software/2014-09-09/pre_shogi</guid>
                <pubDate>2014-09-09T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>三目並べ（tictactoe）</title>
                <description>&lt;p&gt;Project: 「&lt;strong&gt;三目並べ&lt;/strong&gt;」: &lt;a href=&quot;https://github.com/happyclam/tictactoe_ruby&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;開発の動機&lt;/h3&gt;
&lt;p&gt;　Ruby用のGUI開発ツールShoesを使って一通り機能を備えた将棋ソフトを作ってみたのですが、思っていた以上に弱い。大昔にオセロのソフトを作ったことがあるのですが、min-max法とαβ法を使えば普通の人では勝てないぐらいのものが簡単に作れました。オセロでは四隅を取ると有利になるので、隅のコマは点数を高くして、その隣の位置は点数を低くするという、コマを置く盤面の位置に重み付けすることで局面を評価するよくある評価関数を使えば十分でした。&lt;br /&gt;
　だから将棋の場合もそれぞれの駒に重み付けをして評価関数を作れば、オセロに比べると読む局面の数が多くなるとはいえ、それなりに強いものが出来ると思っていたのにあまりにも弱かったのです。そこで評価関数は置いといて局面の先読み部分がうまくいってるのか確認するために、まずはより単純なゲームである三目並べで確認しようと思ったのが作成のきっかけです。三目並べ（tictactoe）なら初手からゲーム終了まで読みきれるので先読み関数に問題がないかどうか判断しやすいと思ったからです。  &lt;/p&gt;

&lt;h3 id=&quot;min-max&quot;&gt;min-max法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  #先手×は最大値、後手○は最小値を選択するように再帰しながら局面を先読み
  def lookahead(board, turn, cnt)
    if turn == CROSS
      value = MIN_VALUE
    else
      value = MAX_VALUE
    end
    locate = nil
    board.each_with_index {|b, i|
      next if b
      board[i] = turn
      temp_v = evaluation(board)
      teban = (turn == CROSS) ? NOUGHT : CROSS
      if (temp_v != MAX_VALUE &amp;amp;&amp;amp; temp_v != MIN_VALUE &amp;amp;&amp;amp; cnt &amp;lt; SIZE - 1)
        #指定した深さまで再帰呼出し
        temp_v, temp_locate = lookahead(board, teban, cnt + 1)
      end
      board[i] = nil
      #先手×の番と後手○の番で、同じ深さでの最小、最大の評価値をvalueに保存
      if (temp_v &amp;gt; value &amp;amp;&amp;amp; turn == CROSS) || (temp_v &amp;lt; value &amp;amp;&amp;amp; turn == NOUGHT)
        value = temp_v 
        locate = i
      end
    }
    #同じ深さでの最小、最大の評価値を返す
    return value, locate
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;αβ法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;min-max法に、親局面の評価値を子局面に伝えるための引数を追加&lt;/li&gt;
  &lt;li&gt;引数で渡された親局面の評価値と現局面を比較して、現局面が選択されることがないことがわかったら、先読みを中断してreturnする（αカットとβカット）&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  #現局面の評価値を子局面に渡しながら再帰関数で局面を先読み
  def lookahead(board, turn, cnt, threshold)
    if turn == CROSS
      value = MIN_VALUE
    else
      value = MAX_VALUE
    end
    locate = nil
    board.each_with_index {|b, i|
      next if b
      board[i] = turn
      temp_v = evaluation(board)
      teban = (turn == CROSS) ? NOUGHT : CROSS
      if (temp_v != MAX_VALUE &amp;amp;&amp;amp; temp_v != MIN_VALUE &amp;amp;&amp;amp; cnt &amp;lt; SIZE - 1)
        temp_v, temp_locate = lookahead(board, teban, cnt + 1, temp_v)
      end
      board[i] = nil
      #先手×の番
      if (temp_v &amp;gt; value &amp;amp;&amp;amp; turn == CROSS) 
        value = temp_v 
        locate = i
        #閾値を上回ったら先読み中止
        return value, locate if threshold &amp;lt; temp_v
      #後手○の番
      elsif (temp_v &amp;lt; value &amp;amp;&amp;amp; turn == NOUGHT)
        value = temp_v 
        locate = i
        #閾値を下回ったら先読み中止
        return value, locate if threshold &amp;gt; temp_v
      end
    }
    #同じ深さでの最小、最大の評価値を返す
    return value, locate
  end

end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;※min-max法に僅かなコードを追加しただけで素晴らしい効果が得られました。&lt;a href=&quot;http://www.vaio.sony.co.jp/Products/P1/spec_vom1.html&quot;&gt;vaio type p (VGN-P90S)&lt;/a&gt;という非力なPCで比較したところ、単なるmin-max法で完全読み切りに３０秒ほどかかったのに、αβ法なら５秒で完了しました。評価関数が、勝ち、負け、引き分けの３値しかない単純なものだったせいもありますがすごいです。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;検証と意外だったこと&lt;/h3&gt;
&lt;p&gt;　先読みがうまく機能しているかは、初手をどこに打ってゲーム開始しても引き分けという結果が返ってくることや、先手・後手でそれぞれ何度か三目並べで遊んでみて確認した程度ですが、それで十分でしょう。&lt;br /&gt;
　でも作ってみて意外だったのは初手から完全読み切りするわけだから、ソフトに初手を指させたら当然真ん中に×をつける（打つ？指す？）と思っていたのに真ん中には打ってこなかったことです。人間ならすぐに一番勝つ可能性が高い真ん中を取るはずですが、ソフトは双方が最善手を指せば引き分けになることを読み切っているので、結局どこに打っても同じと判断するわけです。評価関数が勝ち、負け、引き分けの三値しか返さない関数なので、初手に真ん中に打てばラインを揃える可能性が一番高いとはいえ、引き分けには違いないので区別しないのだと一応納得しました。&lt;br /&gt;
　念の為、真ん中は２点、隅は１点、その他は０点という場所による重み付けをしてその点数による評価関数を作って、それを使えば真ん中に打つことは確認しましたが、そんな評価関数では当然弱いソフトになりました。それ以外にも何とか初手に真ん中を選択しながら、強い評価関数はどうすればいいか考えてみましたが、シンプルでいい方法は思いつきませんでした。&lt;br /&gt;
　結局オセロでも将棋でもそうですが、局面の形成判断をする評価関数と読み切り用の評価関数は分けて作るのがいいのかもしれません。&lt;/p&gt;

</description>
                <link>http://happyclam.github.io/project/2014-08-05/tictactoe</link>
                <guid>http://happyclam.github.io/project/2014-08-05/tictactoe</guid>
                <pubDate>2014-08-05T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>BlueToothマウス</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;携帯する気は無いが、マウスのケーブルは細い方がいい&lt;/h3&gt;
&lt;p&gt;　まだ一年程しか使っていなかったマウスが壊れました。ケーブルが平べったいタイプでUSB端子をマウスの中に収納できるタイプのもの。ケーブルが巻き取れるタイプのものは携帯用の小さなマウスばかりですが、USB端子も本体に収納出来るようになっているため比較的マウス本体も大きめの作りでまぁまぁ気に入っていたのに短い命でした。このタイプのマウスでもう一つお気に入りのマウスを持っているのですが、それはビックカメラ製の今はもう製造していないであろう珍しいもの（だと思います）。10年以上前に新横浜のビックカメラで買ったものですが、ELECOM等のOEM製品だと思いますが、どういう経緯で自社ブランドで販売したのか知りませんが、確かにビックカメラ製と銘打っていたと記憶しています。あの時まとめて買いだめしておけばよかったと思います。&lt;br /&gt;
&lt;img src=&quot;/images/biccamera_mouse.png&quot; alt=&quot;ビックカメラ製マウス&quot; style=&quot;float: left;&quot; /&gt;
　大きいマウスの方が使いやすいのですが、ケーブルが太いと、わずかではあるけどケーブルに操作を持っていかれる時があるので好きではありません。だからと言ってケーブルの無い無線方式だと何となく信頼できないというか、安心できないというかイザというとき困るんじゃないかとか、CPU切替器も使っているのでちゃんと動くかどうかわからないという不安が先走って、未だに無線方式のものは使わずにいます。マウスに関してはキーボードほど使い勝手にこだわりは無いのでそろそろ無線を試してもいいかもと思いながらも、あくまで細いケーブルの大きなマウスを求めていろんな店舗を見て回ることにしました。  &lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;予定していた行動とまったく違うことすることってありますよね&lt;/h3&gt;
&lt;p&gt;　細く平たいケーブルのマウスか、それが無ければ無線マウスを買うつもりで家を出たのに、家に持ち帰ったのはBuffalo製の&lt;a href=&quot;http://buffalo.jp/product/input/mouse/bsmbb17/&quot;&gt;BlueToothマウス&lt;/a&gt;でした。細いケーブルのマウスは携帯用の小さいものしか無く、目当てのものが売っていなかったのが最大の原因ですが、無線のマウスは専用のレシーバが必要なのが何となく嫌で躊躇していたところにそれ以外の選択肢が目についてしまったのです。プログラマっていうのはXXX社製専用というのが何となく美しくないと感じてしまうものです、そう、縛られるのが嫌いなのでしょう。BlueToothマウスもBlueTooth機能を備えていないPCで使う場合はドングルというレシーバが必要なわけですが、マウスと同じメーカーでなくても使えます。マウスと同じメーカーの対になったレシーバしか使えないという不自由さが気に入らないのでしょう（家でしか使わないならそれで十分なのに…）。そういえば昔買ってほとんど使わずじまいのドングルが家に何個かあるなぁと思い出してしまったことも購入に踏み切った原因だと思います。  &lt;/p&gt;

&lt;h3 id=&quot;ubuntu1204&quot;&gt;Ubuntu12.04では使えない？&lt;/h3&gt;
&lt;p&gt;　家では主にUbuntu12.04を使っているのですが、そのままでは認識すらしてくれませんでした。Windows7のノートPCでは２つのドングル（&lt;a href=&quot;http://www.planex.co.jp/product/bluetooth/bt-microedr2x/&quot;&gt;BT-MicroEDR2X&lt;/a&gt;、&lt;a href=&quot;http://www.planex.co.jp/product/bluetooth/bt-01ude.shtml&quot;&gt;BT-01UDE&lt;/a&gt;）で確認したので故障ではありません。dbusを最新のものに入れ替えたらデバイス検索でBSMBB17を検出してはくれたものの動作しませんでした。そこで以前から更新しようと思っていながら放ったらかしにしていたUbuntu14.04へのアップグレード（do-release-upgradeコマンド一発）をやってみたらすぐに認識することが出来、使えました。メデタシメデタシ。って結局マウスが壊れたおかげで以前から懸案だったUbuntuアップグレード作業をすることが出来たことが収穫って感じです。マウスが壊れたところから神様のお導きだったのかもしれません。&lt;br /&gt;
&lt;a href=&quot;http://buffalo.jp/product/input/mouse/bsmbb17/&quot;&gt;&lt;img src=&quot;/images/bsmbb17_mouse.png&quot; alt=&quot;BSMBB17&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
　で、肝心のBlueToothマウスの使い勝手ですが、頻繁に動作が引っかかる感じでとても使い続ける気にはなりませんでした。自分的にはBlueToothマウスはまだまだ実用には堪えられないって感じです。あくまでlinuxで使う場合の話ですが…。結局マウスはしばらく買わずに、とっておきのビックカメラ製のものを使うことにします。チャンチャン。&lt;/p&gt;

</description>
                <link>http://happyclam.github.io/hardware/2014-07-12/bt_mouse</link>
                <guid>http://happyclam.github.io/hardware/2014-07-12/bt_mouse</guid>
                <pubDate>2014-07-12T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>production環境でjQueryが発動しない</title>
                <description>&lt;h3 id=&quot;deployment&quot;&gt;自宅サーバーにdeployment&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/project/2014-05-30/tweetwatch&quot;&gt;TweetWatch&lt;/a&gt;がとりあえず完成したので、自鯖（Apatch）で動かしてみたらjQueryの一部（画面描画時&lt;code&gt;$(document).ready()&lt;/code&gt;の処理だけ）が上手く動かなかったので動くようになったまでの顛末を書きます（Rails 4.0.2, ruby 2.0.0p353）。&lt;br /&gt;
コードは以下の通りです&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#app/assets/javascripts/users.js
$(document).ready(function(){
    $.ajax({
        url: &#39;/tweets/check&#39;, 
        data: {},
        dataType: &quot;script&quot;
    }).done(function(data, status, xhr) {
    }).fail(function(xhr, status, error) {
        alert(&#39;Error Occured(&#39; + error + &#39;)&#39;);
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;処理の内容はあまり関係ないと思いますが、jQueryからcontrollerのメソッドを呼び出し、サーバースクリプトが動いているかどうかをチェックして画面にstatusを表示する処理をしています。このusers.jsがdevelopment環境では動くのにproduction環境では動かないという現象に悩まされました。動くようになるまでに辿った作業を順に箇条書きにしてみると以下のようになります。  &lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;p&gt;1. Apache+Passenger環境でうまく動かないので、以下の設定でwebrickでproduction環境を試す。特にwebrick用の設定とも言える&lt;code&gt;serve_static_assets = true&lt;/code&gt;がdevelopment環境との大きな違い&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
    #config/environments/production.rb
    config.assets.compile = false
    config.assets.js_compressor = :uglifier
    config.serve_static_assets = true
    config.assets.digest = true
    config.assets.debug = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rake assets:precompile RAILS_ENV=production&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;rails s -e production&lt;/code&gt;&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;p&gt;2. 変化が無かったのでjquery-turbolinks gemを追加してみる&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
    #Gemfile
    gem &#39;jquery-turbolinks&#39;  &amp;lt;- 追加
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    #app/assets/javascripts/application.js
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require users.js
//= require turbolinks
//= require jquery.turbolinks     &amp;lt;- 追加
//= require highcharts/highcharts
//= require highcharts/highcharts-more
//= require highcharts/highstock
//= require_tree .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rake assets:precompile RAILS_ENV=production&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;rails s -e production&lt;/code&gt;
&lt;/p&gt;
※&amp;lt;a href=https://github.com/kossnocorp/jquery.turbolinks/blob/master/README.md&amp;gt;jquery-turbolinksのドキュメント
&lt;/dd&gt;
&lt;br /&gt;
&lt;dt&gt;&lt;p&gt;3. jquery-turbolinks gemを追加してもダメだったので、今度は逆にturbolinksを無効にしてみる&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
    #Gemfile
#    gem &#39;turbolinks&#39;         &amp;lt;- コメント化
#    gem &#39;jquery-turbolinks&#39;  &amp;lt;- コメント化
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
    #app/assets/javascripts/application.js
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require users.js
//= require turbolinks            &amp;lt;- この行を削除
//= require jquery.turbolinks     &amp;lt;- この行を削除
//= require highcharts/highcharts
//= require highcharts/highcharts-more
//= require highcharts/highstock
//= require_tree .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    #app/views/layouts/application.html.erb
    #変更前
  &amp;lt;%= stylesheet_link_tag    &quot;application&quot;, media: &quot;all&quot;, &quot;data-turbolinks-track&quot; =&amp;gt; true %&amp;gt;
  &amp;lt;%= javascript_include_tag &quot;application&quot;, &quot;data-turbolinks-track&quot; =&amp;gt; true %&amp;gt;
    #変更後
  &amp;lt;%= stylesheet_link_tag    &quot;application&quot;, media: &quot;all&quot; %&amp;gt;
  &amp;lt;%= javascript_include_tag &quot;application&quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rake assets:precompile RAILS_ENV=production&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;rails s -e production&lt;/code&gt;&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;p&gt;4. turbolinksは関係なかったので、関係ないと思ったけど今度はcoffee scriptに変えてみる&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;span&gt;jqueryとturbolinks両イベント対応の書き方&lt;/span&gt;
&lt;pre&gt;&lt;code&gt;
#app/assets/javascripts/user.js.coffee
$(document).on &#39;ready page:load&#39;, -&amp;gt;
  url = &#39;/tweets/check&#39;
  dfd = $.ajax
    url: url
    format: &#39;script&#39;
    data: {}
    method: &#39;get&#39;
  promise = dfd.promise()
  promise.done((data, status, xhr) -&amp;gt;
  )
  promise.fail((xhr, status, error) -&amp;gt;
    alert(error)
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;span&gt;jqueryイベントとturbolinksイベントを分けた書き方&lt;/span&gt;
&lt;pre&gt;&lt;code&gt;
#app/assets/javascripts/user.js.coffee
ready = -&amp;gt;
  url = &#39;/tweets/check&#39;
  dfd = $.ajax
    url: url
    format: &#39;script&#39;
    data: {}
    method: &#39;get&#39;
  promise = dfd.promise()
  promise.done((data, status, xhr) -&amp;gt;
  )
  promise.fail((xhr, status, error) -&amp;gt;
    alert(error)
  )

$(document).ready(ready)
$(document).on(&#39;page:load&#39;, ready)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rake assets:precompile RAILS_ENV=production&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;rails s -e production&lt;/code&gt;&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;p&gt;5. どっちのcoffee scriptでもダメなので、こんどは正常に動作しているdevelopment環境の設定をproduction環境と同じにして確認。&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
    #config/environments/development.rb
    config.assets.compile = false
    config.assets.js_compressor = :uglifier
    config.serve_static_assets = true
    config.assets.digest = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;デフォルトでは書かれていない上記設定をdevelopment環境の設定ファイルに追加して&lt;code&gt;rails s -e development&lt;/code&gt;すると、めでたく？production環境と同じくページload時のjqueryだけが発動しない現象が再現しました。結局config.assets.compileがtrueかfalseかで動作が変わるようです。念のためdevelopment環境でconfig.assets.compileの値だけを書き換えて現象の発生の有無を確認しました。&lt;br /&gt;
　でも本番（production）環境でconfig.assets.compile = trueにして運用することは、重くなるので普通はしないと思いますし、結局config.assets.compile = falseのままではturbolinksの有効・無効に関係なく、このjqueryを発動させることは出来ませんでした。
&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;p&gt;6. 何か方法はないかとテンプレートファイルに直接jqueryを直書きしてみたところ&lt;/p&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;pre&gt;&lt;code&gt;
#app/views/users/show.html.erb
&amp;lt;%= javascript_tag do %&amp;gt;
$(document).ready(function(){
    $.ajax({
        url: &#39;/tweets/check&#39;, 
        data: {},
        dataType: &quot;script&quot;
    }).done(function(data, status, xhr) {
    }).fail(function(xhr, status, error) {
        alert(&#39;Error Occured(&#39; + error + &#39;)&#39;);
    });
});
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでdevelopment環境でもproduction環境でもページ読み込み時のjqueryが正常に動作しました。&lt;br /&gt;
config.assets.compile = falseでdevelopment,production両方の環境で動きます。いろいろ環境を弄りましたが元の環境からjqueryをテンプレートに直書きするように変えるだけで他は変更しなくてよかったみたいです。turbolinksが有効でも無効でも大丈夫です
&lt;/p&gt;
&lt;/dd&gt;

&lt;/dl&gt;

&lt;p&gt;&lt;em&gt;結論&lt;/em&gt;&lt;br /&gt;
「$document.readyイベントを使うjqueryが動作しない時は、テンプレートに直書きしてみる。」&lt;/p&gt;

&lt;p&gt;　※ネットの情報を漁っていると、jquery-turbolinks gemを使えば解決するというものが多いのですが、document.readyイベントに関してはそういうわけにはいかないようです。&lt;/p&gt;

</description>
                <link>http://happyclam.github.io/programming/2014-07-07/rails_env</link>
                <guid>http://happyclam.github.io/programming/2014-07-07/rails_env</guid>
                <pubDate>2014-07-07T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>ツイートを監視して集計する（client側）</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;サーバースクリプトの状態遷移&lt;/h3&gt;
&lt;p&gt;　言うまでもなくclient側と言ってもWebサーバ上で動いているわけなのでユーザから見ればサーバーとして機能しているわけですが、TwitterAPIを使ってデータをDBに保存するサーバースクリプトに対してclient側ということです。&lt;br /&gt;
state_machine gemを利用してサーバースクリプトの状態を管理しています。
&lt;img src=&quot;/images/tweetwatch.png&quot; alt=&quot;状態遷移図&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;状態遷移表&lt;/em&gt;  &lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;status\method&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;start&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;store&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;stop&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;停止中(down)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;待機中(prepared)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;待機中(prepared)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;集計中(storing)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;停止中(down)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;集計中(storing)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;停止中(down)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;サーバー停止中のユーザー画面&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;/images/state1.png&quot; alt=&quot;サーバー停止中&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;サーバー集計中のユーザー画面&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;/images/state2.png&quot; alt=&quot;サーバー集計中&quot; /&gt;&lt;br /&gt;
　ユーザ向け画面では「停止中」と「集計中」の２つの状態しかないのですが、EventMachineを使用しているサーバースクリプトでは、接続確立が完了した状態（post_initイベントが発生後）にならないとコマンドラインで渡したパラメータが有効にならないので、サーバースクリプトを起動した直後の状態を「待機中」として管理しています。&lt;br /&gt;
&lt;!-- other list --&gt;&lt;/li&gt;
  &lt;li&gt;停止中 —– サーバースクリプト停止中&lt;/li&gt;
  &lt;li&gt;待機中 —– サーバースクリプトが起動しているが、TwitterAPIを呼び出していない状態&lt;/li&gt;
  &lt;li&gt;集計中 —– TwitterAPIを呼び出しツイートデータをDBに保存している状態&lt;br /&gt;
※「集計中」から「待機中」には遷移できません（停止して再起動）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;機能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;server側スクリプトの制御（起動、終了、状態確認）&lt;br /&gt;
※遅いノートPC（Atom機）で試したところserver側スクリプト起動に時間がかかり、接続がタイムアウトすることがあったので５秒のsleepを入れています。&lt;/li&gt;
  &lt;li&gt;server側のスクリプトがDBに保存したツイートデータを集計してグラフ表示する。&lt;br /&gt;
※Twitterのデータ構造はハッシュタグを本文とは別に保持しているようですが、SQLで集計する際にハッシュタグで集計するのはコストがかかるので、本文の内容でgroup byするという単純なやり方で妥協しています。詳細は別記事にするつもりです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;er&quot;&gt;ER図&lt;/h3&gt;
&lt;object data=&quot;/pdf/struct_tweetwatch.pdf&quot; width=&quot;600&quot; height=&quot;600&quot;&gt;
&lt;p&gt;ご覧の環境では、object要素がサポートされていないようです。&lt;a href=&quot;/pdf/struct_tweetwatch.pdf&quot;&gt;PDFファイルをダウンロードしてください&lt;/a&gt;&lt;/p&gt;
&lt;/object&gt;

&lt;ul&gt;
  &lt;li&gt;Tweetテーブルへの書き込みはサーバースクリプトのみで、client側のRailsアプリからTweetテーブルへのアクセスはRead onlyです。  &lt;/li&gt;
  &lt;li&gt;Servモデルはユーザがサーバースクリプトを起動する時に指定したTwitter検索タグとサーバースクリプトの状態を管理します。  &lt;/li&gt;
  &lt;li&gt;ユーザは複数のTrackモデル（検索タグ）を保存できますが、サーバースクリプト起動時に指定出来るタグは一つだけです。  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　&lt;/p&gt;

</description>
                <link>http://happyclam.github.io/project/2014-06-07/tweetwatch_client</link>
                <guid>http://happyclam.github.io/project/2014-06-07/tweetwatch_client</guid>
                <pubDate>2014-06-07T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>ツイートを監視して集計する（server側）</title>
                <description>&lt;h3 id=&quot;eventmachine&quot;&gt;EventMachineで簡単インターフェース&lt;/h3&gt;
&lt;p&gt;　初めて&lt;a href=&quot;http://morizyun.github.io/blog/ruby-twitter-stream-api-heroku/&quot;&gt;morizyun氏のこの記事&lt;/a&gt;を読んだときはEventMachineとかforemanとかって何をするものか知らなかったのですが、EventMachineというのは「&lt;a href=&quot;https://morizyun.github.io/blog/reactor-pattern-ruby/&quot;&gt;[Ruby] Reactorパターンについて&lt;/a&gt;」にも書いてある通り、ソケットの受信待機をして貰って簡単にReactorパターンを実現することが出来るツールってことのようです。だからわざわざ自分でプロセス間通信の手続きを書く必要がなくアプリケーションレベルのコマンドを用意してあげるだけで済むのではないか？と思いながら作ったら思惑通りにうまく動いたって感じです。実際に組み込む前には、以下のような単純なサンプルで確認しました。  &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#server側サンプル  
require &#39;eventmachine&#39;

class Serv &amp;lt; EM::Connection
  attr_accessor :track
  def post_init
    puts &quot;myserv: init&quot;
  end

  def receive_data(data)
    puts data
    send_data @track
    EM.stop if data =~ /stop/i
  end

  def connection_completed
    puts &quot;myserv: completed&quot;
  end

  def unbind
    puts &quot;myserv: unbind&quot;
  end
end

EM.run do
  EM.start_server(&quot;127.0.0.1&quot;, 10000, Serv) do |conn|
    conn.track = ARGV[0]
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下のようにコマンドラインパラメータを付加して起動し、  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby myserv.rb O.K.&lt;/code&gt;&lt;br /&gt;
クライアント接続時にServクラスのプロパティに保持されていることを確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#client側サンプル
require &quot;net/telnet&quot;

begin
  localhost = Net::Telnet::new(&quot;Host&quot; =&amp;gt; &quot;localhost&quot;,
                             &quot;Port&quot; =&amp;gt; 10000,
                             &quot;Timeout&quot; =&amp;gt; 1,
                             &quot;Telnetmode&quot; =&amp;gt; false,
                             &quot;Output_log&quot; =&amp;gt; &quot;./temp0.log&quot;,
                             &quot;Prompt&quot; =&amp;gt; &quot;O.K.&quot;)
  localhost.cmd(&quot;search word&quot;) { |c| print c }
  localhost.close
  localhost = nil
  p &quot;end&quot;
rescue Net::ReadTimeout
  p &quot;readtimeout&quot;
  p $!.to_s
rescue
  p $!.to_s
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このserver側の処理を、twitterAPIを使ってDBに検索結果を保存するスクリプトに組み込んで、client側の処理をRails製のサイトに組み込めばいいわけです。&lt;br /&gt;
　あと、server側のスクリプトは、ユーザ毎に起動してユーザがWebサイトから制御しなければならないので、foremanは必要無さそうです。  &lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;サーバースクリプトへのパラメータの受け渡し&lt;/h3&gt;
&lt;p&gt;　EventMachine::Connectionを継承したクラスServにユーザ情報を保存するメンバ変数（プロパティ）を用意して、Webサイト（client側）からサーバースクリプトを起動する時にコマンドライン引数でそれらの値を渡してあげます。起動の際に「10000+ユーザID」をポート番号に指定することでWebサイト利用者とサーバースクリプト利用者を一致させています。EventMachineを使ったプログラム同士が変数を共有する仕組みのようなものがあるかもしれませんが、ステートレスなHTTPで動いているWebサイトから起動するのだから、コマンドラインで渡すのがちょうど良さそうです。&lt;br /&gt;
　twitterのStreamingAPIを使用する部分は&lt;a href=&quot;/project/2014-05-30/tweetwatch&quot;&gt;以前書いた記事&lt;/a&gt;で紹介したmorizyun氏のコードをServ.trackingメソッドに閉じ込めてほぼそのまま動かしています。twitter側でエラーが発生した場合このままでいいのかよく分かりませんが、エラーになればWebサイト側からサーバースクリプトを再起動してもらえばいいという考え方で作ってます。&lt;br /&gt;
　client側からserver側スクリプトに受け渡すパラメータはTwitterAPIを利用するために必要な認証key文字列（４種類）とユーザIDとTwitterのfilterAPIに渡す検索文字列（検索タグ）です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#実際のソースの一部
require &#39;eventmachine&#39;
require &#39;optparse&#39;

class Serv &amp;lt; EM::Connection
  attr_accessor :uid
  attr_accessor :track
  attr_accessor :c_key
  attr_accessor :c_secret
  attr_accessor :a_key
  attr_accessor :a_secret
  def receive_data(data)
    case data
    when /stop/i
      send_data &quot;O.K.&quot;
      EM.stop
    when /check/i
      send_data @track
    省略
      :

  def tracking(track, c_key, c_secret, a_key, a_secret, uid)
    stream = Twitter::JSONStream.connect(
  省略
    :

EM.run do
  EM.start_server(&quot;127.0.0.1&quot;, 10000 + params[&quot;p&quot;].to_i, Serv) do |conn|
    conn.track = params[&quot;t&quot;]
    conn.uid = params[&quot;p&quot;].to_i
    conn.c_key = params[&quot;c&quot;]
    conn.c_secret = params[&quot;k&quot;]
    conn.a_key = params[&quot;s&quot;]
    conn.a_secret = params[&quot;a&quot;]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考サイト&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://keijinsonyaban.blogspot.jp/2010/12/eventmachine.html&quot;&gt;【翻訳】EventMachine入門 &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gihyo.jp/dev/serial/01/ruby/0032&quot;&gt;Reactorで非同期処理をやってみよう（2）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://happyclam.github.io/project/2014-06-06/tweetwatch_server</link>
                <guid>http://happyclam.github.io/project/2014-06-06/tweetwatch_server</guid>
                <pubDate>2014-06-06T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>ツイートを監視して集計する</title>
                <description>&lt;p&gt;Project: 「tweetwatch」: &lt;a href=&quot;https://github.com/happyclam/tweetwatch&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;開発の動機&lt;/h3&gt;
&lt;p&gt;　今年の都知事選の頃、多くのフォロワーを抱えている人（以下a氏と表記）が
&amp;gt;Twitterで&lt;strong&gt;#都知事選&lt;/strong&gt;というタグをつけて自分が投票した候補者の名前を呟けば、それを集計してくれるアプリ作れないかな～&lt;/p&gt;

&lt;p&gt;と物欲しそうに呟いていたのが目に止まりました。&lt;br /&gt;
Yahooのアンケートのように、誰がどれぐらい票を獲得しているかtwitterで独自に確認しようという意図のようです。
　プログラマたるもの、そこで「すぐ出来ますよ」とリプライするような軽率な行動をとってはいけません。職業プログラマなら尚更です。誰かが手を挙げるかもと思いながらしばらく様子を見ていましたが、その呟きに対して反応する人はいなかったようです。こういう場合、相手がどれほどのものを要求しているかわからないので迂闊に出来ますなんて言えませんが、StreamingAPI使えばとりあえず使える程度のものであれば、すぐ出来るんじゃないかと思い調べてみました。  &lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;とりあえずローカル環境で動くもの&lt;/h3&gt;
&lt;p&gt;　「StreamingAPI」で検索すると役に立ちそうなサイトはすぐに見つかりました→&lt;a href=&quot;http://morizyun.github.io/blog/ruby-twitter-stream-api-heroku/&quot;&gt;「Herokuの無料枠でTwitter Stream APIを常時監視 =&amp;gt; DBに保存するRubyコード」&lt;/a&gt;&lt;br /&gt;
このmorizyunって人のサイトは調べ物をしている際にはよくお世話になっていますが、今回見つけた記事も自分の要望その物です。私はherokuは使いませんでしたがほぼこの記事のコードそのままがローカル環境で動作しました。ツイートの集計がしたいのであればDBに溜まったデータに対してSQLを打ち込めば好きな結果が得られます。a氏に教えてあげようかとも思いましたが、おそらくプログラミングやSQLも知らないa氏が実際に自分のPCで動かすためにはそうとうな時間をかけてサポートしてあげないと無理だろうと思って止めておきました。自分が良かれと思って教えても、逆に恨まれることになり兼ねません。そうなんです、自分でニタニタ楽しむためのソフトを作れたとしても、それをひと様に使ってもらおうとするとまた一段とハードルが高くなるんですねぇ（今回は自分で楽しむものさえパクリですが）。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;ひと様が使えるようにするために&lt;/h3&gt;
&lt;p&gt;　最初はDBにデータを格納するだけのシェルスクリプトを起動しながら、ユーザー向けのwebインターフェースを提供してあげればいいだけだからそれほど手間はかからないと思いましたが、そうすると２プロセス動かすことになり、herokuの無料枠では済まなくなります。それに運用環境を何とか用意したとしても、自分のtwitterアカウントの認証キーをそのサービスで利用するとなると、一人しか利用できないwebサービスになってしまいます。twitter社にAPI利用料を支払えば解決ですが、そこまでする気もないので開発に取りかかるのは躊躇してました。&lt;br /&gt;
で結局、  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;運用環境に関してはとりあえず自宅サーバで動くようにしてから考える  &lt;/li&gt;
  &lt;li&gt;twitterのAPIキーをユーザ自身が登録して、そのキーを利用しながらDB格納プロセスを起動するようにする  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という方針で作りました。
&lt;img src=&quot;/images/tweetwatch_screen.png&quot; alt=&quot;集計画面&quot; /&gt;  &lt;br /&gt;
DBにデータを格納するシェルスクリプトは、&lt;a href=&quot;http://morizyun.github.io/blog/ruby-twitter-stream-api-heroku/&quot;&gt;morizyun氏のコード&lt;/a&gt;を叩き台にしてWebサイトから制御するためのプロセス間通信用インターフェースを追加し、そのサーバーとなるシェルスクリプトに接続するクライアントアプリとなるユーザ向けのwebサイトを作る。そのwebサイトは&lt;a href=&quot;http://railstutorial.jp/&quot;&gt;Ruby on Rails チュートリアル&lt;/a&gt;でRSpecの勉強（写経）をしながら作ったものがあったのでそれを流用しています。&lt;br /&gt;
以降、DBにデータを格納する&lt;a href=&quot;/project/2014-06-06/tweetwatch_server/&quot;&gt;&lt;em&gt;サーバースクリプト（server側）&lt;/em&gt;&lt;/a&gt;とRails製&lt;a href=&quot;/project/2014-06-07/tweetwatch_client/&quot;&gt;&lt;em&gt;Webサイト（client側）&lt;/em&gt;&lt;/a&gt;に分けて紹介します。&lt;/p&gt;

&lt;hr /&gt;
</description>
                <link>http://happyclam.github.io/project/2014-05-30/tweetwatch</link>
                <guid>http://happyclam.github.io/project/2014-05-30/tweetwatch</guid>
                <pubDate>2014-05-30T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>ボラティリティについて</title>
                <description>&lt;h3 id=&quot;ivhv&quot;&gt;インプライド・ボラティリティ（IV）とヒストリカル・ボラティリティ（HV）&lt;/h3&gt;
&lt;p&gt;　ボラティリティには２種類ありますが、ニュースの記者や市況解説者が「ボラティリティ」という言葉を理解していないまま使っていることが多いと感じるので、以前から一言言っておきたいと思っていたことを書いておこうと思います。&lt;br /&gt;
　市況解説の中でも現物市場ではなく特に先物市場の解説をしている人が、先物価格の値動きが荒かった日などに「今日はボラの大きな一日でした」と解説しているのを聞くと「(・_・)……ン?」となることがあります、そういう日でもインプライドボラティリティ(IV)が低い日も結構あるからです。オプションの買いで勝負する時はボラが高い時が有利、逆に売りはボラが低い時が有利なのですが、IVが低い日に「今日は（オプション買いに）手出ししなくてよかった」と思っているところに、市況解説で「ボラの高い一日でした」なんて言われると「(‾△‾;)エッ・・そうだっけ？」となるわけです。実際にIVが高かったかどうかはスマイルチャートなどで確認できます。&lt;br /&gt;
　&lt;a href=&quot;http://www.option-dojo.com/kn/225_latest.html&quot;&gt;直近1年のボラティリティー&lt;/a&gt;をみればよく分かりますが、ヒストリカル・ボラティリティ（HV）とインプライド・ボラティリティ（IV）の動きは必ずしも一致していません。原資産である先物の動きがそれ程なくても、オプションの値動きが激しい日もあるということです。それにオプションは先物と違い、満期(SQ)が近づくとボラ(IV)が高くなるという性質（時間価値の減少に伴うもの）もあります。また、日経２２５先物とそれを原資産とする派生商品である日経２２５オプションの関係だけでなく、現物株とそれを原資産とする派生商品（株オプ等）の間でも同じことが言えます。&lt;br /&gt;
　まぁIVとHVの違いは理解しているけど、ボラティリティと言う言葉は単に「値動き」とか「値幅」と同義で使っているだけなので、区別する必要はないと言われればそれまでなのですが。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;誤解を生む説明の仕方&lt;/h3&gt;
&lt;p&gt;　ネットや本ではよく&lt;strong&gt;「ボラティリティが高いとオプションのプレミアムが高くなる、ボラティリティが低いとオプションのプレミアムが低くなる」&lt;/strong&gt;と説明されています。でもこの文を読んでいる人を騙そうとする悪意があるかどうかは別にして、非常に誤解を生みやすい説明だと思います。なぜなら、&lt;strong&gt;ボラティリティが高いと&lt;/strong&gt;という前提条件がIVのことを指しているのかHVのことを指しているのかわかりません。&lt;br /&gt;
　もしIVのことを指しているとしたら、IVが高いとプレミアムが高くなるのはその通りですが、そのIVというものはオプションの価格から算出されているものだから当たり前のことを言っているに過ぎません。IVが高いとオプションのプレミアムが高くなるわけではなく、IVが高いってことはオプションが割高に買われているってことです。&lt;br /&gt;
　また、&lt;strong&gt;ボラティリティが高いと&lt;/strong&gt;という前提条件がHVのことを指しているのだとすると、HVが高いとオプションの&lt;strong&gt;理論価格&lt;/strong&gt;が高くなることは間違いないですが、オプションの&lt;strong&gt;実際の価格&lt;/strong&gt;が理論価格通りに高くなるとは限りません。HVが高いとオプションの価格（プレミアム）が高くなるのではなく、HVが高いとオプションの&lt;strong&gt;理論価格&lt;/strong&gt;が高くなると言うべきです。&lt;br /&gt;
　&lt;strong&gt;ボラティリティが高いと&lt;/strong&gt;という表現がIVのことを指しているとしてもHVのことを指しているとしても、いずれも不正確な文章だと言えます。IVとHVの違いを理解している人でもつい説明する手間を省いて、こういう表現をしがちなんだと思いますが、説明する側がよく理解していないケースも多いと思います。    &lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;違いが分かる説明の仕方&lt;/h3&gt;
&lt;p&gt;　&lt;a href=&quot;http://ja.wikipedia.org/wiki/%E3%83%9C%E3%83%A9%E3%83%86%E3%82%A3%E3%83%AA%E3%83%86%E3%82%A3&quot;&gt;wikipediaによるボラティリティの説明&lt;/a&gt;は学問的で、これはこれでいいのかもしれません。それに「インプライド・ボラティリティとは&lt;strong&gt;現実のオプション市場でついたオプション価格から逆算されたボラティリティ&lt;/strong&gt;のことである」とこれ以上望めない簡潔な言葉で言い表されています。&lt;br /&gt;
しかし、これ&lt;br /&gt;
&lt;img src=&quot;http://upload.wikimedia.org/math/c/8/9/c89911f0951782890cbb855572aa9de7.png&quot; alt=&quot;wikipediaのHVの数式&quot; /&gt;&lt;br /&gt;
とか、&lt;br /&gt;
こういう&lt;br /&gt;
&lt;img src=&quot;http://upload.wikimedia.org/math/1/9/b/19beb2fcdc78f6d56e3e16ad3f04c624.png&quot; alt=&quot;wikipediaのIVの数式&quot; /&gt;&lt;br /&gt;
難しい数式が出てくるので、「要するにどちらも値動きの荒さ、変動率のことだろ？」と言う感じで思考を中断してしまいがちだと思うのです。オプションという商品を理解しているつもりだった自分も、&lt;a href=&quot;http://my-posi.herokuapp.com&quot;&gt;先物・オプション売買損益シミュレーションサイト&lt;/a&gt;を自分で作ってみるまではIVとHVの違いを明確に区別出来ていなくて、よく似たような物ぐらいに考えていました。２つの間には相関関係が非常に薄いにも関わらずです。&lt;br /&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
ヒストリカル・ボラティリティxとオプション理論価格yは以下のように表すことが出来て、  \\
y = ax\\
オプションの実際の価格がy_1であった時に、導き出されるものがインプライド・ボラティリティx_1である。  \\
x_1 = \frac{y_1}{a}\\
&lt;/script&gt;
という感じで簡略化した数式を書いてくれれば２つのボラティリティの関係が分かりやすいと思うんですけど、どうでしょうか？&lt;/p&gt;

</description>
                <link>http://happyclam.github.io/miscellaneous/2014-05-27/my-posi_vola</link>
                <guid>http://happyclam.github.io/miscellaneous/2014-05-27/my-posi_vola</guid>
                <pubDate>2014-05-27T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>DBのカラムに対応しないプロパティ</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;日付型のカラムのデータを年月だけの文字列にしてコンボボックスに表示したい&lt;/h3&gt;
&lt;p&gt;先物やオプションの建玉を入力する時には限月を選ぶ必要がありますが、必要なのは年と月(“2014/06”等の文字列)だけです。でもDBに”年/月”のフォーマットで文字列として格納するのはあまりにも汚い。DBのカラム属性は日付型にしておいた方が何かと便利、というかしておくべきでしょう（日数や時間の差を計算する時に困ります）。&lt;br /&gt;
&lt;img src=&quot;/images/dropdown_exp.png&quot; alt=&quot;限月の選択&quot; title=&quot;限月の選択&quot; /&gt;&lt;br /&gt;
こういう場合、昔PHPで仕事していた時には、文字列型と日付型を相互にフォーマット変換するコードをView上のあちこちに散りばめながら実現していた記憶があります。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;シンプルな実現方法&lt;/h3&gt;
&lt;p&gt;Position.expirationがDBのカラムに対応するプロパティで日付型です。そこにPosition.ym_expirationというDBにカラムが存在しない入出力用のプロパティを用意し、そのsetterとgetterを定義します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Model(Position)&lt;br /&gt;
getter(日付型のデータを、年/月のフォーマットの文字列に変換してして返す)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  def ym_expiration
    return self.expiration.strftime(&quot;%Y/%m&quot;) if self.expiration
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setter(年/月の文字列データを日付01を付加して日付型に変換して格納)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  def ym_expiration=(ym_expiration)
    self.expiration = Date.strptime(ym_expiration + &quot;/01&quot;, &quot;%Y/%m/%d&quot;)
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Viewから呼ばれる、年/月の文字列データを返すメソッド&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;  def get_expiration_list
    :省略
    :
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;View(_edit_position.html.erb)&lt;br /&gt;
Viewでは入出力用に追加したym_expirationプロパティだけを使うようにすれば、あたかもDBに対応するカラムのように扱えます。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ERB&quot;&gt;&amp;lt;td align=&quot;center&quot;&amp;gt;&amp;lt;%= f.select(&quot;ym_expiration&quot;, position.get_expiration_list, {:include_blank =&amp;gt; false}, {:class =&amp;gt; &quot;span6&quot;, :style =&amp;gt; &quot;width:90px;&quot;}) %&amp;gt;&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CakephpやPHP5以上ならたぶん同じことが出来ると思いますが、もうPHPに戻りたくないし調べる気にもなりません&lt;/p&gt;

&lt;hr /&gt;
</description>
                <link>http://happyclam.github.io/programming/2014-05-26/my-posi_tip1</link>
                <guid>http://happyclam.github.io/programming/2014-05-26/my-posi_tip1</guid>
                <pubDate>2014-05-26T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>先物・オプションのシミュレーションサイト</title>
                <description>&lt;p&gt;Project: 「&lt;a href=&quot;http://my-posi.herokuapp.com/&quot;&gt;&lt;strong&gt;みんなのポジション&lt;/strong&gt;&lt;/a&gt;」: &lt;a href=&quot;https://github.com/happyclam/my-posi&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;開発の動機&lt;/h3&gt;
&lt;p&gt;当時、利用している証券会社のシステムが物足りなく信用できないものであったため自作しました。でも自分で作成した後、まもなくネット証券側もシステムをリニューアルして、自分のものより遥に高機能なものに置き換わったのですが、損益グラフを表示した時にグラフのメモリ幅を変更出来ないため見にくいという不満があったりするので、その点でまだは自分のソフトの方が優れているかなと思っています。まぁオプション売買を活発にしている人はそれ程多くないと思いますので、証券会社も力を入れていないのだと思います。５社ほどで取引したことありますが、そもそもオプション売買のシミュレーション機能なんて無い証券会社もありました。&lt;br /&gt;
最近は自分もあまりオプション取引をしていないのでよく知りませんが、今ではWebベースでもWindowsネイティブソフト並にユーザインターフェースに凝ったソフトを提供している証券会社があるかもしれません。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;機能&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;日経225先物、日経225先物ミニ、日経225オプション(CALL,PUT)の建玉を一つのポジション、複数のポジションをまとめたものをストラテジーとして、ユーザ毎の複数のストラテジーの保存。&lt;/li&gt;
  &lt;li&gt;複数の建玉の売買シミュレーションと損益推移（個別・合算）グラフを表示&lt;br /&gt;
※ブラックショールズモデルを利用したオプション理論価格計算に対応しているので、満期（SQ）時の損益だけでなく、現時点での原資産価格（日経225先物価格）毎の損益推移を表示出来ます&lt;/li&gt;
  &lt;li&gt;twitterを利用したユーザー認証とポジションをtwitterで呟く&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;er&quot;&gt;ER図&lt;/h3&gt;
&lt;object data=&quot;/pdf/ERD.pdf&quot; width=&quot;760&quot; height=&quot;480&quot;&gt;
&lt;p&gt;ご覧の環境では、object要素がサポートされていないようです。&lt;a href=&quot;/pdf/ERD.pdf&quot;&gt;PDFファイルをダウンロードしてください&lt;/a&gt;&lt;/p&gt;
&lt;/object&gt;

&lt;p&gt;UserモデルとStrategyモデルが1対多、StrategyモデルとPositionモデルが1対多で関連付けられている単純なテーブル構造です。&lt;br /&gt;
他のテーブルと関連付けられていないCandlestickモデルというのはネット上に転がっている先物価格のロウソク足用のcsvデータを流し込むためのテーブルで、ヒストリカル・ボラティリティ（HV）を計算するためだけに使用しています。HVの計算方法には色々あるようですが、自分が使用したのは&lt;a href=&quot;http://www.option-dojo.com/kn/225_vola.html&quot;&gt;ここ&lt;/a&gt;に記載されている方法に倣っています。&lt;br /&gt;
気が向いたときにcsvデータを手動で更新するという運用の仕方をしてました。画面から手入力するとその値を優先して使用するようにしているので、実際にはHVを手入力して使うことが多かったです。開発当時は無かったのですが、今なら日経平均ボラティリティインデックスがリアルタイムで更新されているのでその値を手入力する方がいいかもしれません。20%（日経平均VIが20ポイント）であれば0.2を入力します。このHVの値を使ってオプション理論価格を算出します。&lt;br /&gt;
※ボラティリティにはHVとは別にインプライド・ボラティリティ（IV）というものがありますが、ボラティリティに関しては別記事を書こうと思います。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;テーブル構造&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Userテーブル&lt;/em&gt;  &lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;名称&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;例&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;name&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;サイト内で使用する独自のユーザ名&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;provider&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;twitter認証APIで返される文字列&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“twitter”&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;screen_name&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;twitter認証APIで返される文字列&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“SappierBoy”&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;uid&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;twitter認証APIで返される文字列&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“1111111111”&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Strategyテーブル&lt;/em&gt;  &lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;名称&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;例&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;draw_type&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;損益グラフを個別表示するか合算表示するか&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;1,未定義&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;interest&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;金利&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.02&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;name&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;ストラテジー名&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“abc戦略”&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;range&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;グラフの幅デフォルト500とした相対数値で拡大・縮小&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;500&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;sigma&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;オプション理論価格計算に使用するボラティリティ(HV)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.2&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Positionテーブル&lt;/em&gt;  &lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;名称&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;内容&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;例&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;distinct&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;商品種別（日経225先物、日経225先物mini、CALLオプション、PUTオプション）&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;exercise&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;行使価格（オプションの場合のみ、先物の場合はnil）&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.02&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;expiration&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;限月（満期月）&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;“2014/06”&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;maturity&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;残存日数（1日に満たない場合も日数換算）&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.1～365&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;number&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;オプション理論価格計算に使用するボラティリティ&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;0.2&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;sale&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;売り、買いの区別&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;unit&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;商品単価&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Candlestickテーブル&lt;/em&gt;&lt;br /&gt;
※どこから先物価格のデータを取得するかでテーブル構造は変わるので省略します。必要なのはオプションの原資産となる先物価格の終値20日分です。私が利用していたのは&lt;a href=&quot;http://k-db.com/&quot;&gt;このサイト&lt;/a&gt;です。&lt;br /&gt;
以下のようにcsvデータをダウンロード  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;wget -O ./lib/futures.csv &quot;http://k-db.com/site/jikeiretsuF.aspx?c=101&amp;amp;year=0&amp;amp;download=csv&quot;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;csvデータから先物価格データを格納      &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rails runner Candlestick::biteoff
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.amazon.co.jp/%E4%B8%96%E7%95%8C%E4%B8%80%E3%82%84%E3%81%95%E3%81%97%E3%81%84%E9%87%91%E8%9E%8D%E5%B7%A5%E5%AD%A6%E3%81%AE%E6%9C%AC%E3%81%A7%E3%81%99-%E7%94%B0%E6%B8%95-%E7%9B%B4%E4%B9%9F/dp/4534040512/ref=sr_1_1?ie=UTF8&amp;amp;qid=1413415898&amp;amp;sr=8-1&amp;amp;keywords=%E3%80%8C%E4%B8%96%E7%95%8C%E4%B8%80%E3%82%84%E3%81%95%E3%81%97%E3%81%84%E9%87%91%E8%9E%8D%E5%B7%A5%E5%AD%A6%E3%81%AE%E6%9C%AC%E3%81%A7%E3%81%99%E3%80%8D&quot;&gt;「世界一やさしい金融工学の本です」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://happyclam.github.io/project/2014-05-24/my-posi</link>
                <guid>http://happyclam.github.io/project/2014-05-24/my-posi</guid>
                <pubDate>2014-05-24T00:00:00+09:00</pubDate>
        </item>

        <item>
                <title>rspecに納得できない</title>
                <description>&lt;p&gt;先日衝動買いした&lt;a href=&quot;http://www.amazon.co.jp/Instant-RSpec-Test-Driven-Development-How-ebook/dp/B00DMYO1QK&quot;&gt;Instant RSpec Test-Driven Development How-to [Kindle版]&lt;/a&gt;の最初に出てくるサンプルコード&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;#location_spec.rb
describe Location do
  describe &quot;#initialize&quot; do
    it &quot;sets the latitude and longitude&quot; do
      loc = Location.new(:latitude =&amp;gt; 38.911268,
                         :longitude =&amp;gt; -77.444243)
      loc.latitude.should == 38.911268
      loc.longitude.should == -77.444243
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;上記テストを通過させるために「自分が書いたコード」が以下のもの&lt;code&gt;rspec failed&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;   #my_answer.rb  
   class  Location  
       attr_accessor :latitude  
       attr_accessor :longitude  
       def initialize(lati=nil, long=nil)  
           @latitude = lati  
           @longitude = long  
       end  
   end  
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;「リファクタリング前のコード」として本で紹介されているコード&lt;code&gt;rspec passed&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;   #bad_answer.rb
   class  Location
       def initialize(args = {});end
       def latitude
           38.911268
       end
       def longitude
           -77.444243
       end
   end
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;「リファクタリング後のコード」として本で紹介されているコード&lt;code&gt;rspec passed&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Ruby&quot;&gt;   #model_answer.rb
   class Location
       attr_accessor :latitude, :longitude
       def initialize(args = {})
           self.latitude = args[:latitude]
           self.longitude = args[:longitude]
       end
   end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストを通過させるためだけに書かれたような「リファクタリング前のコード」がエラーにならないのに、上記「自分のコード」がエラーになるのは納得がいかない。&lt;br /&gt;
自分のコードに何かエラーにしなければならない理由があるのか？自分にはわからないので誰か教えてください。&lt;/p&gt;

</description>
                <link>http://happyclam.github.io/programming/2014-05-17/inflexible-rspec</link>
                <guid>http://happyclam.github.io/programming/2014-05-17/inflexible-rspec</guid>
                <pubDate>2014-05-17T00:00:00+09:00</pubDate>
        </item>


</channel>
</rss>
